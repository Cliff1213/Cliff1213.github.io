<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>六角學院 UI 觀念直播班心得</title>
    <url>/2022-01-17-hexschool-UI/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本身不是設計相關科系，但還是希望能透過這次的＂六角學院－UI設計觀念必修直播班＂來增進一點 UI/UX 的相關知識，雖然很遺憾沒有完美的走到終點，但還是幫自己記錄一下這次參與直播班的心路歷程。</p>
<span id="more"></span>

<h2 id="報名這堂課的契機是？"><a href="#報名這堂課的契機是？" class="headerlink" title="報名這堂課的契機是？"></a>報名這堂課的契機是？</h2><p>相信在仿間與 UI/UX 設計相關的課程一定數不勝數，但是為什麼我會選擇”六角學院”的課程？原因很簡單，<del>就是信仰（沒</del>，其實早在先前就有報名六角的切版班了，而六角學院整體給我的氛圍是很團結的；你會有自己的小組以及永遠在前線待命等你發問的助教，當然少不了最敬業的老師。而因為你是跟著大家一起學習，所以當腦海衍生出想偷懶的想法同時，也會有一種被人從後面拍肩膀並對你說「欸我先走一步哩，你就繼續耍廢。」的感覺，讓你在學習上能自律。</p>
<h2 id="每週的學習過程："><a href="#每週的學習過程：" class="headerlink" title="每週的學習過程："></a>每週的學習過程：</h2><p>這一次表訂為期四週的直播課程大綱如下：</p>
<ul>
<li><p><strong>Week 1：掌握頁面所有元件</strong></p>
<p>本次主要使用的設計工具為 Figma，算是目前的主流之一。而這週就是帶你認識軟體的操作介面；雖然我在開課前有先觀看課前釋出的體驗營直播錄影，但是自己在操作上還是有許多不解的地方；不過在聽完第一週的直播後，我私下就利用時間把直播錄影再看一次並且針對操作上比較複雜的地方寫了筆記，<del>對我來說都很複雜所以筆記滿到哭</del>，而這些後續幫助我在練習軟體上幫助很多。</p>
</li>
<li><p><strong>Week 2：帶你從草稿到完稿</strong></p>
<p>這週認識了一些網頁在設計的過程中比較常見會遇到的設計模式，像是C.R.A.P的設計準則，或是在規劃網頁時常用的 AIDA Modal；再來會介紹甚麼是 Wireframe。這週基本上每個人會開始設計第一個 Landing Page，對我這個設計白癡來說算是頗有挑戰性的，<del>（我做的很像釣魚網站</del>。</p>
</li>
<li><p><strong>Week 3：伸縮自如的響應式設計</strong></p>
<p>RWD對我來說雖然早就不陌生，但是這堂課讓我更加的理解網頁在不同寬度的視窗做切換時的一些細節以及過往不懂的知識，像是中斷點、網格切換時的邏輯或是兩個物件之間的間距都是一個學問。</p>
</li>
<li><p><strong>Week 4：讓介面動起來</strong></p>
<p>這週的直播內容算是比較有趣的一次，主要都是在介紹 Prototype 的運作，很多動畫都是在網頁中常見的，但是直播以外的時間幾乎都是拿來做最終作品，從這週開始會覺得時間緊湊起來。</p>
</li>
<li><p><strong>Week 5：加碼內容</strong></p>
<p>標題說是表訂為期四週，但怎麼會還有第五週呢？原因是老師擔心有些同學工作比較忙碌，可能會沒有時間做最終作品，因此開放最終作品有達到一定進度的同學提供額外的一次直播並且延長作品繳交的期限<del>（老師你是神吧</del>，而加碼直播課程的內容是如何把作品上傳到 Behance 以及作品呈現的排版建議；為了拿到這張門票我花了不少時間不反覆改我的作品版型，但一切都值得。</p>
</li>
</ul>
<h2 id="建議："><a href="#建議：" class="headerlink" title="建議："></a>建議：</h2><p>無論你是不是設計背景，或是你有想轉職 UI 設計師的想法但是沒有明確的學習目標，不仿可以考慮看看六角學院的 UI 設計直播課程；好的學習環境跟課程規劃這裡都提供給你了，但能不能有所成長還是決定在自己身上，以我自己為例，很多觀念在直播上課的當下我是充滿疑惑的，但課後我會盡可能的把當天的直播錄影重頭到尾看一次並且隨時暫停錄影做筆記，因為對我來說暫停的當下會先思考一次問題的所在，而作筆記的時候會間接複習剛剛思考的問題，這確實大幅提升了我的學習效率，當然這是我自己的做法，每個人的學習方式不盡相同，但這裡要表達的重點是自己必須要有所規劃，再搭配現有的資源去做結合，才能最有效率的學習。</p>
<h2 id="結語："><a href="#結語：" class="headerlink" title="結語："></a>結語：</h2><p>雖然這次的過程對我來說真的不容易，但還是很榮幸可以跟到這次的直播課程，畢竟這是我有史以來最認真跟 UI/UX 相處的一段時間。很喜歡一個人專注在思考或是做某一件事情時的感覺，而這次直播班讓我深刻體會到了，遺憾的是我沒有在時間內完成最終作品，雖然對特別延長繳交期限的老師很不好意思，但這個作品我還是會利用時間把它完成，至少有始有終也算是對參與這個課程的自己負責吧。</p>
<p>最後我要特別感謝<strong>熾炎鐵甲狼</strong>的組員，特別是組長都會幫忙繳交小組作業以及提醒繳交的時間，也要感謝其他組員都會提出疑問和幫忙解答，雖然各位都很忙，但都盡可能的參與小組任務，這邊讓我私心合影紀念一下。</p>
<p><img src="https://i.imgur.com/kQuBKJ5.png" alt="img"></p>
<p>最後的最後，要感謝聲音自帶磁性的俊儀老師和唯一的 Joanne 助教願意回答我提出的蠢問題<del>（假日問跨年也問，吵到真的不好意思</del>，雖然最後階段的作品屢次被退回，但每次的建議我都有仔細看，讓我這個設計肢障提升了設計觀念之餘，也培養了專注思考的能力，感謝兩位的用力鞭打，也辛苦你們了。</p>
<p><img src="https://i.imgur.com/GIbWClM.png?1"></p>
]]></content>
      <categories>
        <category>心得文</category>
      </categories>
      <tags>
        <tag>UI/UX</tag>
        <tag>六角學院</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM 筆記</title>
    <url>/2022-02-07-npm-note/</url>
    <content><![CDATA[<p>最近開始接觸 JS 套件，但在過程中因為版本之間的相容問題，幾乎是讓我踩到一堆深不見底的坑，後來開始找了很多資料並參考其他開發者使用以及管理套件的方式，然而相關資料都離不開 NPM，於是決定來找它泡茶一下，順便紀錄一下過程中學到的知識。</p>
<span id="more"></span>

<hr>
<h2 id="甚麼是-NPM？"><a href="#甚麼是-NPM？" class="headerlink" title="甚麼是 NPM？"></a>甚麼是 NPM？</h2><p>全名 Node Package Manager，是一種套件管理工具，簡言之就是匯集各種 Node js 套件的線上庫。</p>
<hr>
<h2 id="安裝-Node-JS-amp-NPM"><a href="#安裝-Node-JS-amp-NPM" class="headerlink" title="安裝 Node JS &amp; NPM"></a>安裝 Node JS &amp; NPM</h2><p><img src="https://i.imgur.com/O3WVkU4.png"></p>
<p>上圖是 <a href="https://nodejs.org/en/">Node js 官網</a>所提供的下載點，可以看到分成兩個部分，左邊為 LTS（Long Term Support），屬於長期支援維護的版本，可以理解成較穩定的版本；右邊 Current 的部分則是最近、最新的版本。</p>
<p>Node js 官方在版本的釋出上有自己的邏輯，通常會在每年四月份發布偶數版本，十月份發布奇數版本，可以從下圖看到近期的版本維護狀態：</p>
<p><img src="https://i.imgur.com/zOGuPaZ.png"></p>
<p>新的版本在發布後，版本號如果是奇數，六個月後就不會再維護；但版本號如果是偶數，半年後就會進入長期維護（Active LTS）的狀態，並保證在接下來的三十個月內會更新與修復各種問題，因此新專案通常會選擇安裝 LTS 的版本。</p>
<p>接著進入正題，要如何安裝 NPM？這個問題其實在安裝 Node 後就已經解決了，因為 NPM 是 Node js 開發環境預設的套件管理工具（Packge Manager），因此在安裝 Node 的同時，NPM 會跟著一起安裝。</p>
<blockquote>
<p>因為每個專案所使用的 Node 版本不盡相同，因此為了避免產生版本與套件之間的相容問題，建議使用 NVM（Node Version Manager）來切換 Node 版本。</p>
</blockquote>
<p>安裝完成後，開啟任一終端機即可開始操作。</p>
<hr>
<h2 id="檢視版本"><a href="#檢視版本" class="headerlink" title="檢視版本"></a>檢視版本</h2><p>在終端機輸入以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>如果顯示 npm 版本號，表示安裝成功，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.9.0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="初始化目錄"><a href="#初始化目錄" class="headerlink" title="初始化目錄"></a>初始化目錄</h2><p>指定任一資料夾為目錄，輸入以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>此時會顯示訊息要求輸入專案的一些資訊，如下所示：</p>
<p><img src="https://i.imgur.com/bGQsEeb.png"></p>
<p>上述部分只需要持續按下 Enter 即可。</p>
<p>接著透過編輯器開啟專案資料夾，可以看到一個 package.json 的檔案，這是資料夾在進行 npm 初始化後所產生的 json 格式檔案，內容主要是紀錄專案的資訊，如下所示：</p>
<p><img src="https://i.imgur.com/yjjj8ZV.png"></p>
<hr>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><h3 id="安裝至全域"><a href="#安裝至全域" class="headerlink" title="安裝至全域"></a><strong>安裝至全域</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g 套件名稱</span><br></pre></td></tr></table></figure>

<p>安裝套件時，在指令加入 <code>-g</code>，套件就會被安裝在全域，也就是當前使用的電腦上；這樣做的好處是，當有其他專案需要使用這個套件時，就不用再另外安裝該套件在專案資料夾中。</p>
<h3 id="安裝至指定目錄"><a href="#安裝至指定目錄" class="headerlink" title="安裝至指定目錄"></a><strong>安裝至指定目錄</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save 套件名稱</span><br></pre></td></tr></table></figure>

<p>以指定專案資料夾為目錄並執行上述指令，套件就會被安裝在該資料夾中，在加入 <code>--save</code> 參數後，這個套件就會被記錄在 package.json 檔案裡，下列以安裝 jquery 為範例：</p>
<p><img src="https://i.imgur.com/n1jRC8k.png"></p>
<p>可以看到檔案中新增了一個 dependencies 項目，並且在下方可以看到已安裝的 jquery 套件與對應版本。</p>
<p>因為不同專案所使用的套件與套件版本不同，因此在接手別人開發的專案時，可以先依據 dependencies 中的資訊來安裝對應的套件。</p>
<hr>
<h2 id="安裝指定版本套件"><a href="#安裝指定版本套件" class="headerlink" title="安裝指定版本套件"></a>安裝指定版本套件</h2><p>正常的情況下，安裝下來的套件預設會是最新的版本，但一些較舊的專案可能不支援新版本的套件，此時就可以使用以下指令來安裝指定版本的套件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱@版本號</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="版本數字意義"><a href="#版本數字意義" class="headerlink" title="版本數字意義"></a>版本數字意義</h2><p>通常套件的版本會以 3 個數字的格式來表示，但每個數字所代表的意義其實不同，下列以 jquery 為例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jquery&quot;： &quot;^3.6.0&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>3</code> - 主要版本，通常會因為重大改版而增加版本號。</li>
<li><code>6</code> - 次要版本，依當前的主要版本為基準，新增功能時增加版本號。</li>
<li><code>0</code> - 修正版本，依當前的主要版本為基準，修正錯誤時增加版本號。</li>
</ul>
<p>開發的過程中通常不會直接更新主要版本，因為這樣有極高的機率毀掉專案，正常的情況下只會更新次要版本或修正版本，依專案的開發情形而定。</p>
<hr>
<h2 id="版本標示符號"><a href="#版本標示符號" class="headerlink" title="版本標示符號"></a>版本標示符號</h2><ul>
<li><code>^x.x.x</code> - 安裝套件時，自動更新次要與修正版本，主要版本不做更動。</li>
<li><code>~x.x.x</code> - 安裝套件時，自動更新修正版本，主要與次要版本不做更動。</li>
<li><code>latest</code> - 安裝套件時，自動安裝最新版本。</li>
<li>未加入任何符號，表示只安裝當前輸入的版本。</li>
</ul>
<p>更新套件版本的方式，只需要將專案資料夾中的 node_modules 刪除，再重新執行以下指令，系統就會根據該專案中的 package.json 檔案設置來安裝所有會使用到的套件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="移除套件"><a href="#移除套件" class="headerlink" title="移除套件"></a>移除套件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall 套件名稱</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上述指令只會將專案資料夾中的套件移除，但是並不會同時更新 package.json 檔案中的設置，如果有這個需求，只需要在指令中加入 <code>--save</code> 參數即可。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://medium.com/html-test/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E4%BD%BF%E7%94%A8npm%E5%A5%97%E4%BB%B6-317beefdf182"><em>從零開始：使用NPM套件</em></a></li>
<li><em><a href="https://linyencheng.github.io/2020/03/22/tool-npm/">npm 入門到進階</a></em></li>
</ul>
]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Font-Family 淺規則</title>
    <url>/2022-03-02-font-family/</url>
    <content><![CDATA[<p>回想過去在初學網頁的時候，對於 font-family 這個屬性一直處於很難相處的狀態，常會發生明明設定了字體，也沒有語法上的錯誤，但是網頁上呈現出來的結果總是不如預期；剛好前陣子在練習切版的時候又遇到了這方面的問題，於是決定投入一點時間研究問題的所在，藉此讓自己重新認識這個屬性。</p>
<blockquote>
<p>本篇僅討論 font-family 字體設定的基本觀念，沒有過多的字體介紹，主要方便自己做後續的查閱用途。</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="Font-Family-設定規則"><a href="#Font-Family-設定規則" class="headerlink" title="Font-Family 設定規則"></a>Font-Family 設定規則</h2><p>基本上只要是網頁設計，都會使用到的屬性，可以自訂頁面上的文字字體，但是初學者在使用這個屬性之前，為了避免結果不如預期，建議需要先理解一些設定上的規則。</p>
<h3 id="字體套用邏輯"><a href="#字體套用邏輯" class="headerlink" title="字體套用邏輯"></a>字體套用邏輯</h3><p>Font-Family 雖然可以設定多個屬性值，但是並不會將所有寫入的字體都一起套用，而是會根據瀏覽器對該字體的支援與否，由左至右依序判斷，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: 字體A, 字體B, 字體C;</span><br></pre></td></tr></table></figure>

<p>假設使用者的電腦系統中僅存在 “字體B”，此時瀏覽器載入網頁時，會根據上述設定先判斷系統內是否有對應的字體A，但因為系統中找不到這個字體，因此會跳過該字體並判斷下一個字體B，此時找到字體B之後，就會套用該字體，並且不再往下進行判斷。</p>
<h3 id="語法注意事項"><a href="#語法注意事項" class="headerlink" title="語法注意事項"></a>語法注意事項</h3><p>在部分字體的選用上，同一個字體可以選擇使用中文名稱或英文名稱的屬性值設定，其結果會相同，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;Microsoft JhengHei&quot;</span>;</span><br><span class="line"><span class="attribute">font-family</span>: 微軟正黑體;</span><br></pre></td></tr></table></figure>

<p>從上述語法中可以發現，第一行的字體加上了雙引號，這是因為該字體的名稱之間如果存在空白，在不加上雙引號的情形下，瀏覽器會無法辨識而導致讀取失敗。</p>
<p>另一個值得注意的是，雖然使用中文名稱來設定字體結果與英文名稱相同，但是只單獨設定中文名稱的話，可能會遇到編碼的問題而導致結果不如預期，因此會建議使用英文名稱的屬性值，或是中、英文一起使用，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;Microsoft JhengHei&quot;</span>, 微軟正黑體;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Font-Family-字體類型"><a href="#Font-Family-字體類型" class="headerlink" title="Font-Family 字體類型"></a>Font-Family 字體類型</h2><p>在當今這麼大量的字體中，主要可以分為 “指定字體” 與 “通用字體” 兩種類型。</p>
<h3 id="指定字體（family-name）"><a href="#指定字體（family-name）" class="headerlink" title="指定字體（family-name）"></a>指定字體（family-name）</h3><p>不同的字體也會影響網頁的視覺感受，因此在選用字體時，通常會優先使用指定的字體。</p>
<h3 id="通用字體（generic-family）"><a href="#通用字體（generic-family）" class="headerlink" title="通用字體（generic-family）"></a>通用字體（generic-family）</h3><p>通用字體可以理解成多數的電腦系統中，內建就已存在的字體，常見的通用字體有以下五種，其中無襯線體、襯線體使用最為廣泛：</p>
<ul>
<li>sans-serif（無襯線體 / 黑體）</li>
<li>serif（襯線體 / 明體）</li>
<li>cursive（手寫體）</li>
<li>monospace（等寬體）</li>
<li>fantasy（幻想體）</li>
</ul>
<h3 id="設定方式"><a href="#設定方式" class="headerlink" title="設定方式"></a>設定方式</h3><p>雖然可以透過指定字體名稱的方式，來達到自訂網頁上想要呈現的字體，但是並非所有電腦系統都有對應的指定字體，因此在使用指定字體時，通常都會在 font-family 屬性值的<strong>最後方位置</strong>設定預設的通用字體；而前面有提到 font-family 是由左至右判斷屬性值，所以當瀏覽器不支援或無法從系統中找到前方所對應的指定字體時，就會套用最後設定的通用字體，設定格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: 指定字體, <span class="string">&quot;指定 字體&quot;</span>, 通用字體;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="字體順序觀念"><a href="#字體順序觀念" class="headerlink" title="字體順序觀念"></a>字體順序觀念</h2><p>本篇一開始在設定規則的地方有簡單提到字體是由左邊開始判斷，但是在順序方面還有一些重要觀念需要熟記，這邊先記住以下設定順序，後續會說明原因：</p>
<p>設定順序：<strong>英文字體 &gt; Linux &gt; Mac &gt; Windows &gt; 通用字體</strong></p>
<!-- 這部分一直沒有比較好的解釋 -->



<h3 id="中、英文順序"><a href="#中、英文順序" class="headerlink" title="中、英文順序"></a>中、英文順序</h3><p>一個網頁通常會存在多個語言（以中、英文為例），但是並非所有的字體都同時支援中、英文，因此許多網頁會利用這個由左至右判斷的技巧，分別針對中文與英文各別設定不同的字體，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: Arial, 微軟正黑體;</span><br></pre></td></tr></table></figure>

<p>上述設定中，Arial 只有英文字體，而微軟正黑體則是中、英文字體都有，因此瀏覽器在判斷 Arial 之後，就會因為符合條件而套用英文字體，而中文會因為找不到對應字體則往下判斷微軟正黑體並套用，此時網頁上的中文與英文就會呈現不同字體的效果。</p>
<p>但是如果順序換成微軟正黑體在前面，瀏覽器就會先判斷微軟正黑體，因為該字體中、英文都可以使用，所以網頁上的兩種語言都會套用成微軟正黑體，而後面的 Arial 會因為英文字體已套用成微軟正黑體而不會被讀取。</p>
<p>因此，正確的屬性值順序為<strong>英文字體在前面，中文字體在後面。</strong></p>
<h3 id="字體使用率與順序"><a href="#字體使用率與順序" class="headerlink" title="字體使用率與順序"></a>字體使用率與順序</h3><p>每個作業系統都有自己的系統字體，例如 -apple-system 與 BlinkMacSystemFont 分別是 iOS 以及 macOS 的系統字體，並且前者只能使用在 Safari 瀏覽器上，後者則是用於 Chrome，像這種只能使用在特定系統或瀏覽器的字體，順序就需要放在前面，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">&quot;Segoe UI&quot;</span>, <span class="string">&quot;Microsoft JhengHei&quot;</span>, Roboto, <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span><br><span class="line">	     <span class="comment">/* mac系統字體, iOS系統字體,	windows英文系統字體, 微軟正黑體, Android系統字體, iOS系統字體, 通用字體, 通用字體 */</span></span><br></pre></td></tr></table></figure>

<p>假設使用者電腦系統為 windows，瀏覽器因為在系統中找不到 -apple-system 與 BlinkMacSystemFont 而直接跳過這兩個字體，而下一個 Segoe UI 屬於 windows 的英文系統字體，因此英文字體就會套用 Segoe UI，中文字體則是因為 Segoe UI 並沒有對應的中文而判斷下一個值，最終套用 Microsoft JhengHei。</p>
<p>如果電腦系統是 macOS 並且使用 Chrome 瀏覽網頁，當瀏覽器在讀取到 -apple-system 時，就會套用對應的中文及英文字體，並且不再往下判斷。</p>
<p>因此，為了適應各種不同的瀏覽器與作業系統，在設定字體時需要把<strong>較少使用到的字體放前面，較常使用到的字體放後面。</strong></p>
<hr>
<h2 id="實務範例"><a href="#實務範例" class="headerlink" title="實務範例"></a>實務範例</h2><p>附上幾個知名企業的字體設定當作參考，有興趣的也可以自行研究順序邏輯。</p>
<p>Apple（台灣）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;SF Pro TC&quot;</span>, <span class="string">&quot;SF Pro Text&quot;</span>, <span class="string">&quot;SF Pro Icons&quot;</span>, <span class="string">&quot;PingFang TC&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, <span class="string">&quot;Helvetica&quot;</span>, <span class="string">&quot;Arial&quot;</span>, sans-serif;</span><br></pre></td></tr></table></figure>

<p>微軟台灣：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&#x27;Segoe UI&#x27;</span>, SegoeUI, <span class="string">&#x27;Microsoft JhengHei&#x27;</span>, 微軟正黑體, <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica, Arial, sans-serif;</span><br></pre></td></tr></table></figure>

<p>Google：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: arial, sans-serif;  <span class="comment">/* 不愧是 Google，連字體設定都這麼簡約 */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.oxxostudio.tw/articles/201811/css-font-family.html">CSS font-family 詳細介紹</a></li>
<li><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/180456/#outline__1_2_1">最標準的系統字型規範 font-family</a></li>
<li><a href="https://www.casper.tw/css/2014/01/01/font-family/">font-family要怎麼玩</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>font-family</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 指令概述</title>
    <url>/2022-01-20-git-note/</url>
    <content><![CDATA[<p>在初接觸到網頁領域的時候，偶爾會聽到版本控制一詞，當時的理解是把每一個完整的專案，當作一次的版本發佈到網路空間呈現出來；事實上確實是如此，但是實際在接觸到 Git 之後，才理解到版本控制背後有很多深層的學問可以探究；這段時間為了拓展技能樹，不斷的逼自己學習新的技能，近期剛好把 Git 告一個段落，順便藉由這次機會把學到的知識做個筆記。</p>
<blockquote>
<p>本篇僅記錄這段時間學習 Git 所做的筆記，主要是用來找資料與複習，內容較為白話也沒有過多專有名詞的解釋。</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="環境安裝"><a href="#環境安裝" class="headerlink" title="環境安裝"></a>環境安裝</h2><p>在進入正題之前，必須先根據電腦的作業系統安裝 <a href="https://git-scm.com/">Git</a> 的環境，安裝成功後在 Git 資料夾中會有 “Git Bash” 的應用程式，可以透過它來操作 Git 指令；或是使用電腦本身就有的命令提示字元 / 終端機也可以，依使用者習慣為主。</p>
<hr>
<h2 id="Command-Line-基本指令"><a href="#Command-Line-基本指令" class="headerlink" title="Command Line 基本指令"></a>Command Line 基本指令</h2><p>使用 Git 時，通常還會搭配一些終端機的基本指令去輔助操作，常用的 command line 指令如下：</p>
<h3 id="移動到指定目錄"><a href="#移動到指定目錄" class="headerlink" title="移動到指定目錄"></a><strong>移動到指定目錄</strong></h3><p>指令：<code>cd 資料夾路徑</code></p>
<p>除了直接輸入路徑，也可以直接將資料夾拖曳至終端機視窗中。</p>
<h3 id="展開當前目錄"><a href="#展開當前目錄" class="headerlink" title="展開當前目錄"></a><strong>展開當前目錄</strong></h3><p>指令：<code>ls</code></p>
<p>列出當前目錄的所有檔案。</p>
<h3 id="回前一層目錄"><a href="#回前一層目錄" class="headerlink" title="回前一層目錄"></a><strong>回前一層目錄</strong></h3><p>指令：<code>cd ..</code></p>
<p>從當前位置回到前一層目錄。</p>
<h3 id="回到根目錄"><a href="#回到根目錄" class="headerlink" title="回到根目錄"></a>回到根目錄</h3><p>指令：<code>cd\</code></p>
<p>直接移動到根目錄。</p>
<h3 id="新增資料夾"><a href="#新增資料夾" class="headerlink" title="新增資料夾"></a><strong>新增資料夾</strong></h3><p>指令：<code>mkdir 資料夾名稱</code></p>
<p>在當前目錄下建立一個資料夾。</p>
<h3 id="新增檔案"><a href="#新增檔案" class="headerlink" title="新增檔案"></a><strong>新增檔案</strong></h3><p>指令：<code>touch 檔案名稱.檔案類型</code></p>
<p>在當前目錄建立一個檔案。</p>
<h3 id="刪除檔案"><a href="#刪除檔案" class="headerlink" title="刪除檔案"></a>刪除檔案</h3><p>指令：<code>del 檔案名稱.檔案類型</code></p>
<hr>
<h2 id="Git-版本檢視"><a href="#Git-版本檢視" class="headerlink" title="Git 版本檢視"></a>Git 版本檢視</h2><p>環境安裝完成後開啟終端機，嘗試輸入指令 <code>$ git version</code> ，如果若出現 Git 版本訊息即表示安裝成功。</p>
<p>版本訊息範例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git version</span><br><span class="line">git version 2.32.0.windows.2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Git-環境設定"><a href="#Git-環境設定" class="headerlink" title="Git 環境設定"></a>Git 環境設定</h2><p>使用 Git 進行版本控制時，每一個更新紀錄的更新人、更新時間以及部分的內容都會被記錄；因此在開始使用 Git 之前，需要先設定一些基本的資訊。</p>
<h3 id="設定使用者暱稱"><a href="#設定使用者暱稱" class="headerlink" title="設定使用者暱稱"></a><strong>設定使用者暱稱</strong></h3><p>指令：<code>$ git config --global user.name &quot;使用者暱稱&quot;</code></p>
<h3 id="設定使用者信箱"><a href="#設定使用者信箱" class="headerlink" title="設定使用者信箱"></a><strong>設定使用者信箱</strong></h3><p>指令：<code>$ git config --global user.email &quot;使用者信箱&quot;</code></p>
<h3 id="查看設定值"><a href="#查看設定值" class="headerlink" title="查看設定值"></a><strong>查看設定值</strong></h3><p>指令：<code>$ git config --list</code></p>
<hr>
<h2 id="Git-常用指令"><a href="#Git-常用指令" class="headerlink" title="Git 常用指令"></a>Git 常用指令</h2><p>Git 基本操作流程示意圖：</p>
<p><img src="https://i.imgur.com/zLOR8aN.png"></p>
<p>Git 操作方式會根據不同情境而有所差異，但是運作原理相同。</p>
<h3 id="建立本地端儲存庫"><a href="#建立本地端儲存庫" class="headerlink" title="建立本地端儲存庫"></a><strong>建立本地端儲存庫</strong></h3><p>指令：<code>$ git init</code></p>
<p>儲存庫（Repositiory）是用來存放一個專案所有檔案的資料夾；建立方式只需要開啟終端機，並以任意資料夾作為根目錄並輸入上述指令即可。</p>
<p>以檔名為 Project 的資料夾為例，建立成功後會顯示以下訊息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in C:/Users/user/Desktop/Project/.git/</span><br></pre></td></tr></table></figure>

<p>此外也可以開啟該資料夾，查看根目錄是否多出一個 .git 的資料夾，它主要是用於監控與紀錄資料夾內檔案的所有變動；通常 .git 資料夾預設會隱藏，可以從資料夾上方列的 “檢視” 開啟隱藏的項目。</p>
<h3 id="檢視狀態"><a href="#檢視狀態" class="headerlink" title="檢視狀態"></a><strong>檢視狀態</strong></h3><p>指令：<code>$ git status</code></p>
<p>查看工作目錄與暫存區的檔案是否有變動；可得知哪些檔案被修改，哪些檔案尚未被 Git 追蹤。</p>
<p>以 Project（本地端儲存庫）為例，輸入指令時顯示以下訊息，表示尚未做任何檔案新增或編輯：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>



<h3 id="加入暫存區"><a href="#加入暫存區" class="headerlink" title="加入暫存區"></a><strong>加入暫存區</strong></h3><p>指令：<code>$ git add .</code></p>
<p>工作目錄有新增或編輯的檔案時，可以輸入上述指令將檔案加入暫存區（索引），並等待提交成一次新的版本。</p>
<p>新增檔案 index.html 在 Project 資料夾中，並輸入指令 <code>$ git status</code> 查看狀態時顯示以下訊息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line">Untracked files:  # 偵測到未被追蹤檔案</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        index.html  # 檔案名稱</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>訊息顯示偵測到尚未追蹤的檔案 index.html，此時可以輸入上述指令將檔案加入暫存區。</p>
<p>檔案加入暫存區後，輸入 <code>$ git status</code> 查看狀態時顯示以下訊息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:  # 工作目錄的檔案已被加入暫存區等待提交</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   index.html  # 檔案名稱</span><br></pre></td></tr></table></figure>



<p>補充說明：</p>
<p>使用指令 <code>$ git status</code> 查詢狀態時，如果是工作目錄新增的檔案，狀態會是 <code>Untracked files</code>，表示尚未加入暫存區追蹤；但如果是暫存區已存在，後續再進行修改的檔案，狀態會是 <code>Changes not staged for commit</code>，並且檔案前面會標註 <code>modified</code>，表示該檔案已被編輯，需要再次加入暫存區等待提交。</p>
<p>下列為檔案在不同狀態下所表示的意思：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed        # 已加入暫存區，準備提交成一次新的版本紀錄。</span><br><span class="line">Changes not staged for commit  # 已被追蹤，但尚未加入至暫存區。</span><br><span class="line">Untracked file                 # 新建立，尚未被追蹤的檔案。</span><br></pre></td></tr></table></figure>



<h3 id="提交更新（Commit）"><a href="#提交更新（Commit）" class="headerlink" title="提交更新（Commit）"></a><strong>提交更新</strong>（Commit）</h3><p>指令：<code>$ git commit -m &quot;提交內容敘述&quot;</code></p>
<p>將暫存區的檔案提交一次新的版本紀錄。</p>
<p>以下為成功提交暫存區的檔案 index.html 後顯示的訊息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;新增 index&quot;</span><br><span class="line">[master (root-commit) ce9d927] 新增 index  # 提交內容敘述</span><br><span class="line">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 index.html  # 被提交的檔案</span><br></pre></td></tr></table></figure>

<p>提交暫存區的檔案後，輸入 <code>$ git status</code> 查看狀態時顯示以下訊息，表示沒有更動需要提交，並且目前工作目錄乾淨，完全沒有檔案新增、修改或刪除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>



<h3 id="查詢提交紀錄"><a href="#查詢提交紀錄" class="headerlink" title="查詢提交紀錄"></a><strong>查詢提交紀錄</strong></h3><p>指令：<code>$ git log</code></p>
<p>列出過去幾筆的提交紀錄。</p>
<p>以下為提交紀錄的顯示內容範例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit ce9d92723df3302156a9523453c0fff21f7fdcc0 (HEAD -&gt; master)</span><br><span class="line">Author: Cliff Chu &lt;wave99487chu@gmail.com&gt;</span><br><span class="line">Date:   Sun Jan 23 17:53:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    新增 index</span><br></pre></td></tr></table></figure>

<p>顯示的筆數較多時，按下鍵盤 q 即可返回原內容。</p>
<hr>
<h2 id="忽略檔案"><a href="#忽略檔案" class="headerlink" title="忽略檔案"></a><strong>忽略檔案</strong></h2><p>不希望某些檔案被 Git 追蹤時，可以建立一個 .gitignore 檔案，透過編輯器開啟檔案後，輸入希望被忽略的檔案名稱和檔案類型並儲存即可；需要注意的是 .gitignore 檔案本身不會被忽略。</p>
<p>被忽略檔案的輸入格式分別為下列幾種類型：</p>
<ul>
<li><p><strong>忽略單一檔案</strong>：輸入格式：<code>檔案名稱.檔案類型</code></p>
</li>
<li><p><strong>忽略檔案類型</strong>：輸入格式：<code>*.檔案類型</code></p>
</li>
<li><p><strong>忽略單一資料夾</strong>：輸入格式：<code>資料夾名稱/</code></p>
</li>
</ul>
<hr>
<h2 id="還原（Reset）"><a href="#還原（Reset）" class="headerlink" title="還原（Reset）"></a>還原（Reset）</h2><p>開始介紹 <code>$ git reset</code> 相關指令之前，需要先理解 Reset 會使用到的三種參數模式，如下所示：</p>
<ul>
<li><code>--mixed</code>（預設模式）：暫存區的檔案會被丟回工作目錄，但是原本工作目錄的檔案不會被影響。</li>
<li><code>--soft</code>：移除 commit 節點，但是暫存區與工作目錄的檔案皆不會被影響。</li>
<li><code>--hard</code>：移除 commit 節點、工作目錄與暫存區所有檔案。</li>
</ul>
<p>補充說明：</p>
<p><code>^</code> 符號代表要往回還原的版本次數，<code>HEAD^</code> 代表往回一個版本，也可以使用 <code>~</code> 加上數字來代替 <code>^</code> 符號的數目，<code>@</code> 符號可以用來代表 <code>HEAD</code>；以 <code>HEAD^^</code> 為例，可以改成 <code>HEAD~2</code>，或 <code>@~2</code>。</p>
<h3 id="還原暫存區單一檔案回工作目錄"><a href="#還原暫存區單一檔案回工作目錄" class="headerlink" title="還原暫存區單一檔案回工作目錄"></a><strong>還原暫存區單一檔案回工作目錄</strong></h3><p>指令：<code>$ git reset HEAD 檔案名稱</code></p>
<h3 id="還原暫存區所有檔案回工作目錄"><a href="#還原暫存區所有檔案回工作目錄" class="headerlink" title="還原暫存區所有檔案回工作目錄"></a><strong>還原暫存區所有檔案回工作目錄</strong></h3><p>指令：<code>$ git reset HEAD</code></p>
<h3 id="還原單一檔案內容"><a href="#還原單一檔案內容" class="headerlink" title="還原單一檔案內容"></a>還原單一檔案內容</h3><p>指令：<code>$ git checkout 檔案名稱.檔案類型</code></p>
<p>指定檔案內容還原回最後一次提交的狀態。</p>
<h3 id="還原工作目錄與暫存區"><a href="#還原工作目錄與暫存區" class="headerlink" title="還原工作目錄與暫存區"></a><strong>還原工作目錄與暫存區</strong></h3><p>指令：<code>$ git reset --hard</code></p>
<p>當前工作目錄與暫存區，皆還原回最後一次提交時的狀態。</p>
<p>需要注意空的資料夾本身會被 git 忽略，因此不會被指令還原；但是資料夾內有存在檔案時，就會被 git 追蹤並還原。</p>
<h3 id="移除最新的提交節點"><a href="#移除最新的提交節點" class="headerlink" title="移除最新的提交節點"></a><strong>移除最新的提交節點</strong></h3><p>指令：<code>$ git reset HEAD^ --hard</code></p>
<p>除了移除最新的節點之外，當前暫存區的檔案也會被移除，但是當前工作目錄的檔案不受影響。</p>
<h3 id="還原被移除的最新提交節點"><a href="#還原被移除的最新提交節點" class="headerlink" title="還原被移除的最新提交節點"></a><strong>還原被移除的最新提交節點</strong></h3><p>指令：<code>$ git reset ORIG_HEAD --hard</code></p>
<p>還原指令 <code>$ git reset --hard HEAD^</code> 移除的節點，並移除當前暫存區的檔案，但是當前工作目錄不受影響。</p>
<p>補充說明：</p>
<p>指令中的 <code>ORIG_HEAD</code> 是當使用者在執行一些較危險的指令（<code>merge</code>、<code>rebase</code>、<code>reset</code> …）時，當前 HEAD 的檔案狀態會事先存放的地方，隨時可以還原。</p>
<p>除了上述方法，也可以使用以下指令來還原狀態：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset 89cb75  # 指令中的亂數為被刪除節點的 SHA-1 值</span><br></pre></td></tr></table></figure>

<p>需要注意被刪除的節點無法透過 <code>$ git log</code> 來查詢，查詢的方式可以使用指令 <code>$ git reflog</code> 來檢視歷史的狀態紀錄。</p>
<h3 id="移除最新的提交節點並保留檔案狀態"><a href="#移除最新的提交節點並保留檔案狀態" class="headerlink" title="移除最新的提交節點並保留檔案狀態"></a><strong>移除最新的提交節點並保留檔案狀態</strong></h3><p>指令：<code>$ git reset HEAD^ --soft </code></p>
<p>可以理解成沒有執行最後一次的提交動作。</p>
<h3 id="修改最新提交節點的描述"><a href="#修改最新提交節點的描述" class="headerlink" title="修改最新提交節點的描述"></a><strong>修改最新提交節點的描述</strong></h3><p>指令：<code>$ git commit --amend -m &quot;修改描述&quot;</code></p>
<p>修改當前分支最新一次的提交描述。</p>
<h3 id="追加檔案到最新的提交節點"><a href="#追加檔案到最新的提交節點" class="headerlink" title="追加檔案到最新的提交節點"></a><strong>追加檔案到最新的提交節點</strong></h3><p>指令：<code>$ git commit --amend --no-edit</code></p>
<p>執行指令時如果未加上 <code>--no-edit</code> 參數，會跳出 Vim 編輯視窗。</p>
<hr>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支（branch）是開發者在團隊協作一個專案時，會需要使用到的 Git 架構內容；可以理解成將當前儲存庫的所有檔案複製一份，而這兩個版本可以獨立進行檔案新增、編輯與修改。這樣的好處是檔案的內容如果需要做更動，就可以先移動到另一個分支動作，同時也不用擔心影響到原本的檔案狀態。</p>
<p>以下列出常見分支名稱與主要用途：</p>
<ul>
<li>master（預設分支）：用來合併 develop，合併時才會產生提交節點。</li>
<li>develop（開發分支）：用來合併 feature 分支，合併時才會產生提交節點。</li>
<li>feature：用來開發功能、修改錯誤。</li>
</ul>
<p>進入分支之前，需要先對 HEAD 指標有些概念，可以把它理解成當前分支上的所在位置；資料夾路徑可以看到目前 HEAD 的指向，如下圖所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@DESKTOP-LV1TU83 MINGW64 ~/Desktop/Project (master)  # 目前 HEAD 正指向 master 分支</span><br></pre></td></tr></table></figure>

<h3 id="檢視當前所有分支"><a href="#檢視當前所有分支" class="headerlink" title="檢視當前所有分支"></a>檢視當前所有分支</h3><p>指令：<code>$ git branch</code></p>
<p>查詢目前本地端儲存庫的所有分支。</p>
<p>以 Project（本地端儲存庫）為例，輸入指令後顯示以下訊息，表示目前本地端有兩個分支，分別為 develop 與 master，而符號 <code>*</code> 表示當前 HEAD 正指向的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  develop</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<h3 id="移動-HEAD-到指定提交節點"><a href="#移動-HEAD-到指定提交節點" class="headerlink" title="移動 HEAD 到指定提交節點"></a>移動 HEAD 到指定提交節點</h3><p>指令：<code>$ git checkout SHA-1前4碼</code></p>
<p>用來查看某一次的 commit 內容；而 SHA-1 值可透過 <code>$ git log</code> 查詢，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit ce9d92723df3302156a9523453c0fff21f7fdcc0</span><br><span class="line">Author: Cliff Chu &lt;wave99487chu@gmail.com&gt;</span><br><span class="line">Date:   Sun Jan 23 17:53:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    新增 index</span><br></pre></td></tr></table></figure>

<p>接著輸入指令 <code>$ git checkout ce9d</code> 就能夠移動 HEAD 到這次 commit 節點，如果要回到原本位置，只需要輸入 <code>$ git checkout 當前分支名稱</code> 即可。</p>
<h3 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h3><p>指令：<code>$ git branch 分支名稱</code></p>
<p>建立一個新的分支，但是 HEAD 的指向不變。</p>
<h3 id="切換當前分支"><a href="#切換當前分支" class="headerlink" title="切換當前分支"></a>切換當前分支</h3><p>指令：<code>$ git checkout 分支名稱</code></p>
<p>移動 HEAD 到指定分支的最後一次提交節點。</p>
<h3 id="合併分支-快轉模式（Fast-Forward）"><a href="#合併分支-快轉模式（Fast-Forward）" class="headerlink" title="合併分支 - 快轉模式（Fast-Forward）"></a><strong>合併分支 - 快轉模式（Fast-Forward）</strong></h3><p>指令：<code>$ git merge 合併的分支名稱</code></p>
<p>快轉模式下，兩分支合併後路線重疊，並且不會產生額外的提交節點。</p>
<p>兩分支合併之前，如果最後提交節點都在同一個位置，合併時就會產生快轉模式（Fast - Forward），如下圖所示：</p>
<p><img src="https://i.imgur.com/q0db0Wg.png"></p>
<p>已知合併前的圖中，feature 分支比 master 分支多了兩次提交節點，但是 master 並沒有新增自己的節點，所以 master 分支的檔案在 feature 分支也都有，可以理解成 feature 分支只是 master 分支未來的版本而已，因此進行合併後，master 分支與 feature 分支會重疊，並且不會產生額外的合併節點，這種合併模式稱為 “快轉模式（Fast - Forward）”。</p>
<h3 id="合併分支-關閉快轉模式"><a href="#合併分支-關閉快轉模式" class="headerlink" title="合併分支 - 關閉快轉模式"></a><strong>合併分支 - 關閉快轉模式</strong></h3><p>指令：$ git merge 合併的分支名稱 –no-ff</p>
<p>非快轉模式下，兩分支合併後會產生額外的提交節點。</p>
<p>下圖為加上參數 <code>--no-ff</code> 關閉快轉模式的例子：</p>
<p><img src="https://i.imgur.com/zpwHsHZ.png"></p>
<p>圖中合併前的狀態前面的案例相同，因此在正常情況下合併兩分支就會產生快轉模式；但是也可以在合併時加上參數 <code>--no-ff</code> 來關閉快轉模式，如此一來，兩分支在合併後不但不會重疊，並且會額外產生新的提交節點。</p>
<p>補充說明：</p>
<p>兩分支在非快轉模式下進行合併時，可能會跳出以下訊息，表示需要輸入合併的原因；此時可以按下 i 進入輸入模式，接著將黃色文字的部分改成合併的簡單敘述（同 commit 訊息），輸入完畢後再按下 Esc 退出輸入模式，最後在底部輸入 <code>：wq</code> 即可完成合併並回到原來的畫面。</p>
<p><img src="https://i.imgur.com/LVudQXm.png"></p>
<h3 id="將當前分支合併到指定分支前"><a href="#將當前分支合併到指定分支前" class="headerlink" title="將當前分支合併到指定分支前"></a><strong>將當前分支合併到指定分支前</strong></h3><p>指令： <code>$ git rebase 要合併的分支名稱</code></p>
<p>複製當前分支所有的提交節點，合併在指定的分支前面。</p>
<p>需要注意複製的提交節點會重新產生個別的 SHA-1，與原先的節點彼此並不相同，而原先的節點會隨著時間被 Git 機制回收。</p>
<p>補充說明：</p>
<p>使用 <code>rebase</code> 合併後，無法透過 <code>$ git reset HEAD^</code> 還原回合併前的狀態，而是會還原到前一個節點上；如果要還原回合併前的狀態，可以使用指令 <code>$ git reset ORIG_HEAD --hard</code>。</p>
<p>下列圖片為兩分支在使用 <code>rebase</code> 合併時，可能產生的衝突：</p>
<p><img src="https://i.imgur.com/sz7xcOB.png"></p>
<p>合併時顯示上述訊息，表示檔案內容有衝突，此時可以開啟編輯器查看衝突的部分，以下圖為例：</p>
<p><img src="https://i.imgur.com/wxaxXFa.png"></p>
<p>確認完衝突的檔案內容後，只需要在終端機再次將檔案加入暫存區，接著輸入以下指令再次嘗試合併即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>



<h3 id="指定提交節點合併到當前分支前"><a href="#指定提交節點合併到當前分支前" class="headerlink" title="指定提交節點合併到當前分支前"></a><strong>指定提交節點合併到當前分支前</strong></h3><p>指令： <code>$ git cherry-pick SHA-1 SHA-1</code></p>
<p>複製指定的單一或數個提交節點，合併在當前分支前面。</p>
<p>以下圖為例，嘗試將 feature 分支的 add style 與 add js 兩個合併節點，合併在 master 分支前面：</p>
<p><img src="https://i.imgur.com/UyuDjy1.png"></p>
<p>可以從 sourcetree 介面中的右側看到每個節點的 SHA-1，在取得 add style 與 add js 兩個節點的值後，在 master 分支執行以下指令，即可複製被指定的兩個節點，並合併在當前分支前面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＄ git cherry-pick 7316ad7 3372681</span><br></pre></td></tr></table></figure>

<p>如果希望被複製過來的節點不要直接進行合併，可以在指令後方加上參數 <code>--no-commit</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＄ git cherry-pick 7316ad7 3372681 --no-commit</span><br></pre></td></tr></table></figure>

<p>此時被複製過來的節點會被拆除，並將節點的檔案加入暫存區，也可以透過 <code>$ git status</code> 查詢狀態，會發現暫存區目前有兩個檔案等待提交，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   all.js</span><br><span class="line">        new file:   style.css</span><br></pre></td></tr></table></figure>

<p>確認檔案沒問題後，就可以進行提交，結果如下圖所示：</p>
<p><img src="https://i.imgur.com/wJeP32p.png"></p>
<hr>
<h2 id="標籤（Tag）"><a href="#標籤（Tag）" class="headerlink" title="標籤（Tag）"></a>標籤（Tag）</h2><p>開發專案過程中，會因為檔案不斷新增、刪除或修改而增加許多提交節點，雖然彼此都有獨自的版本描述，但是這樣很難去區分彼此之間的重要程度，如不同時間點的上線版本；因此為了有效區別，可以使用標籤相關指令。</p>
<p>補充說明：</p>
<p>標籤和分支都是指向某一個提交節點的指標，但是兩者的差別在於標籤只會指向固定的提交節點，而分支會隨著提交的增加而移動到最新的節點。</p>
<h3 id="新增標籤"><a href="#新增標籤" class="headerlink" title="新增標籤"></a>新增標籤</h3><p>指令：<code>$ git tag 標籤名稱</code></p>
<p>在當前位置新增一個標籤，可使用指令 <code>$ git tag</code> 來查詢標籤。</p>
<h3 id="新增標示標籤"><a href="#新增標示標籤" class="headerlink" title="新增標示標籤"></a>新增標示標籤</h3><p>指令：<code>$ git tag -am &quot;標示內容&quot; 標籤名稱</code></p>
<p>在當前位置新增一個標籤，並加入詳細的敘述，可以使用指令 <code>$ git tag -n</code> 來檢視標籤的詳細內容。</p>
<h3 id="刪除標籤"><a href="#刪除標籤" class="headerlink" title="刪除標籤"></a>刪除標籤</h3><p>指令：<code>$ git tag -d 標籤名稱</code></p>
<p>可以將標籤想像成一張貼紙，撕掉並不會影響提交的檔案狀態。</p>
<h3 id="移動到指定標籤位置"><a href="#移動到指定標籤位置" class="headerlink" title="移動到指定標籤位置"></a>移動到指定標籤位置</h3><p>指令：<code>$ git checkout 標籤名稱</code></p>
<p>移動 HEAD 的位置到指定標籤上查看檔案狀態，輸入 <code>$ git checkout 分支名稱</code> 即可回到原本內容。</p>
<!-- 標籤類似快照，移動過去時無法編輯檔案，待補充說明 -->

<hr>
<h2 id="暫存（Stash）"><a href="#暫存（Stash）" class="headerlink" title="暫存（Stash）"></a>暫存（Stash）</h2><p>團隊開發專案的過程中，常常會開發到一半出現突發狀況要處理，其中一種作法是，先將目前的工作內容加入暫存區並提交，解決突發狀況後，再透過指令 <code>$ git reset --soft HEAD^</code> 刪除最後一次的提交節點，並還原提交前的所有狀態；另外一種做法則是透過 <code>$ git stash</code> 相關指令來暫存檔案狀態。</p>
<p>補充說明：</p>
<p>暫存（stash）和暫存區（Staging Area）兩者屬於不同的概念。</p>
<!-- 什麼不同概念，待補充 -->

<h3 id="暫存當前的檔案狀態"><a href="#暫存當前的檔案狀態" class="headerlink" title="暫存當前的檔案狀態"></a>暫存當前的檔案狀態</h3><p>指令：<code>$ git stash</code></p>
<p>暫存當前工作目錄已被追蹤與暫存區（Staging Area）的檔案狀態，暫存後無法透過 <code>$ git status</code> 查詢檔案。</p>
<h3 id="檢視暫存列表"><a href="#檢視暫存列表" class="headerlink" title="檢視暫存列表"></a>檢視暫存列表</h3><p>指令：<code>$ git stash list</code></p>
<p>透過指令 <code>$ git stash</code> 暫存的檔案可以使用上述指令來查詢，以下為查詢結果範例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 15988d5 add index</span><br></pre></td></tr></table></figure>

<h3 id="還原暫存的檔案狀態"><a href="#還原暫存的檔案狀態" class="headerlink" title="還原暫存的檔案狀態"></a>還原暫存的檔案狀態</h3><p>指令：<code>$ git stash pop</code></p>
<p>將暫存的檔案狀態還原到當前分支上，有搬運檔案的功能。</p>
<h3 id="清除最新暫存"><a href="#清除最新暫存" class="headerlink" title="清除最新暫存"></a>清除最新暫存</h3><p>指令：<code>$ git stash drop</code></p>
<p>刪除暫存列表最新的暫存紀錄，並無法還原。</p>
<h3 id="清除全部暫存"><a href="#清除全部暫存" class="headerlink" title="清除全部暫存"></a>清除全部暫存</h3><p>指令：<code>$ git stash clear</code></p>
<p>刪除暫存列表所有的暫存紀錄，並無法還原。</p>
<hr>
<h2 id="遠端儲存庫操作指令"><a href="#遠端儲存庫操作指令" class="headerlink" title="遠端儲存庫操作指令"></a>遠端儲存庫操作指令</h2><p>本篇內容主要是在著重講述 Git 的基本操作，因此先不討論遠端儲存庫的建立方式與相關內容。</p>
<h3 id="連結遠端儲存庫"><a href="#連結遠端儲存庫" class="headerlink" title="連結遠端儲存庫"></a>連結遠端儲存庫</h3><p>指令：<code>$ git remote add origin 遠端儲存庫網址</code></p>
<p>指令中的 <code>origin</code> 為遠端儲存庫的預設名稱；實務上通常會有多個儲存庫，如正式主機與測試主機；使用者可根據儲存庫用途來自訂名稱。</p>
<h3 id="查詢遠端儲存庫"><a href="#查詢遠端儲存庫" class="headerlink" title="查詢遠端儲存庫"></a>查詢遠端儲存庫</h3><p>指令：<code>$ git remote</code></p>
<p>查詢與本地端連結的遠端儲存庫的名稱；加入參數 <code>-v</code> 可以查詢詳細名稱與路徑。</p>
<h3 id="複製遠端儲存庫"><a href="#複製遠端儲存庫" class="headerlink" title="複製遠端儲存庫"></a>複製遠端儲存庫</h3><p>指令：<code>$ git clone 遠端儲存庫網址</code></p>
<p>複製遠端資料到本地端資料夾，並建立工作目錄與本地端儲存庫（.git 資料夾），在指令後方加上 <code>-b 遠端分支名稱</code> 可以指定要複製的遠端分支。</p>
<p>補充說明：</p>
<p>上述指令通常會在本地端尚未存在遠端的資料的形況下執行；而後續本地端的資料更新都是透過 <code>$ git pull</code> 相關指令來操作。</p>
<h3 id="推送本地端分支到遠端分支"><a href="#推送本地端分支到遠端分支" class="headerlink" title="推送本地端分支到遠端分支"></a>推送本地端分支到遠端分支</h3><p>指令：<code>$ git push 遠端儲存庫名稱 遠端分支名稱</code></p>
<p>與本地端連結的遠端儲存庫如果有一個以上，在推送的時候要注意遠端儲存庫名稱，是否與要推送的遠端儲存庫相同，避免推送到錯誤的遠端。</p>
<p>補充說明：</p>
<p>第一次在推送時，如果在指令中加入參數 <code>-u</code>，Git 就會記錄這次的推送行為，後續在推送本地端資料回遠端時，只需要輸入指令 <code>$ git push</code> 即可，但是也會遇到無法推送的情形，這部分會在 <code>$ git pull</code> 的部分說明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u 遠端儲存庫名稱 遠端分支名稱</span><br></pre></td></tr></table></figure>

<h3 id="變更遠端儲存庫名稱"><a href="#變更遠端儲存庫名稱" class="headerlink" title="變更遠端儲存庫名稱"></a>變更遠端儲存庫名稱</h3><p>指令：<code>$ git remote rename 原儲存庫名稱 修改後名稱</code></p>
<p>預設的遠端儲存庫名稱為 <code>origin</code>。</p>
<h3 id="複製遠端儲存庫分支與本地端分支合併"><a href="#複製遠端儲存庫分支與本地端分支合併" class="headerlink" title="複製遠端儲存庫分支與本地端分支合併"></a>複製遠端儲存庫分支與本地端分支合併</h3><p>指令：<code>$ git pull 遠端儲存庫名稱 遠端分支名稱</code></p>
<p>團隊協作開發專案時，因為每個人的進度不同，會需要不定時更新遠端的資料回本地端；與 <code>$ git clone</code> 不同的是，<code>$ git pull</code> 是使用在本地端已經存在遠端的資料，但是需要更新檔案進度時。</p>
<p>推送本地端資料回遠端前，如果遠端資料已更新，本地端在推送時就會出現以下衝突訊息：</p>
<p><img src="https://i.imgur.com/5Pu4KZi.png"></p>
<p>此時需要使用 <code>$ git pull</code> 先將遠端最新的資料更新（複製）到本地端，在複製遠端資料時會跳出以下訊息，表示需要將遠端資料與本地端進行合併。</p>
<p><img src="https://i.imgur.com/PnkSzXM.png"></p>
<p>從上述行為可得知，指令 <code>$ git pull</code> 做的事情是將遠端分支複製一份到本地端，再直接進行合併的動作。</p>
<h3 id="複製遠端儲存庫分支與本地端分支等待合併"><a href="#複製遠端儲存庫分支與本地端分支等待合併" class="headerlink" title="複製遠端儲存庫分支與本地端分支等待合併"></a>複製遠端儲存庫分支與本地端分支等待合併</h3><p>指令：<code>$ git fetch 遠端儲存庫名稱 遠端分支名稱</code></p>
<p>與 <code>$ git pull</code> 不同的是，使用 <code>$ git fetch</code> 取得的遠端最新檔案會產生一個 FETCH_HEAD，表示遠端分支的最新狀態 <code>遠端儲存庫名稱/遠端儲存庫分支</code> 與 <code>遠端儲存庫名稱/HEAD</code>，並額外產生提交節點在本地端當前分支前面，使用者檢查後再決定是否要與本地端分支合併，合併指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge 遠端儲存庫名稱/遠端儲存庫分支</span><br></pre></td></tr></table></figure>

<p>從上述行為可得知，<code>$ git pull</code> 做的動作相當於 <code>$ git fetch</code> 加上 <code>$ git merge</code>。</p>
<!-- 可以補充說明 -->

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><em><a href="https://gitbook.tw/chapters/using-git/amend-commit2">如何使用 –amend 追加檔案</a></em></li>
<li><em><a href="https://ithelp.ithome.com.tw/articles/10211795">Fast-Forward 快轉模式詳細介紹</a></em></li>
<li><em><a href="https://gitbook.tw/chapters/faq/stash">Git Stash 詳細使用方式</a></em></li>
<li><em><a href="https://gitbook.tw/chapters/using-git/reset-commit">Git Reset 使用模式</a></em></li>
<li><em><a href="https://gitbook.tw/chapters/branch/merge-with-rebase">使用 Git Rebase 合併</a></em></li>
<li><em><a href="https://iter01.com/539474.html">Git Fetch 詳細介紹</a></em></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
