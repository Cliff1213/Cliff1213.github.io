<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NPM 基本指令</title>
    <url>/2022-02-07-npm-note/</url>
    <content><![CDATA[<p>淺淺的紀錄一下 NPM 是甚麼，以及相關的一些指令，藉此避免踩到一些開發中常見的雷。</p>
<span id="more"></span>

<h2 id="甚麼是-NPM？"><a href="#甚麼是-NPM？" class="headerlink" title="甚麼是 NPM？"></a>甚麼是 NPM？</h2><p>全名 Node Package Manager，是一種套件管理工具，簡言之就是匯集各種 Node js 套件的線上庫。</p>
<h2 id="安裝-Node-JS-amp-NPM"><a href="#安裝-Node-JS-amp-NPM" class="headerlink" title="安裝 Node JS &amp; NPM"></a>安裝 Node JS &amp; NPM</h2><p><img src="https://i.imgur.com/O3WVkU4.png"></p>
<p>上圖是 <a href="https://nodejs.org/en/">Node js 官網</a>所提供的下載點，可以看到分成兩個部分，左邊為 LTS（Long Term Support），屬於長期支援維護的版本，可以理解成較穩定的版本；右邊 Current 的部分則是最近、最新的版本。</p>
<p>Node js 官方在版本的釋出上有自己的邏輯，通常會在每年四月份發布偶數版本，十月份發布奇數版本，可以從下圖看到近期的版本維護狀態：</p>
<p><img src="https://i.imgur.com/zOGuPaZ.png"></p>
<p>新的版本在發布後，版本號如果是奇數，六個月後就不會再維護；但版本號如果是偶數，半年後就會進入長期維護（Active LTS）的狀態，並保證在接下來的三十個月內會更新與修復各種問題，因此新專案通常會選擇安裝 LTS 的版本。</p>
<p>接著進入正題，要如何安裝 NPM？這個問題其實在安裝 Node 後就已經解決了，因為 NPM 是 Node js 開發環境預設的套件管理工具（Packge Manager），因此在安裝 Node 的同時，NPM 會跟著一起安裝。</p>
<blockquote>
<p>因為每個專案所使用的 Node 版本不盡相同，因此為了避免產生版本與套件之間的相容問題，建議使用 NVM（Node Version Manager）來切換 Node 版本。</p>
</blockquote>
<p>安裝完成後，開啟任一終端機即可開始操作。</p>
<h2 id="檢視版本"><a href="#檢視版本" class="headerlink" title="檢視版本"></a>檢視版本</h2><p>在終端機輸入以下指令：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> -v<br></code></pre></td></tr></table></figure>

<p>如果顯示 npm 版本號，表示安裝成功，如下所示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<h2 id="初始化目錄"><a href="#初始化目錄" class="headerlink" title="初始化目錄"></a>初始化目錄</h2><p>指定任一資料夾為目錄，輸入以下指令：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure>

<p>此時會顯示訊息要求輸入專案的一些資訊，如下所示：</p>
<p><img src="https://i.imgur.com/bGQsEeb.png"></p>
<p>上述部分只需要持續按下 Enter 即可。</p>
<p>接著透過編輯器開啟專案資料夾，可以看到一個 package.json 的檔案，這是資料夾在進行 npm 初始化後所產生的 json 格式檔案，內容主要是紀錄專案的資訊，如下所示：</p>
<p><img src="https://i.imgur.com/yjjj8ZV.png"></p>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><h3 id="全域安裝"><a href="#全域安裝" class="headerlink" title="全域安裝"></a><strong>全域安裝</strong></h3><figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g 套件名稱<br></code></pre></td></tr></table></figure>

<p>安裝套件時，在指令加入 <code>-g</code>，套件就會被安裝在全域，也就是當前使用的電腦上；這樣做的好處是，當有其他專案需要使用這個套件時，就不用再另外安裝該套件在專案資料夾中。</p>
<h3 id="安裝於指定目錄"><a href="#安裝於指定目錄" class="headerlink" title="安裝於指定目錄"></a><strong>安裝於指定目錄</strong></h3><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save 套件名稱</span><br></code></pre></td></tr></table></figure>

<p>以指定專案資料夾為目錄並執行上述指令，套件就會被安裝在該資料夾中，在加入 <code>--save</code> 參數後，這個套件就會被記錄在 package.json 檔案裡，下列以安裝 jquery 為範例：</p>
<p><img src="https://i.imgur.com/n1jRC8k.png"></p>
<p>可以看到檔案中新增了一個 dependencies 項目，並且在下方可以看到已安裝的 jquery 套件與對應版本。</p>
<p>因為不同專案所使用的套件與套件版本不同，因此在接手別人開發的專案時，可以先依據 dependencies 中的資訊來安裝對應的套件。</p>
<h2 id="安裝指定版本套件"><a href="#安裝指定版本套件" class="headerlink" title="安裝指定版本套件"></a>安裝指定版本套件</h2><p>正常的情況下，安裝下來的套件預設會是最新的版本，但一些較舊的專案可能不支援新版本的套件，此時就可以使用以下指令來安裝指定版本的套件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> 套件名稱@版本號<br></code></pre></td></tr></table></figure>


<h2 id="版本數字意義"><a href="#版本數字意義" class="headerlink" title="版本數字意義"></a>版本數字意義</h2><p>通常套件的版本會以 3 個數字的格式來表示，但每個數字所代表的意義其實不同，下列以 jquery 為例：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;jquery&quot;</span>： <span class="hljs-string">&quot;^3.6.0&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>3</code> - 主要版本，通常會因為重大改版而增加版本號。</li>
<li><code>6</code> - 次要版本，依當前的主要版本為基準，新增功能時增加版本號。</li>
<li><code>0</code> - 修正版本，依當前的主要版本為基準，修正錯誤時增加版本號。</li>
</ul>
<p>開發的過程中通常不會直接更新主要版本，因為這樣有極高的機率毀掉專案，正常的情況下只會更新次要版本或修正版本，依專案的開發情形而定。</p>
<h2 id="版本標示符號"><a href="#版本標示符號" class="headerlink" title="版本標示符號"></a>版本標示符號</h2><ul>
<li><code>^x.x.x</code> - 安裝套件時，自動更新次要與修正版本，主要版本不做更動。</li>
<li><code>~x.x.x</code> - 安裝套件時，自動更新修正版本，主要與次要版本不做更動。</li>
<li><code>latest</code> - 安裝套件時，自動安裝最新版本。</li>
<li>未加入任何符號，表示只安裝當前輸入的版本。</li>
</ul>
<p>更新套件版本的方式，只需要將專案資料夾中的 node_modules 刪除，再重新執行以下指令，系統就會根據該專案中的 package.json 檔案設置來安裝所有會使用到的套件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure>


<h2 id="移除套件"><a href="#移除套件" class="headerlink" title="移除套件"></a>移除套件</h2><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall 套件名稱<br></code></pre></td></tr></table></figure>

<p>需要注意的是，上述指令只會將專案資料夾中的套件移除，但是並不會同時更新 package.json 檔案中的設置，如果有這個需求，只需要在指令中加入 <code>--save</code> 參數即可。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/html-test/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E4%BD%BF%E7%94%A8npm%E5%A5%97%E4%BB%B6-317beefdf182">從零開始：使用NPM套件</a><br><a href="https://linyencheng.github.io/2020/03/22/tool-npm/">npm 入門到進階</a></p>
]]></content>
      <categories>
        <category>Package</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 CSS Font-Family</title>
    <url>/2022-03-02-css-font-family/</url>
    <content><![CDATA[<p>在設定字體時，常常會遇到結果不如預期的情況，於是決定研究一下網頁是怎麼套用字體，以及一些相關的注意事項。</p>
<span id="more"></span>

<h2 id="Font-Family-設定規則"><a href="#Font-Family-設定規則" class="headerlink" title="Font-Family 設定規則"></a>Font-Family 設定規則</h2><p>基本上只要是網頁設計，都會使用到的屬性，可以自訂頁面上的文字字體，但是初學者在使用這個屬性之前，為了避免結果不如預期，建議需要先理解一些設定上的規則。</p>
<h3 id="字體套用邏輯"><a href="#字體套用邏輯" class="headerlink" title="字體套用邏輯"></a>字體套用邏輯</h3><p>Font-Family 雖然可以設定多個屬性值，但是並不會將所有寫入的字體都一起套用，而是會根據瀏覽器對該字體的支援與否，由左至右依序判斷，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: 字體A, 字體B, 字體C;<br></code></pre></td></tr></table></figure>

<p>假設使用者的電腦系統中僅存在 “字體B”，此時瀏覽器載入網頁時，會根據上述設定先判斷系統內是否有對應的字體A，但因為系統中找不到這個字體，因此會跳過該字體並判斷下一個字體B，此時找到字體B之後，就會套用該字體，並且不再往下進行判斷。</p>
<h3 id="語法注意事項"><a href="#語法注意事項" class="headerlink" title="語法注意事項"></a>語法注意事項</h3><p>在部分字體的選用上，同一個字體可以選擇使用中文名稱或英文名稱的屬性值設定，其結果會相同，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Microsoft JhengHei&quot;</span>;<br><span class="hljs-attribute">font-family</span>: 微軟正黑體;<br></code></pre></td></tr></table></figure>

<p>從上述語法中可以發現，第一行的字體加上了雙引號，這是因為該字體的名稱之間如果存在空白，在不加上雙引號的情形下，瀏覽器會無法辨識而導致讀取失敗。</p>
<p>另一個值得注意的是，雖然使用中文名稱來設定字體結果與英文名稱相同，但是只單獨設定中文名稱的話，可能會遇到編碼的問題而導致結果不如預期，因此會建議使用英文名稱的屬性值，或是中、英文一起使用，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Microsoft JhengHei&quot;</span>, 微軟正黑體;<br></code></pre></td></tr></table></figure>


<h2 id="Font-Family-字體類型"><a href="#Font-Family-字體類型" class="headerlink" title="Font-Family 字體類型"></a>Font-Family 字體類型</h2><p>在當今這麼大量的字體中，主要可以分為 “指定字體” 與 “通用字體” 兩種類型。</p>
<h3 id="指定字體（family-name）"><a href="#指定字體（family-name）" class="headerlink" title="指定字體（family-name）"></a>指定字體（family-name）</h3><p>不同的字體也會影響網頁的視覺感受，因此在選用字體時，通常會優先使用指定的字體。</p>
<h3 id="通用字體（generic-family）"><a href="#通用字體（generic-family）" class="headerlink" title="通用字體（generic-family）"></a>通用字體（generic-family）</h3><p>通用字體可以理解成多數的電腦系統中，內建就已存在的字體，常見的通用字體有以下五種，其中無襯線體、襯線體使用最為廣泛：</p>
<ul>
<li>sans-serif（無襯線體 / 黑體）</li>
<li>serif（襯線體 / 明體）</li>
<li>cursive（手寫體）</li>
<li>monospace（等寬體）</li>
<li>fantasy（幻想體）</li>
</ul>
<h3 id="設定方式"><a href="#設定方式" class="headerlink" title="設定方式"></a>設定方式</h3><p>雖然可以透過指定字體名稱的方式，來達到自訂網頁上想要呈現的字體，但是並非所有電腦系統都有對應的指定字體，因此在使用指定字體時，通常都會在 font-family 屬性值的<strong>最後方位置</strong>設定預設的通用字體；而前面有提到 font-family 是由左至右判斷屬性值，所以當瀏覽器不支援或無法從系統中找到前方所對應的指定字體時，就會套用最後設定的通用字體，設定格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: 指定字體, <span class="hljs-string">&quot;指定 字體&quot;</span>, 通用字體;<br></code></pre></td></tr></table></figure>


<h2 id="字體順序觀念"><a href="#字體順序觀念" class="headerlink" title="字體順序觀念"></a>字體順序觀念</h2><p>本篇一開始在設定規則的地方有簡單提到字體是由左邊開始判斷，但是在順序方面還有一些重要觀念需要熟記，這邊先記住以下設定順序，後續會說明原因：</p>
<p>設定順序：<strong>英文字體 &gt; Linux &gt; Mac &gt; Windows &gt; 通用字體</strong></p>
<!-- 這部分一直沒有比較好的解釋 -->



<h3 id="中、英文順序"><a href="#中、英文順序" class="headerlink" title="中、英文順序"></a>中、英文順序</h3><p>一個網頁通常會存在多個語言（以中、英文為例），但是並非所有的字體都同時支援中、英文，因此許多網頁會利用這個由左至右判斷的技巧，分別針對中文與英文各別設定不同的字體，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: Arial, 微軟正黑體;<br></code></pre></td></tr></table></figure>

<p>上述設定中，Arial 只有英文字體，而微軟正黑體則是中、英文字體都有，因此瀏覽器在判斷 Arial 之後，就會因為符合條件而套用英文字體，而中文會因為找不到對應字體則往下判斷微軟正黑體並套用，此時網頁上的中文與英文就會呈現不同字體的效果。</p>
<p>但是如果順序換成微軟正黑體在前面，瀏覽器就會先判斷微軟正黑體，因為該字體中、英文都可以使用，所以網頁上的兩種語言都會套用成微軟正黑體，而後面的 Arial 會因為英文字體已套用成微軟正黑體而不會被讀取。</p>
<p>因此，正確的屬性值順序為<strong>英文字體在前面，中文字體在後面。</strong></p>
<h3 id="字體使用率與順序"><a href="#字體使用率與順序" class="headerlink" title="字體使用率與順序"></a>字體使用率與順序</h3><p>每個作業系統都有自己的系統字體，例如 -apple-system 與 BlinkMacSystemFont 分別是 iOS 以及 macOS 的系統字體，並且前者只能使用在 Safari 瀏覽器上，後者則是用於 Chrome，像這種只能使用在特定系統或瀏覽器的字體，順序就需要放在前面，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="hljs-string">&quot;Segoe UI&quot;</span>, <span class="hljs-string">&quot;Microsoft JhengHei&quot;</span>, Roboto, <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;<br>	     <span class="hljs-comment">/* mac系統字體, iOS系統字體,	windows英文系統字體, 微軟正黑體, Android系統字體, iOS系統字體, 通用字體, 通用字體 */</span><br></code></pre></td></tr></table></figure>

<p>假設使用者電腦系統為 windows，瀏覽器因為在系統中找不到 -apple-system 與 BlinkMacSystemFont 而直接跳過這兩個字體，而下一個 Segoe UI 屬於 windows 的英文系統字體，因此英文字體就會套用 Segoe UI，中文字體則是因為 Segoe UI 並沒有對應的中文而判斷下一個值，最終套用 Microsoft JhengHei。</p>
<p>如果電腦系統是 macOS 並且使用 Chrome 瀏覽網頁，當瀏覽器在讀取到 -apple-system 時，就會套用對應的中文及英文字體，並且不再往下判斷。</p>
<p>因此，為了適應各種不同的瀏覽器與作業系統，在設定字體時需要把<strong>較少使用到的字體放前面，較常使用到的字體放後面。</strong></p>
<h2 id="實務範例"><a href="#實務範例" class="headerlink" title="實務範例"></a>實務範例</h2><p>附上幾個知名企業的字體設定當作參考，有興趣的也可以自行研究順序邏輯。</p>
<p>Apple（台灣）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;SF Pro TC&quot;</span>, <span class="hljs-string">&quot;SF Pro Text&quot;</span>, <span class="hljs-string">&quot;SF Pro Icons&quot;</span>, <span class="hljs-string">&quot;PingFang TC&quot;</span>, <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, <span class="hljs-string">&quot;Helvetica&quot;</span>, <span class="hljs-string">&quot;Arial&quot;</span>, sans-serif;<br></code></pre></td></tr></table></figure>

<p>微軟台灣：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Segoe UI&#x27;</span>, SegoeUI, <span class="hljs-string">&#x27;Microsoft JhengHei&#x27;</span>, 微軟正黑體, <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Helvetica, Arial, sans-serif;<br></code></pre></td></tr></table></figure>

<p>Google：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: arial, sans-serif;  <span class="hljs-comment">/* 這絕對不是懶(? */</span><br></code></pre></td></tr></table></figure>



<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.oxxostudio.tw/articles/201811/css-font-family.html">CSS font-family 詳細介紹</a><br><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/180456/#outline__1_2_1">最標準的系統字型規範 font-family</a><br><a href="https://www.casper.tw/css/2014/01/01/font-family/">font-family要怎麼玩</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>font-family</tag>
      </tags>
  </entry>
  <entry>
    <title>UI 觀念直播班心得</title>
    <url>/2022-01-17-hexschool-ui-feedback/</url>
    <content><![CDATA[<p>2021 冬，UI 直播班心得，推！</p>
<span id="more"></span>



<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本身不是設計相關科系，但還是希望能透過這次的＂六角學院－UI設計觀念必修直播班＂來增進一點 UI/UX 的相關知識，雖然很遺憾沒有完美的走到終點，但還是幫自己記錄一下這次參與直播班的心路歷程。</p>
<h2 id="報名這堂課的契機是？"><a href="#報名這堂課的契機是？" class="headerlink" title="報名這堂課的契機是？"></a>報名這堂課的契機是？</h2><p>相信在仿間與 UI/UX 設計相關的課程一定數不勝數，但是為什麼我會選擇”六角學院”的課程？原因很簡單，<del>就是信仰（沒</del>，其實早在先前就有報名六角的切版班了，而六角學院整體給我的氛圍是很團結的；你會有自己的小組以及永遠在前線待命等你發問的助教，當然少不了最敬業的老師。而因為你是跟著大家一起學習，所以當腦海衍生出想偷懶的想法同時，也會有一種被人從後面拍肩膀並對你說「欸我先走一步哩，你就繼續耍廢。」的感覺，讓你在學習上能自律。</p>
<h2 id="每週的學習過程："><a href="#每週的學習過程：" class="headerlink" title="每週的學習過程："></a>每週的學習過程：</h2><p>這一次表訂為期四週的直播課程大綱如下：</p>
<ul>
<li><p><strong>Week 1：掌握頁面所有元件</strong></p>
<p>本次主要使用的設計工具為 Figma，算是目前的主流之一。而這週就是帶你認識軟體的操作介面；雖然我在開課前有先觀看課前釋出的體驗營直播錄影，但是自己在操作上還是有許多不解的地方；不過在聽完第一週的直播後，我私下就利用時間把直播錄影再看一次並且針對操作上比較複雜的地方寫了筆記，<del>對我來說都很複雜所以筆記滿到哭</del>，而這些後續幫助我在練習軟體上幫助很多。</p>
</li>
<li><p><strong>Week 2：帶你從草稿到完稿</strong></p>
<p>這週認識了一些網頁在設計的過程中比較常見會遇到的設計模式，像是C.R.A.P的設計準則，或是在規劃網頁時常用的 AIDA Modal；再來會介紹甚麼是 Wireframe。這週基本上每個人會開始設計第一個 Landing Page，對我這個設計白癡來說算是頗有挑戰性的，<del>（我做的很像釣魚網站</del>。</p>
</li>
<li><p><strong>Week 3：伸縮自如的響應式設計</strong></p>
<p>RWD對我來說雖然早就不陌生，但是這堂課讓我更加的理解網頁在不同寬度的視窗做切換時的一些細節以及過往不懂的知識，像是中斷點、網格切換時的邏輯或是兩個物件之間的間距都是一個學問。</p>
</li>
<li><p><strong>Week 4：讓介面動起來</strong></p>
<p>這週的直播內容算是比較有趣的一次，主要都是在介紹 Prototype 的運作，很多動畫都是在網頁中常見的，但是直播以外的時間幾乎都是拿來做最終作品，從這週開始會覺得時間緊湊起來。</p>
</li>
<li><p><strong>Week 5：加碼內容</strong></p>
<p>標題說是表訂為期四週，但怎麼會還有第五週呢？原因是老師擔心有些同學工作比較忙碌，可能會沒有時間做最終作品，因此開放最終作品有達到一定進度的同學提供額外的一次直播並且延長作品繳交的期限<del>（老師你是神吧</del>，而加碼直播課程的內容是如何把作品上傳到 Behance 以及作品呈現的排版建議；為了拿到這張門票我花了不少時間不反覆改我的作品版型，但一切都值得。</p>
</li>
</ul>
<h2 id="建議："><a href="#建議：" class="headerlink" title="建議："></a>建議：</h2><p>無論你是不是設計背景，或是你有想轉職 UI 設計師的想法但是沒有明確的學習目標，不仿可以考慮看看六角學院的 UI 設計直播課程；好的學習環境跟課程規劃這裡都提供給你了，但能不能有所成長還是決定在自己身上，以我自己為例，很多觀念在直播上課的當下我是充滿疑惑的，但課後我會盡可能的把當天的直播錄影重頭到尾看一次並且隨時暫停錄影做筆記，因為對我來說暫停的當下會先思考一次問題的所在，而作筆記的時候會間接複習剛剛思考的問題，這確實大幅提升了我的學習效率，當然這是我自己的做法，每個人的學習方式不盡相同，但這裡要表達的重點是自己必須要有所規劃，再搭配現有的資源去做結合，才能最有效率的學習。</p>
<h2 id="結語："><a href="#結語：" class="headerlink" title="結語："></a>結語：</h2><p>雖然這次的過程對我來說真的不容易，但還是很榮幸可以跟到這次的直播課程，畢竟這是我有史以來最認真跟 UI/UX 相處的一段時間。很喜歡一個人專注在思考或是做某一件事情時的感覺，而這次直播班讓我深刻體會到了，遺憾的是我沒有在時間內完成最終作品，雖然對特別延長繳交期限的老師很不好意思，但這個作品我還是會利用時間把它完成，至少有始有終也算是對參與這個課程的自己負責吧。</p>
<p>最後我要特別感謝<strong>熾炎鐵甲狼</strong>的組員，特別是組長都會幫忙繳交小組作業以及提醒繳交的時間，也要感謝其他組員都會提出疑問和幫忙解答，雖然各位都很忙，但都盡可能的參與小組任務，這邊讓我私心合影紀念一下。</p>
<p><img src="https://i.imgur.com/kQuBKJ5.png" alt="img"></p>
<p>最後的最後，要感謝聲音自帶磁性的俊儀老師和唯一的 Joanne 助教願意回答我提出的蠢問題<del>（假日問跨年也問，吵到真的不好意思</del>，雖然最後階段的作品屢次被退回，但每次的建議我都有仔細看，讓我這個設計肢障提升了設計觀念之餘，也培養了專注思考的能力，感謝兩位的用力鞭打，也辛苦你們了。</p>
<p><img src="https://i.imgur.com/GIbWClM.png?1"></p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>六角學院</tag>
      </tags>
  </entry>
  <entry>
    <title>RWD 響應式設計</title>
    <url>/2022-03-14-rwd-note/</url>
    <content><![CDATA[<p>隨著行動裝置的普及，RWD 可以說是現今網頁開發中必備的一項技能，剛好最近也學到這方面的知識，藉此機會寫一篇筆記，提供自己後續資料的查找。</p>
<span id="more"></span>


<h2 id="RWD-在做什麼？"><a href="#RWD-在做什麼？" class="headerlink" title="RWD 在做什麼？"></a>RWD 在做什麼？</h2><p>響應式網頁設計（Responsive Web Design），是為了因應現今網頁瀏覽裝置的多樣性，而衍生出來的一網頁設計模式；能夠讓一個網頁在多種裝置寬度下，呈現出不同的內容排版。</p>
<h2 id="初始設置"><a href="#初始設置" class="headerlink" title="初始設置"></a>初始設置</h2><h3 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h3><p>要使網頁符合 RWD 條件，就必須在 head 標籤內層加入以下設定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>上述語法中的 viewport 代表視埠，可以理解成可視區域，在後方可以看到 width=device-width 與 initial-scale=1.0 兩個參數，前者表示強制讓網頁的解析度等於瀏覽裝置的寬度，後者則是設定網頁的縮放比例為 1 倍。</p>
<p>viewport 可設定參數分別有以下幾種：</p>
<ul>
<li>width（設定寬度）</li>
<li>height（設定高度）</li>
<li>initial-scale（設定初始縮放比例）</li>
<li>minimum-scale（設定最小縮放比例）</li>
<li>maximum-scale（設定最大縮放比例）</li>
<li>user-scalable（是否允許畫面縮放）</li>
</ul>
<h3 id="檢視前後差異"><a href="#檢視前後差異" class="headerlink" title="檢視前後差異"></a>檢視前後差異</h3><p>以 Chrome 瀏覽器為例，網頁在加上 viewport 的語法後，可以透過開發人員工具的 toggle device toolbar 功能來檢視是否載入成功，而先前的語法中分別設定了 width 以及 initial-scale，因此將瀏覽裝置變更為手機後，網頁中的文字會保持原本大小，並且內容會被侷限在裝置的寬度範圍裡，<strong>不會產生 x 軸</strong>。</p>
<blockquote>
<p>補充說明：上述提到的 x 軸，是指瀏覽器底部的水平移動軸（scroll bar）。</p>
</blockquote>
<h2 id="Media-Queries"><a href="#Media-Queries" class="headerlink" title="Media Queries"></a>Media Queries</h2><p>media 是在設計響應式網頁時，必然會使用到的語法，而 Media Queries（媒體查詢）的作用是偵測使用者目前裝置的屬性（如裝置寬度），並針對這些屬性定義樣式。 </p>
<h3 id="媒體類型"><a href="#媒體類型" class="headerlink" title="媒體類型"></a>媒體類型</h3><p>根據 <a href="https://www.w3schools.com/css/css3_mediaqueries.asp">W3C</a> 文件中所列出的媒體類型，目前主要有以下幾種：</p>
<ul>
<li>all（所有裝置）</li>
<li>print（印刷裝置）</li>
<li>screen（螢幕裝置）</li>
<li>speech（朗讀裝置）</li>
</ul>
<blockquote>
<p>備註：後續內容會著重在網頁上會使用的相關設定。</p>
</blockquote>
<h3 id="設定方式（CSS）"><a href="#設定方式（CSS）" class="headerlink" title="設定方式（CSS）"></a>設定方式（CSS）</h3><p>以下原始碼只有指定 media 類型，因此只要裝置類型為螢幕（screen）時，就會載入樣式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen &#123;<br>    <span class="hljs-comment">/* CSS Style */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下原始碼除了指定 media 類型之外，還使用了 Queries 的判斷條件 and，此時需要符合裝置為螢幕，以及畫面的最大寬度為 768 像素，才會載入樣式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-comment">/* CSS Style */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>判斷條件也可以設定多個，以下方原始碼為例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> ( <span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span> ) <span class="hljs-keyword">and</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-comment">/* CSS Style */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>除了上述的 and，還可以使用 or、not、only 來設定判斷條件，在此不討論。</p>
</blockquote>
<p>如果不指定 media 類型，判斷的裝置類型就會是 all（所有裝置），此時 and 也可以省略，設定方式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-comment">/* CSS Style */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="寬度設定類型"><a href="#寬度設定類型" class="headerlink" title="寬度設定類型"></a>寬度設定類型</h2><p>因為響應式網頁的運作方式是根據裝置的寬度，而相關的設定可使用以下兩種：</p>
<h3 id="max-width"><a href="#max-width" class="headerlink" title="max-width"></a>max-width</h3><p>表示最大寬度在設定的數值（含）以下時，範例原始碼如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 斷點一 */</span><br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 斷點二 */</span><br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">375px</span> ) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假設目前瀏覽器寬度為 1024 像素，此時 h1 的字體顏色為紅色，接著嘗試使用 iPad Mini（768*1024）進行瀏覽，此時就會滿足斷點一的條件並載入樣式，使 h1 的顏色變更為綠色。</p>
<blockquote>
<p>因為 CSS 權重觀念，Media Queries 的樣式載入後，前者相同屬性的樣式就會被後者載入的樣式覆蓋。</p>
</blockquote>
<p>同理，如果將瀏覽裝置切換成 iPhone SE（375*667），就會滿足斷點二的條件，並將 h1 的字體大小設定為 24 像素。</p>
<h3 id="min-width"><a href="#min-width" class="headerlink" title="min-width"></a>min-width</h3><p>表示最小寬度在設定的數值（含）以上時，範例原始碼如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;<br>&#125;<br><span class="hljs-comment">/* 斷點一 */</span><br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 斷點二 */</span><br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">min-width</span>: <span class="hljs-number">992px</span> ) &#123;<br>    <span class="hljs-selector-tag">h1</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>min-width 是依據最小寬度來載入樣式，以此例子來說，在未滿足任何斷點時，文字大小都會是 24 像素，即使斷點一、二的撰寫位置在下方，也會因為沒有滿足媒體查詢條件而使樣式不被套用。</p>
<h3 id="差異與影響"><a href="#差異與影響" class="headerlink" title="差異與影響"></a>差異與影響</h3><p>因為 CSS 的載入邏輯是先判斷權重，再判斷先後順序，因此若是使用 max-width 來設計響應式網頁，在行動裝置上 Media Queries 就會因為符合所有斷點條件使樣式從電腦版一路覆蓋到行動版；但如果是使用 min-width，在行動裝置上就不會有樣式覆蓋的問題，不過使用上並不會有影響，依照習慣擇一使用即可。</p>
<h2 id="讓網頁自適應寬度"><a href="#讓網頁自適應寬度" class="headerlink" title="讓網頁自適應寬度"></a>讓網頁自適應寬度</h2><p>一般網頁在沒有設計響應式的情況下，最外層容器都會設定一個固定寬度，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">clss</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是在響應式網頁中，如果使用 width 來設定容器寬度，會造成網頁在縮放時，因為寬度固定而無法使內容自適應寬度，導致產生 x 軸，以上方範例來說，手動調整瀏覽器寬度到 1000 像素以下時，網頁的寬度還是 1000 像素，因此部分內容會被隱藏到可視範圍外，需要拖曳瀏覽器底部的 x 軸，才能看到被隱藏的內容。</p>
<p>所以如果要讓上方原始碼具有響應式網頁的功能，就必須將最外層容器原本設定的屬性 width 更改為 max-width（最大寬度），設定方式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如此一來，任意調整瀏覽器寬度時，最外層容器的寬度就會是瀏覽器當下的寬度，並且最大不會超過容器本身的寬度。</p>
<h2 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h2><p>大部分的網頁在開始設定樣式之前，都會先載入習慣的 CSS Reset 設定，而在響應式網頁中，會建議另外加上幾個 Reset 設定。</p>
<h3 id="設定圖片"><a href="#設定圖片" class="headerlink" title="設定圖片"></a>設定圖片</h3><p>設定方式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假設網頁中的任意一張圖片原始大小為 900 像素，此時如果將瀏覽器寬度調整至小於 900 像素時，圖片預設還是會保持原本的大小，造成網頁產生 x 軸，但如果使用上述設定，圖片就會根據父層元素的寬度，以原始比例自動調整大小，並且最大不會超過圖片原始大小。</p>
<blockquote>
<p>屬性 max-width 若改為 width，可能會因為圖片解析度較小而失真。</p>
</blockquote>
<h3 id="設定容器寬度"><a href="#設定容器寬度" class="headerlink" title="設定容器寬度"></a>設定容器寬度</h3><p>一般情況下，網頁容器設定 Padding、Margin 或 Border 後，容器本身實際寬度都會改變，以下方原始碼為例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述 box 區塊在載入樣式後，寬度不是 width 所設定的 100 像素，而是 100 + 10 * 2 + 5 * 2，因此實際寬度會變成 130 像素，這樣在網頁排版時，會因為需要計算容器寬度而變得相當麻煩。</p>
<p>為了避免發生這方面的問題，可以在排版之前先加入以下設定：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">*,*<span class="hljs-selector-pseudo">::before</span>,*<span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>加入這段設定後，元素的寬度與高度就不會包含 Padding、Border 所產生的距離，可以理解成實際寬度等於設定的寬度（width、max-width）。</p>
<blockquote>
<p>margin 不在 border-box 範疇之內。</p>
</blockquote>
<h2 id="使用百分比控制寬度"><a href="#使用百分比控制寬度" class="headerlink" title="使用百分比控制寬度"></a>使用百分比控制寬度</h2><p>在響應式網頁中，也常會使用百分比（%）單位來設計網頁元素的排版，而使用百分比的元素會根據父層元素的寬度，自適應調整自身的寬度與高度。</p>
<p>以下方原始碼為例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>圖片一<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>圖片二<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>圖片三<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS / 假設已載入 meyerweb reset */</span><br>*,*<span class="hljs-selector-pseudo">::before</span>,*<span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: auto;<br>&#125;<br><span class="hljs-selector-class">.wrap</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>;<br>&#125;<br><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">33.33%</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-comment">/* 斷點一 */</span><br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span> ) &#123;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例在 ul 使用了 flex 屬性值，讓內層的元素 li 並排，而 li 因為設定了寬度 33.33%，因此當瀏覽器寬度在 1000 像素或以上時，li 會以三個並排的方式呈現；當瀏覽器寬度在 768 像素或以下時，斷點一的條件就會滿足，使該斷點的樣式設定覆蓋原先的設定，因為 ul 有設定 wrap 屬性值，因此 li 會以兩個並排的方式呈現。</p>
<h2 id="斷點規劃"><a href="#斷點規劃" class="headerlink" title="斷點規劃"></a>斷點規劃</h2><p>雖然在設計響應式網頁時，可以新增斷點讓網頁在不同瀏覽裝置上呈現不同排版，但是礙於現今裝置的多樣性，並沒有辦法透過幾個斷點就兼容所有瀏覽裝置，因此只能針對當下較熱門的解析度來設定斷點內容。</p>
<blockquote>
<p>可以使用 <a href="https://gs.statcounter.com/browser-market-share/all/taiwan/#monthly-202101-202201">statcounter</a> 工具來查詢目前熱門的螢幕解析度，並規劃網頁的斷點。</p>
</blockquote>
<h2 id="表格設計"><a href="#表格設計" class="headerlink" title="表格設計"></a>表格設計</h2><p>電腦版網頁中的表格在轉換至行動版時，為了避免瀏覽器寬度不足而擠壓到內容，可透過 display 設定屬性來將較不重要的欄位隱藏，以下為範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d-none&quot;</span>&gt;</span>訂單編號<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品項<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>產品價格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d-none&quot;</span>&gt;</span>001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>皮卡丘<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>雷之石<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1500<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-class">.wrap</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-tag">table</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">375px</span> ) &#123;<br>    <span class="hljs-selector-class">.d-none</span> &#123;<br>        <span class="hljs-attribute">display</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述為簡易的後台訂單表格，因為在 CSS 第 12 行設定了 Media Queries 的斷點設定，因此該表格在瀏覽器寬度 375 像素以下時，被加上 d-none 類別的 th 標籤與 td 標籤就會被隱藏。</p>
<p>但如果遇到在行動裝置上，表格的所有欄位都要顯示時，也可以透過以下方式來保留所有內容並防止內容擠壓，範例原始碼如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>訂單編號<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品項<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>產品價格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>皮卡丘<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>雷之石<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1500<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-class">.wrap</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-tag">table</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> ( <span class="hljs-attribute">max-width</span>: <span class="hljs-number">375px</span> ) &#123;<br>    <span class="hljs-selector-class">.wrap</span> &#123;<br>        <span class="hljs-attribute">overflow-x</span>: auto;<br>    &#125;<br>    <span class="hljs-selector-tag">table</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">375px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例與先前內容相同，但是在 Media Queries 的設定裡，針對表格的外容器 wrap 設定了 overflow-x 的屬性與對應值 auto，這種設定方式能夠使內容因擠壓而超出元素寬度時，使該容器本身產生 x 軸，而在 CSS 第16 行的部分因為將表格設定了固定寬度，因此就算瀏覽器寬度小於表格寬度也不會被擠壓，而是隱藏在外容器產生的 x 軸外。</p>
<h2 id="網頁優化"><a href="#網頁優化" class="headerlink" title="網頁優化"></a>網頁優化</h2><p>這一部分的內容與 RWD 較不相關，但也建議學會的小技巧！</p>
<h3 id="使用圖片取代文字"><a href="#使用圖片取代文字" class="headerlink" title="使用圖片取代文字"></a>使用圖片取代文字</h3><p>LOGO 是用來識別一個網站的重要圖片元素，而 h1 標籤通常是網頁中最重要的內容之一，可以透過以下技巧，將 LOGO 以 h1 標籤的方式撰寫，並將 h1 標籤中的文字隱藏不顯示，範例原始碼如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;logo&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.html&quot;</span>&gt;</span>最重要網頁標題<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;images/logo.svg&#x27;</span>); <span class="hljs-comment">/* 推薦使用 svg 圖片格式 */</span><br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 視圖片本身寬度而定 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 視圖片本身高度而定 */</span><br>    <span class="hljs-attribute">background-size</span>: contain; <span class="hljs-comment">/* 使圖片自適應在寬度與高度（200*100）之中 */</span><br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">101%</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例中，CSS 第 3~7 行的部分較容易理解，主要是設定背景圖片，而第 8 行開始，text-indent 的屬性值設定 101% 可使文字縮排至本身寬度以外，white-space 的屬性值 nowrap 則是能讓內容超過最大寬度時不會自動斷行，最後再透過 overflow 使寬度以外的部分隱藏不顯示。</p>
<p>圖片取代文字的用意，在於 LOGO 在網頁上呈現的結果雖然是一張圖片，但是搜索引擎的爬蟲機器人還是能夠抓取到被隱藏的文字內容，會比較有利於 SEO。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.w3schools.com/css/css_rwd_viewport.asp">RWD - The Viewport</a><br><a href="https://www.oxxostudio.tw/articles/201810/css-media-queries.html">CSS Media Queries 詳細介紹</a></p>
]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 套件 - Swiper</title>
    <url>/2022-06-06-swiper-note/</url>
    <content><![CDATA[<p>Swiper 可以實現網頁元素的輪播效果，本篇大概紀錄一下安裝的方式，以及一些常用的參數設定。</p>
<span id="more"></span>


<h2 id="Swiper-套件"><a href="#Swiper-套件" class="headerlink" title="Swiper 套件"></a>Swiper 套件</h2><p><a href="https://swiperjs.com/get-started">Swiper</a> 是一個製作網頁輪播效果的 JavaScript 插件。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>透過 CDN 方式安裝 Swiper 時，需要同時引入 <code>swiper-bundle.min.css</code> 與 <code>swiper-bundle.min.js</code> 兩個檔案，引入壓縮後的版本即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- In head --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://unpkg.com/swiper@8/swiper-bundle.min.css&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- In front of body end tag --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/swiper@8/swiper-bundle.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npm install swiper<br></code></pre></td></tr></table></figure>


<h2 id="基礎結構"><a href="#基礎結構" class="headerlink" title="基礎結構"></a>基礎結構</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>使用 Swiper 時，<code>swiper-container</code>、<code>swiper-wrapper</code>、<code>swiper-slide</code> 三者為必要存在的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Slider main container --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-container&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Additional required wrapper --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-wrapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Slides --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    ...  <span class="hljs-comment">&lt;!-- 新增 swiper-slide 數量 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- If we need pagination --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-pagination&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- If we need navigation buttons --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-prev&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- If we need scrollbar --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-scrollbar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>需要進行輪播的內容，會放在 <code>swiper-slide</code> 之中，數量可依需求自行新增。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>Swiper 在初始化時，會帶入一個 DOM / CSS Selector，以及一個參數（字串），如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> swiper = <span class="hljs-keyword">new</span> Swiper( swiperContainer, parameter );<br></code></pre></td></tr></table></figure>

<p>官方範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">new</span> Swiper(<span class="hljs-string">&quot;.swiper-container&quot;</span>, &#123;<br>  <span class="hljs-comment">// Optional parameters / 加入參數與設定值</span><br>  <span class="hljs-attr">direction</span>: <span class="hljs-string">&quot;vertical&quot;</span>, <span class="hljs-comment">// 輪播方向</span><br>  <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 重複顯示</span><br>  <span class="hljs-comment">// If we need pagination / 是否顯示分頁</span><br>  <span class="hljs-attr">pagination</span>: &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;.swiper-pagination&quot;</span><br>  &#125;,<br>  <span class="hljs-comment">// Navigation arrows / 是否加入上、下一頁方向圖示</span><br>  <span class="hljs-attr">navigation</span>: &#123;<br>    <span class="hljs-attr">nextEl</span>: <span class="hljs-string">&quot;.swiper-button-next&quot;</span>,<br>    <span class="hljs-attr">prevEl</span>: <span class="hljs-string">&quot;.swiper-button-prev&quot;</span><br>  &#125;,<br>  <span class="hljs-comment">// And if we need scrollbar / 是否顯示滾動軸</span><br>  <span class="hljs-attr">scrollbar</span>: &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;.swiper-scrollbar&quot;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="設定容器寬度"><a href="#設定容器寬度" class="headerlink" title="設定容器寬度"></a>設定容器寬度</h3><p>可自訂意義 Swiper 容器大小，範例如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.swiper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="常見參數"><a href="#常見參數" class="headerlink" title="常見參數"></a>常見參數</h2><p>除了先前官方範例提到的參數之外，以下列出一些在不同的版型下，可能會使用到的參數設定，更多可使用的參數可查閱<a href="https://swiperjs.com/swiper-api">官方文件</a>。</p>
<p><strong><code>effect</code></strong></p>
<p>主要用來變更輪播時的轉場效果，預設值為 <code>slide</code>，其他可使用效果還有 <code>fade</code>、<code>cube</code>、<code>coverflow</code>、<code>flip</code>、<code>creative</code>、<code>cards</code>。</p>
<p><strong><code>autoplay</code></strong></p>
<p>該參數屬於一個物件，會依據給予的屬性設定來自定義自動輪播的形式，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">new</span> Swiper(<span class="hljs-string">&quot;.swiper-container&quot;</span>, &#123;<br>  <span class="hljs-attr">autoplay</span>: &#123;<br>    <span class="hljs-attr">delay</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 自動輪播延遲時間</span><br>    <span class="hljs-attr">disableOnInteraction</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 手動滑動後，停止自動撥放，預設值為 true</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong><code>slidesPerView</code></strong></p>
<p>該參數可以決定輪播時，同時顯示的 <code>swiper-slide</code> 數量，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">new</span> Swiper(<span class="hljs-string">&quot;.swiper-container&quot;</span>, &#123;<br>  <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// 同時顯示 3 個 swiper-slide</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>加入參數 <code>slidesPerView</code> 後，<code>swiper-slide</code> 的寬度會根據 swiper-container 來均分。</p>
</blockquote>
<p><strong><code>breakpoints</code></strong></p>
<p>加入該參數後，配合參數 <code>slidesPerView</code> 可根據所設定的斷點來達成響應式的效果，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">new</span> Swiper(<span class="hljs-string">&#x27;.swiper&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 預設的顯示數量為 1</span><br>  <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// 以下為斷點設定</span><br>  <span class="hljs-attr">breakpoints</span>: &#123;<br>    <span class="hljs-comment">// 當頁面寬度大於 768px 時，同時顯示數量為 2</span><br>    <span class="hljs-number">768</span>: &#123;<br>      <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">2</span><br>    &#125;,<br>    <span class="hljs-comment">// 當頁面寬度大於 992px 時，同時顯示數量為 3</span><br>    <span class="hljs-number">992</span>: &#123;<br>      <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">3</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong><code>spacebetween</code></strong></p>
<p>該參數可以設定每個 <code>swiper-slide</code> 之間的間隙，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">new</span> Swiper(<span class="hljs-string">&#x27;.swiper&#x27;</span>, &#123;<br>  <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">spacebetween</span>: <span class="hljs-number">16</span>, <span class="hljs-comment">// 預設間隔為 20px</span><br>  <span class="hljs-attr">breakpoints</span>: &#123;<br>    <span class="hljs-number">768</span>: &#123;<br>      <span class="hljs-attr">slidesPerView</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">spacebetween</span>: <span class="hljs-number">24</span> <span class="hljs-comment">// 當頁面寬度大於 768px 時，間隔為 24px</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Package</category>
      </categories>
      <tags>
        <tag>Swiper</tag>
        <tag>Package</tag>
      </tags>
  </entry>
  <entry>
    <title>SCSS 實用語法</title>
    <url>/2022-06-07-sass-note/</url>
    <content><![CDATA[<p>最近接觸到 Sass/SCSS，覺得各方面的功能都太方便了，這輩子大概不會想回去寫純 CSS 了吧。這篇筆記整理了一些新手必須學會的語法。</p>
<span id="more"></span>


<h2 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h2><h3 id="使用-amp-表示父選擇器"><a href="#使用-amp-表示父選擇器" class="headerlink" title="使用 &amp; 表示父選擇器"></a>使用 &amp; 表示父選擇器</h3><p>以下是一個簡單的 Scss 格式設定：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-selector-class">.header-title</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>  &#125;<br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">8</span> <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;<br>  &#125;<br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述例子可以改用 &amp; 的方式來撰寫，以 &amp; 符號來表示父層，其運行結果想同，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  &amp;-title &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>  &#125;<br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">8</span> <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Variable-變數"><a href="#Variable-變數" class="headerlink" title="Variable 變數"></a>Variable 變數</h3><p>一個設定可能會在許多不同的區塊重複被使用，此時就能夠透過變數來統一管理，好處是後續若需要修改值，只需要修改變數值即可，而變數格式為 <code>$name: value</code>，以顏色為範例，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color-primary</span>: <span class="hljs-number">#00cc99</span>;<br><span class="hljs-selector-class">.header</span> &#123;<br>  &amp;-title &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color-primary</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.footer</span> &#123;<br>  &amp;-title &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color-primary</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>變數值可使用的格式分別有以下幾種：</p>
<ul>
<li>數字：<code>2</code>、<code>16px</code>、<code>2rem</code></li>
<li>字串：<code>"文字"</code>、<code>"./img/logo.png"</code></li>
<li>顏色：<code>blue</code>、<code>#00CC99</code>、<code>rgba(0,0,0,0.5)</code></li>
<li>布林：<code>true</code>、<code>false</code></li>
<li>空值：<code>null</code></li>
<li>值列：<code>16px 8px</code>、<code>"arial, sans-serif"</code></li>
<li>運算：<code>1rem * 1.25</code></li>
</ul>
<h3 id="調整色彩明度"><a href="#調整色彩明度" class="headerlink" title="調整色彩明度"></a>調整色彩明度</h3><p>除了直接輸入顏色或色碼，也能夠使用 <code>darken</code>、<code>lighten</code> 來調整所設定顏色的明暗程度，範例如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color-primary</span>: <span class="hljs-number">#00cc99</span>;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">color</span>: darken(<span class="hljs-variable">$color-primary</span>, <span class="hljs-number">25%</span>); <span class="hljs-comment">// 亮度減少 25%</span><br>&#125;<br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: lighten(<span class="hljs-number">#ddd</span>, <span class="hljs-number">15%</span>); <span class="hljs-comment">// 亮度增加 15%</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="import-匯入檔案"><a href="#import-匯入檔案" class="headerlink" title="@import 匯入檔案"></a>@import 匯入檔案</h3><p>較大的專案為了方便管理程式碼，通常會將 scss 檔案進行較細的拆分，而這些拆分出來的檔案可透過 <code>@import</code> 來統一匯入（合併）一個 scss 檔案中，範例如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 目前檔案為 all.scss</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;variable&#x27;</span>;<br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;reset&#x27;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;base&#x27;</span>;<br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;mixin&#x27;</span>;<br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;main&#x27;</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>檔案的分類可參考 <a href="https://gist.github.com/rveitch/84cea9650092119527bc">Sass 7-1 Pattern</a>，或是此篇<a href="https://medium.com/ivycodefive/4-%E4%BB%80%E9%BA%BC%E6%98%AFsass-7-1%E6%9E%B6%E6%A7%8B-8687e9a10a64">文章</a>。</p>
</blockquote>
<p>補充說明：被合併的 scss 檔案，檔案名稱會使用 _ 做開頭，除了用來表示合併用，也不會被編譯成 css 檔案，但是在匯入時不需要加上下底線，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 正確匯入方式</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;variable&#x27;</span>;<br><span class="hljs-comment">// 錯誤匯入方式</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;_variable&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="mixin-混合多個設定"><a href="#mixin-混合多個設定" class="headerlink" title="@mixin 混合多個設定"></a>@mixin 混合多個設定</h3><p>Mixin 的原理與變數相同，主要是將一些較常使用的語法組合封裝並且定義成一個名稱，等需要使用時，再透過 <code>@include</code> 來導入內容，範例如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// _mixin.scss</span><br><span class="hljs-keyword">@mixin</span> textHide &#123; <span class="hljs-comment">// 圖片取代文字</span><br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">101%</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> desktop &#123; <span class="hljs-comment">// 響應式斷點</span><br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-keyword">@content</span>; <span class="hljs-comment">// 表示導入後所撰寫的內容位置</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// _main.scss</span><br><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;images/logo.svg&quot;</span>);<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">background-size</span>: contain;<br>  <span class="hljs-keyword">@include</span> textHide;<br>  <span class="hljs-keyword">@include</span> desktop &#123;<br>    <span class="hljs-comment">// 此區塊的內容會對應 @content 位置</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="實用語法"><a href="#實用語法" class="headerlink" title="實用語法"></a>實用語法</h2><h3 id="for-運作原理"><a href="#for-運作原理" class="headerlink" title="@for 運作原理"></a>@for 運作原理</h3><p>Sass 的 <code>@for</code> 運作方式類似 JavaScript 的 for 迴圈，能夠依序並重複套用相同的設定，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box box-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box box-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box box-3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box box-4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box box-5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// scss</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">5</span> &#123; <span class="hljs-comment">// through 若改使用 to，則不包含最終值</span><br>    <span class="hljs-selector-class">.box-</span>#&#123; <span class="hljs-variable">$i</span> &#125;&#123; <span class="hljs-comment">// 變數需要加上 # 並使用 &#123;&#125; 包覆，否則無法正常讀取</span><br>    <span class="hljs-attribute">background</span>: darken( <span class="hljs-number">#eee</span>, <span class="hljs-variable">$i</span> * <span class="hljs-number">5%</span> );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例 scss 設定中，第 6 行使用了 <code>@for</code> 方法來設定不同的背景顏色，<code>$i</code> 表示帶入數字的變數，<code>from</code> 會接一個起始值，<code>through</code> 則是會接一個最終值。</p>
<p>而第 7 行的 <code>$i</code> 會先帶入初始值 1，此時就會針對 <code>.box-1</code> 設定下方的樣式 <code>background: darken( #eee, 1 * 5% )</code>，接著 <code>$i</code> 會再帶入 2，並進行與前一次相同的設定，直到最終值進行結束為止。</p>
<h3 id="Sass-Map-是甚麼"><a href="#Sass-Map-是甚麼" class="headerlink" title="Sass Map 是甚麼?"></a>Sass Map 是甚麼?</h3><p>Sass Map 是一種集合變數，概念有點類似 JSON，但是不同的地方在於 Sass Map 會將定義的變數透過<strong>小括弧</strong> <code>()</code> 包裝成一個群組，格式為 <code>$變數名稱: (key: value);</code>，範例如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$colors</span>: (<br>  // key: value<br>  <span class="hljs-string">&#x27;primary&#x27;</span>: <span class="hljs-number">#007bff</span>, // 每個設定之間需要使用半形逗號隔開<br>  <span class="hljs-string">&#x27;secondary&#x27;</span>: <span class="hljs-number">#6c757d</span>,<br>  <span class="hljs-string">&#x27;success&#x27;</span>: <span class="hljs-number">#28a745</span><br>); <span class="hljs-comment">// 必須加上 ; 做結尾以免影響後方程式碼運作</span><br></code></pre></td></tr></table></figure>

<p>設定 Sass Map 之後，可以透過 <code>map-get</code> 來取用變數的內容，以上述例子來說，若想取用 <code>$primary</code> 來當作文字的顏色，做法如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">background</span>: map-get(<span class="hljs-variable">$colors</span>, <span class="hljs-string">&#x27;primary&#x27;</span>);<br>&#125;;<br><span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">background</span>: map-get(<span class="hljs-variable">$colors</span>, <span class="hljs-string">&#x27;secondary&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上述範例來說，雖然可以透過 <code>map-get</code> 來取得對應的變數內容，但是若針對個別項目逐一取用設定，效率會相對較低，因此通常會搭配 <code>@each</code> 來做使用。</p>
<h3 id="each-運作原理"><a href="#each-運作原理" class="headerlink" title="@each 運作原理"></a>@each 運作原理</h3><p>Sass 的 <code>@each</code> 類似 JavaScript 的 each，搭配先前提到的 Sass Map 就可以產出大量的樣式設定，而 <code>@each</code> 的格式為 <code>@each $key, $value in 集合變數&#123;...&#125;</code> ，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Button1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-secondary&quot;</span>&gt;</span>Button2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-success&quot;</span>&gt;</span>Button3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// scss</span><br><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>&#125;<br><span class="hljs-variable">$colors</span>: (<br>  <span class="hljs-string">&#x27;primary&#x27;</span>: <span class="hljs-number">#007bff</span>,<br>  <span class="hljs-string">&#x27;secondary&#x27;</span>: <span class="hljs-number">#6c757d</span>,<br>  <span class="hljs-string">&#x27;success&#x27;</span>: <span class="hljs-number">#28a745</span><br>);<br><span class="hljs-keyword">@each</span> <span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span> in <span class="hljs-variable">$colors</span> &#123;<br>  <span class="hljs-selector-class">.btn-</span>#&#123;<span class="hljs-variable">$key</span>&#125; &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-variable">$value</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述範例 scss 設定中，第 10 行使用了 <code>@each</code> 並指定了集合變數 <code>$colors</code>，此時變數 <code>$colors</code> 中的每個 key 與 value 就會帶入 <code>@each</code> 大括弧裡的對應位置，最後再套用設定到對應的類別之中。</p>
<h3 id="extend-合併相同樣式"><a href="#extend-合併相同樣式" class="headerlink" title="@extend 合併相同樣式"></a>@extend 合併相同樣式</h3><p>在進入 <code>@extend</code> 之前，先簡單說明<strong>佔位符選擇器</strong>（Placeholder Selectors）是什麼，它與 class、id 兩種選擇器類似，差別在於佔位符選擇器在 Sass 中會使用 <code>%</code> 來定義，且必須透過 <code>@extend</code> 來調用，在被 <code>@extend</code> 調用之前，本身並不會被編譯到 .css 檔案中。</p>
<p>進入正題，如果相同的樣式設定被重複使用在多個類別中，可以透過 <code>%</code> 搭配 <code>@extend</code> 的做法，使 Sass 檔案在編譯後，有相同設定的類別就會被合併在一起，以減少多餘的程式碼產生，簡單概念如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// .scss 未使用 @extend</span><br><span class="hljs-selector-class">.header-btn</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#007bff</span>;<br>&#125;<br><span class="hljs-selector-class">.section-btn</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#6c757d</span>;<br>&#125;<br><span class="hljs-selector-class">.footer-btn</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#28a745</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// .scss 使用 @extend</span><br>%btn-base &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>&#125;<br><span class="hljs-selector-class">.header-btn</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %btn-base;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#007bff</span>;<br>&#125;<br><span class="hljs-selector-class">.section-btn</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %btn-base;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#6c757d</span>;<br>&#125;<br><span class="hljs-selector-class">.footer-btn</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %btn-base;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#28a745</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*  編譯後的 .css  */</span><br><span class="hljs-selector-class">.footer-btn</span>, <span class="hljs-selector-class">.section-btn</span>, <span class="hljs-selector-class">.header-btn</span> &#123; <span class="hljs-comment">/* 相同設定合併在一起 */</span><br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;<br>&#125;<br><span class="hljs-selector-class">.header-btn</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#007bff</span>;<br>&#125;<br><span class="hljs-selector-class">.section-btn</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#6c757d</span>;<br>&#125;<br><span class="hljs-selector-class">.footer-btn</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#28a745</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可能會有人說，直接將共通的設定寫在一個 <code>.btn</code> 裡面不是比較方便且簡潔嗎？確實是這樣，而上述使用 <code>%btn-base</code> 來當作案例，主要是為了方便理解 <code>@extend</code> 的運作原理，實際上較不會透過以上做法來設定按鈕的共通樣式。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/ivycodefive/4-%E4%BB%80%E9%BA%BC%E6%98%AFsass-7-1%E6%9E%B6%E6%A7%8B-8687e9a10a64">什麼是Sass 7-1架構?</a><br><a href="https://www.casper.tw/css/2016/12/25/sass-map/">鐵人賽 25 - 實戰心法 - Sass Map 快出產出大量樣式</a></p>
]]></content>
      <categories>
        <category>Sass/SCSS</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁切版直播班心得</title>
    <url>/2022-09-10-hexschool-web-feedback/</url>
    <content><![CDATA[<p>2022 夏，切版直播班心得。</p>
<span id="more"></span>



<h2 id="報名契機"><a href="#報名契機" class="headerlink" title="報名契機"></a>報名契機</h2><p>今年年四月左右參加了為期一個月的公益體驗營，然而在體驗營結束前夕，學院按照慣例會推坑下一次的活動，這次是切版直播班，不過內容相較過去更為豐富，教學大綱除了舊有的 Bootstrap 到近幾年盛行的 Tailwind，思索一番之後還是報名了。其實原本是衝著 Tailwind 來的，但礙於過去在切版方面都是純手刻又覺得 Bootstrap 很困難而遲遲不去面對，導致自己連一個 CSS 框架都不會，另一方面自己在新技能的學習上會需要花不少時間來吸收，擔心一次學兩個會應付不來，因此就把目標先轉向了目前使用率較高的 Bootstrap；除此之外，這次也要求自己必須把八週主線任務的所有頁面都切出來，既然都全職學習了，至少這一點是能做到的吧。</p>
<h2 id="每週學習歷程"><a href="#每週學習歷程" class="headerlink" title="每週學習歷程"></a>每週學習歷程</h2><h3 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h3><p>雖然每週直播的教學內容算是在複習錄影，但是現場跟大家一起聽課的氛圍比起自己看錄影兩者還是有差的，而且常常會有同學在聊天室提出一些平常可能不太會注意到的有趣問題，也能當作是一種額外的知識吸收，此外當然也少不了校長的嘴砲模式以及心靈雞湯，畢竟學程式容易產生焦慮，長時間學習下還是需要找地方宣洩一下情緒。八週的直播形式基本上都是前面提到的這樣，整體的感覺不錯，這部分也沒有需要特別需要補充甚麼了，不過直播班本來就是以大量輸出為前提，每週花費在作業上的時間自然就比較多。</p>
<p>另外這次直播班每週是有兩場直播的，上述提到的是週五例行的直播，另一場則是週三的 Tailwind 主題，雖然大部分心思都投入在 Bootstrap 上面，但是每週還是有聽課並把作業都做過一次，整體感覺其實是很不錯的。</p>
<h3 id="小組討論"><a href="#小組討論" class="headerlink" title="小組討論"></a>小組討論</h3><p>這次被分配到的組別還不錯，每週的小組討論出席率都很高，只是大多數的組員平時都比較忙，也有組員加班到很晚還趕回來餐與討論，辛苦各位了，無法出席的人也會透過線下時間把作業補齊，也要特別感謝組長主持以及做資料彙整，不得不說組長真的很認真好學，小組伺服器的發問次數也是最多的，自己也從不少問題中學到各種額外的知識，賺爛了。</p>
<h3 id="每日任務"><a href="#每日任務" class="headerlink" title="每日任務"></a>每日任務</h3><p>不得不說每日任務真的是很棒的學習資源，每天會釋出一道小題目給學員練習，有時候作業卡關也能從這邊找到線索，也可以學到很多平常不知道的知識，算是一個小寶庫；不過後半段的部分因為都在趕主線任務的進度，幾乎都是用補交的就是了。</p>
<h3 id="主線任務"><a href="#主線任務" class="headerlink" title="主線任務"></a>主線任務</h3><p>作業方面主線任務難度是最高的，前兩週比較像是在試水溫，但是從第三週開始版型就是一個完整的電商網站了，印象中在做第三週時，平均一頁包含 RWD 就花了幾乎一天的時間，切完所有頁面後開始地毯式搜索看有甚麼地方沒處理仔細或是可以再調整，也嘗試透過簡單的 JS 加入了一些小功能和效果，結果自己很滿意。</p>
<p>第四週設計稿和第三週是同一份，差別在於第四週需要透過 Gulp 來做，講白一點這已經不是切版的範疇了，但是提早面對終端機指令、版本相容性或是編譯等問題對未來學習上無疑是好事，不過 Gulp 要怎麼寫任務就要靠自己學了，可惡！好想學會自己寫 Gulp 啊！！</p>
<p>第五週是後台版型，也開始嘗試使用以前一直不敢面對的 Bootstrap，然而這週的作業是一邊看官方文件一邊做的，大部分的時間都花在看文件而不是切版，為了讓自己能早一點習慣使用 Bootstrap，有好幾天晚上睡前用手機都不是在看社群，而是在看官方文件…。</p>
<p>校長在第一次直播時，有大概用折線圖描述一下每週的作業難度，印象中第六週的難度是僅次於第八週的，而且第六週開始被要求使用 CSS 框架來做，還好前一段時間花了不少時間研究 Bootstrap，現在通用類別與元件在使用上已經熟練了非常多，頓時覺得自己以前只是懶的去看密密麻麻的文件而已。除此之外，第六週設計稿部分區塊還需要引入 JS 套件，從 Discord 作業討論頻道也可以看到不少學員受到 Swiper 無情肆虐。自己也花費將近一週的時間才做完，就順便整合第七週一起繳交了，然而心想終於可以休息一下，結果第八週設計稿就提前釋出，害我差點就忘記自己還在通往地獄的列車上。</p>
<p>第八週的設計稿很特別，充斥著各式各樣酷炫的排版。在這過程中也做了很多以往沒做過的嘗試，首先是開始自己設計元件，先前看到其他同學不用 Pages 資料夾就能做出所有頁面，自己早就想嘗試看看了，意外的是然辦到了！果然有些事如果不做永遠不知道結果；另外也學會了客製化通用類別的方法，不得不說使用起來很方便可惜相見恨晚。不過最麻煩的部分還是 JS 套件，這部分花了很多時間不斷嘗試和理解才做出來，從拿到設計稿到切完所有頁面大概用了一個多禮拜的時間，真的好累啊…。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本來以為自己會倒在第八週，但意外的挺過來了，不得不說即便是全職學習還是覺得時間很緊迫，真心佩服那些平時有工作還來進修的同學。總結來說，這次直播班真的扎扎實實的學到很多知識，同時也深刻體會到學習是沒有捷徑的，追求卓越的唯一方法只有不斷的練習，最後非常感謝六角學院提供這麼棒的學習資源和環境，兩位講師和每位助教都辛苦了，小心肝啊！！</p>
<p>（長嘆，肝了無數個夜晚終於可以休息一下了，啊~原來我報名了 JS 直播班，差點忘記我搭的是不停靠的直達列車了。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>六角學院</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex 水平置中，子元素溢出時避免被裁切</title>
    <url>/2022-09-17-css-max-content/</url>
    <content><![CDATA[<p>前一段時間在切版上遇到了一個問題，研究之後發現一個有趣的解決方法，也藉此機會紀錄一下。</p>
<span id="more"></span>


<p>以下是範例情境：</p>
<p><img src="https://i.imgur.com/TK9ZZcF.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section mt-3&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section-title&quot;</span>&gt;</span>Section Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS（上方列表區塊） */</span><br><span class="hljs-selector-class">.list</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例中，上方 <code>.list</code> 區塊使用 <code>display: flex</code> 加上 <code>justify-content: center</code> 讓子元素置中，同時希望瀏覽器寬度縮小至子元素溢出時，溢出的部分以水平軸方式呈現，因此加入了 <code>overflow: auto</code> 設定，呈現畫面如下：</p>
<p><img src="https://i.imgur.com/Sn1BMH4.png"></p>
<p>然而將水平軸向左滾動至最底時，溢出的部分卻被裁切了，而問題就在 <code>justify-content: center</code> 這個屬性上，移除該屬性之後，子元素溢出的部分就會正常呈現，如下：</p>
<p><img src="https://i.imgur.com/6GYarUd.png"></p>
<p>此時問題來了，在不使用 <code>justify-content: center</code> 的情況下，要如何同時滿足子元素保持置中，但是溢出情況下不會被裁切呢？在思索一番後想到另一個能使區塊水平置中的語法，就是 <code>margin: 0 auto</code>，不過這個語法只適用具有實際寬度但非滿版的區塊，而範例中的 <code>.list</code> 區塊因為 <code>display: flex</code> 的關係佔了滿版的寬，因此並沒有如預期置中。下圖是區塊實際佔用的空間：</p>
<p><img src="https://i.imgur.com/WnJz6ud.png"></p>
<p><strong>解決方式：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS（上方列表區塊） */</span><br><span class="hljs-selector-class">.list</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">max-width</span>: max-content;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>僅需在 <code>.list</code> 區塊加上 <code>max-width: max-content</code> 語法即可，而 <code>max-content</code> 最基本的作用是讓區塊寬度或高度自適應子元素，並且當子元素溢出時，內容不會受到擠壓而換行；此處正好利用了前者特性，使 <code>.list</code> 最大寬度等於所有子元素（<code>.list-item</code>）寬度的加總，此時再配合 <code>margin: 0 auto</code> 之後區塊得以置中，並且當子元素溢出時不會被裁切。結果如下圖所示：</p>
<p><img src="https://i.imgur.com/MLip3hT.png"></p>
<p><strong>實作範例：</strong></p>
<iframe src="https://codepen.io/Cliff_hex/embed/bGMqLOq?default-tab=css,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>

<blockquote>
<p>max-content 詳細說明請參考此<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-content">文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 觀念 - 函式</title>
    <url>/2022-09-19-javascript-function/</url>
    <content><![CDATA[<p>簡單的紀錄一下函式的基本知識。</p>
<span id="more"></span>

<h2 id="函式（Function）簡述"><a href="#函式（Function）簡述" class="headerlink" title="函式（Function）簡述"></a>函式（Function）簡述</h2><p>可以將自訂的程式碼進行包裝，並且能在需要時使用，同時減少撰寫重複的程式碼。此外，函式也能接收一個值（參數），並將接收的值進行運算後再回傳，但也可以選擇不接收、不回傳任何值，以「執行某一段邏輯」的目的存在。</p>
<h2 id="函式結構"><a href="#函式結構" class="headerlink" title="函式結構"></a>函式結構</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeThing</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num ** num;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基本的函式可以使用關鍵字 <code>function</code> 來宣告，後方需要加上自訂的函式名稱，透過這種方式宣告的函式稱為「具名函式」，而函式名稱後方的小括號中可放入接收的值（參數），中括號中則是放入想要執行的程式指令，另外可將傳入的值帶入程式中運算，而函式執行後的結果可使用 <code>return</code> 決定要回傳的內容，也可以不回傳，但是若有使用 <code>return</code> 但是後方沒有接任何要回傳的值，則會回傳 <code>undefined</code>。</p>
<p>return 差異如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeThing</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num ** num; <span class="hljs-comment">// 指定回傳的結果</span><br>&#125;<br>doSomeThing(<span class="hljs-number">2</span>); <span class="hljs-comment">// 回傳結果 4</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeThing</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 未指定回傳結果</span><br>&#125;<br>doSomeThing(<span class="hljs-number">2</span>); <span class="hljs-comment">// 回傳結果 undefined</span><br></code></pre></td></tr></table></figure>

<h2 id="函式執行"><a href="#函式執行" class="headerlink" title="函式執行"></a>函式執行</h2><p>函式在寫好的當下式不會立即執行的，如果要執行，則需要在函式名稱的後方加上一組小括號，這個動作又稱為「呼叫（Invoke）」；而小括號若加在型別非函式的變數後方會產生錯誤，因此不可隨意加上。</p>
<p>執行 / 呼叫函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">functionName(); <span class="hljs-comment">// 括號中可決定是否要傳入參數值</span><br></code></pre></td></tr></table></figure>

<h2 id="函式終止"><a href="#函式終止" class="headerlink" title="函式終止"></a>函式終止</h2><p>函式在被呼叫後，會將函式內的程式碼從第一行執行到最後，接著就會終止函式，但是如果有使用到 <code>return</code>，該函式則會提前終止，並回傳 <code>return</code> 後方的值。</p>
<p>使用 return 終止函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = num + num;<br>  <span class="hljs-keyword">return</span> result;<br>  <br>  result ++; <span class="hljs-comment">// 提前終止而未被執行</span><br>&#125;<br>calculate(<span class="hljs-number">5</span>); <span class="hljs-comment">// 回傳結果 10</span><br></code></pre></td></tr></table></figure>

<h2 id="陳述式與表達式"><a href="#陳述式與表達式" class="headerlink" title="陳述式與表達式"></a>陳述式與表達式</h2><p>JavaScript 語法上有區分陳述式、表達式兩種類型。</p>
<ul>
<li><p>陳述式（Statement）：如同名稱一樣，可想像成在描述一件事情或是對邏輯的描述（如：if 邏輯判斷、具名函式），而陳述式會執行一系列的操作，但是<strong>不會回傳結果</strong>。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E9%81%8B%E7%AE%97%E5%BC%8F">MDN 文件 - 陳述式</a></p>
</blockquote>
</li>
<li><p>表達式（Expression）：只要程式在執行結束之後<strong>會回傳一個結果</strong>，就屬於表達式，換句話說表達式是一段能被 JavaScript 運算並產生數值的程式碼。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators">MDN 文件 - 表達式</a></p>
</blockquote>
</li>
</ul>
<p>陳述 / 表達式範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 變數宣告</span><br><span class="hljs-keyword">var</span> x;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 指派值</span><br>x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判斷式</span><br><span class="hljs-keyword">if</span>(x === <span class="hljs-number">10</span>) &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可分別將上述程式碼放在開發人員工具 console 中執行查看，變數在宣告後回傳 <code>undefined</code>，屬於陳述式；指派一個值給變數，而變數會回傳指派的值，屬於表達式；而判斷式本身並不會回傳任何值，因此屬於陳述式。</p>
<h2 id="函式陳述式"><a href="#函式陳述式" class="headerlink" title="函式陳述式"></a>函式陳述式</h2><p>前面所提到透過給予函式名稱的所宣告的函式，也就是一般函式宣告，就屬於函式陳述式。</p>
<h2 id="函式表達式"><a href="#函式表達式" class="headerlink" title="函式表達式"></a>函式表達式</h2><p>除了一般的的函式宣告，還可以將函式指派給一個變數，因為函式本身也屬於物件的一種，因此能夠當作一個被指派的值，而這種方式產生的函式曾為函式表達式。</p>
<p>函式表達式範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> expressionFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 觀念 - 同步與非同步</title>
    <url>/2022-09-20-javascript-sync-async/</url>
    <content><![CDATA[<p>這篇僅記錄同步、非同步是什麼樣的概念，並沒有處理非同步問題的方式。</p>
<span id="more"></span>


<h2 id="JavaScript-中的同步"><a href="#JavaScript-中的同步" class="headerlink" title="JavaScript 中的同步"></a>JavaScript 中的同步</h2><p>「同步（Synchronous）」在你的認知上會怎麼解釋？我自己原本的想法是同時處理很多事情，但這個說法在 JavaScript 卻有些出入，原因在於 JavaScript 是以「單執行緒（單線程）」的方式在執行程序，特性是「一次只做一件事，前面的事做完才會依序做下一件事」。</p>
<blockquote>
<p>執行緒相關內容可參考此<a href="https://www.itread01.com/ixyfq.html">文章</a>。</p>
</blockquote>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNum</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125; <br>printNum();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>以上面程式碼來說，會先執行函式 <code>printNum</code> 印出 <code>1</code>，接著再印出 <code>2</code>，並且兩者是有先後順序的，屬於同步執行。</p>
<h2 id="何謂非同步"><a href="#何謂非同步" class="headerlink" title="何謂非同步"></a>何謂非同步</h2><p>「非同步（Asynchronous）」特性是「可以同時做很多事，並且不需要等待前面的事做完就能做下一件事」，其實就是自己一開始對同步的認知。</p>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(printNum, <span class="hljs-number">2000</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNum</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125; <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>程式碼中 <code>setTimeout</code> 會分別帶入 <code>callback</code>、<code>等待毫秒</code> 兩個參數，而回調函式 <code>printNum</code> 被設定 2 秒後才執行，但是這程中第 5 行的程式碼並不會等待前面的函式 <code>printNum</code>  執行完才動作，而是先印出 <code>2</code>，等待 2 秒之後呼叫函式 <code>printNum</code> 並印出 <code>1</code>。</p>
<p>但是 JavaScript 屬於單執行緒，所以一次應該只會做一件事，為什麼會有範例中非同步的狀況？原因是 JavaScript 在 V8 引擎（JavaScript 引擎）運行時，引擎在運作時是同步的，但是除了引擎內的 JavaScript 原始程式碼之外，瀏覽器也會提供許多 Web APIs（如：document、MouseEvent、setTimeout…等等），這些並不屬於 V8 引擎的範疇，但是可以透過呼叫並使用它們做到非同步的行為，並且不會影響到 JavaScript 主程式的運行，可以理解成 JavaScript 需要依賴 Web APIs 才能達成非同步的效果。</p>
<p>而 <code>setTimeout</code> 等待的期間，程式碼為甚麼能夠繼續往下執行？原因是當 Web APIs 與自己寫的 JavaScript 在瀏覽器一起執行時，透過 Web APIs 非同步呼叫的 callback function 會被放到 Callback Queue（儲列 / 佇列）待命，等到其他程式碼都執行完之後才會被呼叫。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://chanchandev.com/js/Async/async-sync-intro/2534378084/">Javascript 非同步 &amp; Event Loop！10 分鐘輕鬆圖解學習！</a></p>
<p><a href="https://5xruby.tw/posts/how-js-synchronous-works">無痛理解 JS | 非同步怎麼運作？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>synchronous</tag>
        <tag>asynchronous</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 觀念 - 提升</title>
    <url>/2022-09-24-javascript-hoisting/</url>
    <content><![CDATA[<p>ES6 前後的 Hoisting 觀念筆記。</p>
<span id="more"></span>


<p>「提升（Hoisting）」是 JavaScript 特有的一種現象，它的意思是當一個變數或函式在被宣告之前就可以被使用，並且不會出現錯誤，另外 ES6 以前都是使用 <code>var</code> 來宣告變數，與 ES6 新增的 <code>let</code>、<code>const</code> 在提升行為會也有所不同。</p>
<h2 id="ES6-以前的提升"><a href="#ES6-以前的提升" class="headerlink" title="ES6 以前的提升"></a>ES6 以前的提升</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure>

<p>以上針對 <code>x</code> 取值，但是在這之前並沒有宣告一個名為 <code>x</code> 的變數，因此會找不到該變數而回報錯誤，下面是正常的做法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x;<br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>這樣就是一個正常的流程，程式碼會從第一行開始由上往下執行，所以在使用變數之前需要先宣告變數，以確保這個變數是存在的。</p>
<p>接著下面嘗試把第 1、2 行位置進行對調：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-keyword">var</span> x;<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>按照前面的說法，上述程式碼應該會回報錯誤，但是得到的結果卻是 <code>undefined</code>，而這就是提升所造成的現象，感覺像是 <code>var x</code> 這段程式碼被提升到所有程式碼之前。</p>
<p>大多數的程式語言中，變數在被使用之前是需要先宣告的，但是 JavaScript 可以在變數宣告之前就使用該變數，不過關於提升還有一些注意事項，就是會被提升的只有<strong>宣告的行為</strong>，值的指派並不會被提升，以下面程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">7</span>; <span class="hljs-comment">// 宣告變數並指派值</span><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure>

<p>範例跟前面的相同，只是多了一個指派數值的動作，而最後也印出預期的結果，這個時候如果再將 1、2 行位置進行對調，印出的結果會是 <code>7</code> 嗎？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">7</span>;<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>答案是 <code>undefined</code>，照理來說宣告的變數會被提升，可是得到的結果卻不是 <code>7</code>，原因其實就如前面提到的，會被提升的只有宣告的動作，而範例中宣告的動作指的是 <code>var x</code>，後方的 <code>= 7</code> 屬於值的指派，並不會跟著宣告一起被提升。</p>
<p>但是結果為甚麼會是 <code>undefined</code>？原因在於 JavaScript 在開始執行你撰寫的程式碼之前，會先把所有宣告的變數、一般函式都預留一個記憶體空間，但不會馬上指派值給變數，這個預留記憶體空間的動作就是提升，到這邊為止屬於「創造階段」，而這個階段結束之後，變數才會被賦值，這個賦值的過程則是「執行階段」，<code>undefined</code> 就是變數在創造階段建立記憶體空間時，預設給定的初始值。</p>
<p>可以將上面的程式碼運作流程理解成以下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x; <span class="hljs-comment">// 宣告變數（會被提升）</span><br><span class="hljs-built_in">console</span>.log(x);<br>x = <span class="hljs-number">7</span>; <span class="hljs-comment">// 指派值</span><br></code></pre></td></tr></table></figure>

<p>目前為止已經知道會被提升的只有宣告的動作，但是除了變數之外，一般的函式宣告也會被提升，以下面程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fn();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure>

<p>嘗試在函式被宣告之前呼叫，也可以順利執行且不會回報錯誤，因為這是一般的函式宣告（具名函式），整個函式都會被提升，因此就可以在函式宣告之前呼叫。</p>
<p>那匿名函式就不會被提升嗎？答案是會，下面嘗試將範例改成以匿名函式的方式建立：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fn();<br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// TypeError: fn is not a function</span><br></code></pre></td></tr></table></figure>

<p>結果出現錯誤了，不過是不是與 <code>var</code> 宣告的變數很像？其實概念是一樣的，這裡的程式碼確實有被提升，但是被提升的只有變數的宣告 <code>var fn</code>，函式的資料在執行階段才會指派給變數 <code>fn</code>，此時的 <code>fn</code> 的值為 <code>undefined</code>，而 <code>undefined</code> 並非函式因此呼叫的行為就會回報錯誤。</p>
<p>雖然無法呼叫，但是能透過變數取值來驗證上述說法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(fn);<br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>而程式碼實際運作流程就像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn;<br><span class="hljs-built_in">console</span>.log(fn);<br>fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>總結來說，JavaScript 中的「提升（Hoisting）」指的是宣告變數的提升，而值的賦予並不會提升；此外，提升並不會變更程式碼的位置，只是感覺像是整段程式碼被移動到最上方。</p>
<h2 id="let、const-的提升"><a href="#let、const-的提升" class="headerlink" title="let、const 的提升"></a>let、const 的提升</h2><p>關於 <code>let</code>、<code>const</code> 有沒有提升行為，一開始我自己也是透過以下方法來作結論的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ReferenceError: a is not defined</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>原本看到上面的結果，是認為 <code>let</code>、<code>const</code> 沒有提升行為的，直到看到一篇文章寫了下面這段程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnA</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;<br>&#125;<br>fnA();<br><span class="hljs-comment">// ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br></code></pre></td></tr></table></figure>

<p>可以看到在函式 <code>fnA</code> 裡面，嘗試在變數 <code>a</code> 被宣告之前取值，照理來說，如果 <code>let</code> 沒有提升行為，第 3 行的變數 <code>a</code> 應該會指向到函式外層的變數 <code>a</code>，因此印出結果應該是 <code>1</code> 才對，但是最終卻得到 <code>Cannot access &#39;a&#39; before initialization</code> 的錯誤訊息，而這就證明了 <code>let</code> 是有提升行為的，只是不允許在變數宣告之前被存取。</p>
<p>而前面提到 <code>var</code> 在提升時，也就是創造階段預設會給定初始值 <code>undefined</code>，而 <code>let</code>、<code>const</code> 則不會，所以在變數實際賦值前嘗試存取就會出現上面的錯誤，而提升後到賦值之前的這一個區間，稱為「暫時性死區（TDZ）」。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">我知道你懂 hoisting，可是你了解到多深？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>hoisting</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 觀念 - var、let、const 有什麼不同</title>
    <url>/2022-09-21-javascript-var-let-const/</url>
    <content><![CDATA[<p>同樣都是用來宣告變數，為什麼還要分成三種方式？到底 let、const 解決了什麼問題？</p>
<span id="more"></span>


<p>JavaScript 變數的宣告方式有三種，分別是 <code>var</code>、<code>let</code> 以及 <code>const</code>，後兩者是 ES6 新增的語法，而這三種方式所宣告的變數也會有不同的作用。</p>
<h2 id="重複宣告"><a href="#重複宣告" class="headerlink" title="重複宣告"></a>重複宣告</h2><p>透過 <code>var</code> 宣告的變數，重複宣告的行為不會回報錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<p>雖然 JavaScript 允許上面這種行為，但是一般情況下，一個變數只會進行一次宣告。</p>
<p><code>let</code> 不可重複宣告，但是可以重新賦值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p><code>const</code> 則是不可重複宣告，也無法重新賦值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure>


<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>「作用域（Scope）」可以理解成一個變數能夠被存取/使用的範圍。ES6 之前的作用域有兩種，分別是<strong>全域作用域</strong>以及<strong>函式作用域</strong>，而 ES6 新增了<strong>區塊作用域</strong>。</p>
<h3 id="全域作用域（Global-Scope）"><a href="#全域作用域（Global-Scope）" class="headerlink" title="全域作用域（Global Scope）"></a>全域作用域（Global Scope）</h3><p>不是在 <code>function</code> 或 <code>block</code> 裡面宣告的變數，作用域就是全域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123;<br>  a += i;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上方範例中的變數 <code>a</code> 是在全域環境下被宣告的，而全域變數可以在檔案中的任何地方存取。</p>
<h3 id="函式作用域（Function-Scope）"><a href="#函式作用域（Function-Scope）" class="headerlink" title="函式作用域（Function Scope）"></a>函式作用域（Function Scope）</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>;<br>&#125;<br>fn();<br><span class="hljs-built_in">console</span>.log(a, <span class="hljs-string">&#x27;global&#x27;</span>); <span class="hljs-comment">// 1 &quot;global&quot;</span><br><span class="hljs-built_in">console</span>.log(b, <span class="hljs-string">&#x27;function&#x27;</span>); <span class="hljs-comment">// ReferenceError: b is not defined</span><br></code></pre></td></tr></table></figure>

<p>上方範例嘗試在全域環境下取得變數 <code>b</code> 值，結果會因為沒有這個變數而出現錯誤，原因在於 <code>var</code> 宣告的變數是屬於<strong>函式作用域</strong>，而變數 <code>b</code> 是在函式 <code>fn</code> 裡面被宣告的，因此就只能在這個函式裡面被使用，無法從函式外存取該變數。</p>
<p>而函式裡面可以使用函式外面的變數，如果在函式裡找不到變數，預設就會向外查找是否有相同名稱的變數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span>;<br>  <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br>fn();<br><span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure>

<p>上方範例第 5 行因為函式內不存在 <code>a</code> 變數，因此就會使用外層的全域變數 <code>a</code>，而 <code>b</code> 因為函式內已宣告，所以即使全域環境下也有同名的變數 <code>b</code>，也會優先使用函式裡面的變數，而全域變數 <code>b</code> 與函式中的區域變數 <code>b</code> 彼此是不同的兩個變數。</p>
<p>同樣都是函式作用域，那兩個不同函式的變數可以互相存取嗎？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnA</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnB</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;world&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br>fnA();<br>fnB();<br><span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure>

<p>答案是不行，函式裡面宣告的變數，存取範圍只能在當前的函式或是內層的函式。</p>
<h3 id="區塊作用域（Block-Scope）"><a href="#區塊作用域（Block-Scope）" class="headerlink" title="區塊作用域（Block Scope）"></a>區塊作用域（Block Scope）</h3><p>ES6 之前只能只能使用 <code>function</code> 來定義作用域，ES6 開始因為新增了 <code>let</code>、<code>const</code> 兩種宣告方式，使變數能夠以區塊（Block）來規範作用域，而區塊作用域指的是一對大括號 <code>&#123;&#125;</code> 裡面的範圍，常見區塊像是 <code>if</code> 判斷式、<code>for</code> 迴圈等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> c = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(a, b, c);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// ReferenceError: b is not defined</span><br><span class="hljs-comment">// ReferenceError: c is not defined</span><br></code></pre></td></tr></table></figure>

<p>以上可以看到區塊外無法存取區塊內透過 <code>let</code>、<code>const</code> 宣告的變數，因為 <code>var</code> 宣告的變數是函式作用域，所以變數 <code>a</code> 並不會被區塊限制作用域，因此作用域會是全域。</p>
<p>以 <code>if</code> 判斷式為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure>

<p>變數 <code>a</code> 因為是在 <code>if</code> 區塊中宣告的，因此無法從區塊之外存取該變數。</p>
<p>到這邊可以知道一件事，無論變數的作用域是函式還是區塊，都能夠存取外層的變數，外層則無法存取內層變數，為單向性。</p>
<h3 id="變數與物件屬性"><a href="#變數與物件屬性" class="headerlink" title="變數與物件屬性"></a>變數與物件屬性</h3><p>使用 <code>var</code>、<code>let</code>、 <code>const</code> 與不做關鍵字宣告行為有甚麼差別？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> aa = <span class="hljs-number">10</span>;<br>aaa = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>

<p>透過 <code>var</code> 宣告變數後，會在 window（全域物件）下新增一個同名<strong>屬性</strong>，<code>let</code>、<code>const</code> 則不會。</p>
<p><img src="https://i.imgur.com/NWJJi9r.png"></p>
<p>從圖中 window 物件下也可以看到 <code>var</code> 宣告的變數 <code>a</code>，但是 <code>let</code> 宣告的變數 <code>aa</code> 就沒有出現在 window 物件下，另外 window 屬於全域物件，因此也可以下方式來取得物件中屬性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.aa); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>若不使用關鍵字來宣告，結果與使用 <code>var</code> 一樣都會在 window 物件下新增一個同名屬性，而差別就在於是否能被刪除，以下嘗試使用 <code>delete</code> 刪除變數 <code>a</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>.a;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>以上面結果來看，變數 <code>a</code> 並沒有被刪除；接著使用 <code>delete</code> 刪除屬性 <code>aaa</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">aaa = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>.aaa;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.aaa); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>可以發現 <code>aaa</code> 成功被刪除了。</p>
<p>因此，使用關鍵字 <code>var</code> 宣告的變數無法被刪除，而沒有宣告行為的全域屬性，是可以被刪除的。</p>
<p>最後再補充一下 <code>var</code>、<code>let</code> 與 <code>const</code> 的使用時機：</p>
<ul>
<li>預設都以 <code>const</code> 為主</li>
<li>當變數需要重新指向時使用 <code>let</code></li>
<li>盡可能避免使用 <code>var</code></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 筆記 - 迴圈</title>
    <url>/2022-10-07-javascript-loop/</url>
    <content><![CDATA[<p>雖然 for 迴圈能做到的事情，陣列方法中的 forEach 幾乎都能做到，但基於好奇心，還是想理解一下迴圈是怎麼運作的。</p>
<span id="more"></span>

<p>迴圈（Loop）指的就是不斷重複做一件事情，當條件滿足就執行一次，一直到不符合條件就終止迴圈，常見的迴圈有 for、while，還有一個 do…while，不過這篇筆記先不提。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>  step += i;<br>  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 0, 1, 2...10</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(step); <span class="hljs-comment">// 55</span><br></code></pre></td></tr></table></figure>

<p>for 迴圈小括號中的 <code>i</code> 是一個變數，而左到右依序分別代表<strong>初始值</strong>、<strong>條件</strong>以及<strong>結束時的變動</strong>，以範例來說，<code>i</code> 從 <code>0</code> 開始，如果  <code>i &lt;= 10</code> 條件為 true，就執行大括號<code>&#123;&#125;</code>裡面的程式碼，執行結束後 <code>i</code> 就加 <code>1</code>，反覆循環直到條件為 false 時，就跳出迴圈。</p>
<p>使用 for 迴圈需要注意小括號中的變數 <code>i</code>，盡可能都使用 <code>let</code> 來宣告，如果用 <code>var</code> 宣告，則變數 <code>i</code> 的作用域就不會在 for 迴圈的大括號裡面。</p>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">10</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 0, 1, 2...10</span><br>  i ++;<br>&#125;<br><span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure>

<p>while 迴圈比較直白，可以將一個變數放入小括號中進行條件判斷，當判斷為 true 時，就執行大括號 <code>&#123;&#125;</code> 中的程式碼，而結束時的變動需加入執行的程式碼當中，如大括號中的 <code>i ++</code>。</p>
<blockquote>
<p>無論是使用 for 還是 white，終止迴圈的條件都要多加留意，以避免造成無窮迴圈，無窮迴圈意味著你的迴圈永遠不會終止，以上面 white 迴圈為例，如果不加上 <code>i ++</code>，每次判斷都會是 true。</p>
</blockquote>
<h2 id="break-與-continue"><a href="#break-與-continue" class="headerlink" title="break 與 continue"></a>break 與 continue</h2><p>雖然迴圈可以重複執行程式碼，但是有時候可能會希望迴圈在達到某個目的時，就終止迴圈而非一路執行到底，此時就可以使用 break 或是 continue，通常會搭配 if 一起使用。</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 能夠直接終止迴圈，以下面程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numList = [<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">21</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= numList.length-<span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(numList[i]);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>

<p>找出陣列中第一個能夠被 3 整除的數字，找到後終止迴圈。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 可以在執行迴圈的過程中，跳過一些指定特定的條件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numList = [<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">21</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>];<br><span class="hljs-keyword">const</span> newAry = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= numList.length-<span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;<br>    newAry.push(numList[i]);<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(newAry); <span class="hljs-comment">// [9, 21, 16]</span><br></code></pre></td></tr></table></figure>

<p>將陣列 <code>numList</code> 中符合 3 的倍數的項目篩選出來，再依序加入新陣列 <code>newAry</code> 中。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>loop</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 筆記 - 陣列方法</title>
    <url>/2022-10-08-javascript-array-methods/</url>
    <content><![CDATA[<p>forEach 很好用，但是其他陣列方法也很不賴！</p>
<span id="more"></span>


<blockquote>
<p>目錄：</p>
<ul>
<li><a href="#forEach">forEach</a></li>
<li><a href="#map">map</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#find">find</a></li>
<li><a href="#every">every</a></li>
<li><a href="#some">some</a></li>
<li><a href="#reduce">reduce</a></li>
</ul>
</blockquote>
<p>範例資料：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男生&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">22</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Ryan&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男生&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">16</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Amber&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;女生&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>



<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach 會針對陣列中的每一個元素進行操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>陣列所元素皆傳入函式執行一次，但是不會回傳任何值（<code>reutrn</code> 沒有作用），換言之，forEach 不會產生新陣列。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：依序印出人物資訊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;item.name&#125;</span> 是<span class="hljs-subst">$&#123;item.sex&#125;</span>，目前 <span class="hljs-subst">$&#123;item.age&#125;</span> 歲`</span>)<br>&#125;)<br><span class="hljs-comment">// &quot;Leo 是男生，目前 22 歲&quot;</span><br><span class="hljs-comment">// &quot;Ryan 是男生，目前 16 歲&quot;</span><br><span class="hljs-comment">// &quot;Amber 是女生，目前 20 歲&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 可以把原陣列所有元素進行轉換，並以新的資料形式在新陣列中呈現。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>會建立一個新陣列，內容為原陣列的每一個元素運算、轉換後回傳的值，若不回傳，新陣列所有元素皆為 <code>undefined</code>。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：將所有人的年齡加五歲</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mapArray = data.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.age += <span class="hljs-number">5</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(mapArray)<br><span class="hljs-comment">// [27,21,25]</span><br></code></pre></td></tr></table></figure>



<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 就如字面上的意思，可以用來篩選陣列中符合條件的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>會建立一個新陣列，內容為原陣列中所有符合條件的元素。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：篩選出年齡 18 歲以上的人</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filterArray = data.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.age &gt;= <span class="hljs-number">18</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(filterArray);<br><span class="hljs-comment">// [&#123;&quot;name&quot;: &quot;Leo&quot;, &quot;sex&quot;: &quot;男生&quot;&#125;,&#123;&quot;name&quot;: &quot;Amber&quot;, &quot;sex&quot;: &quot;女生&quot;&#125;]</span><br></code></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find 與 filter 類似，差別在於 find 只會找到陣列第一筆符合條件的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>會回傳一個元素，該元素是陣列中第一個符合條件的元素，若都不符合條件則回傳一個 <code>undefined</code>。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：找出第一個女生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> findItem = data.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.sex === <span class="hljs-string">&#x27;女生&#x27;</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(findItem)<br><span class="hljs-comment">// &#123;&quot;name&quot;: &quot;Amber&quot;, &quot;sex&quot;: &quot;女生&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>every 可以檢測陣列是否全部元素都符合條件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>會回傳一個 <code>boolean</code>，陣列中的元素必須全部符合條件，最終才會回傳 <code>true</code>，否則會回傳 <code>false</code>。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：    判斷是否全部都是男生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> result = data.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.sex === <span class="hljs-string">&#x27;男生&#x27;</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>some 與 every 概念類似，差別在於 some 用來檢測陣列是否有任何一個（或以上）元素符合條件，兩個方法從字面上也可以區別。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>最終會回傳一個 <code>boolean</code>，陣列中只要有任何一個元素符合條件，最終就回傳 <code>true</code>，否則回傳 <code>false</code>。</p>
<p>callback 函式可傳入以下參數：</p>
<ul>
<li><code>item</code> 目前元素</li>
<li><code>index</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>範例：    判斷是否有未成年的人</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> result = data.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.age &lt; <span class="hljs-number">18</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce 與其他陣列方法差異較大，可以將陣列中所有元素累計運算，最終回傳一個累計的結果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;<br>  <span class="hljs-comment">// do something...</span><br>&#125;, initialValue)<br></code></pre></td></tr></table></figure>

<p>接收一個 callback 函式與一個起始值作為參數，callback 函式可傳入以下參數：</p>
<ul>
<li><code>accumulator</code> 前一個元素</li>
<li><code>currentValue</code> 目前元素</li>
<li><code>currentIndex</code> 目前元素索引（選用）</li>
<li><code>array</code> 陣列本身（選用）</li>
</ul>
<p>第二個參數為起始值 <code>initialValue</code>（選用），若沒有給定起始值，<code>accumulator</code> 預設會是陣列第一個元素，<code>currentValue</code> 則預設是第二個；反之，如果有給定起始值，<code>accumulator</code> 就會是給定的起始值，而 <code>currentValue</code> 會是陣列第一個元素。</p>
<p>callback 函式每次呼叫時，會把 <code>accumulator</code> 與 <code>currentValue</code> 相加，再把相加的值再次回傳入 <code>accumulator</code>， 不斷反覆進行累計，換言之，<code>accumulator</code> 除了起始值之外，每次運算的值都是前一次相加累計的值。</p>
<p>範例一：不指定起始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> totalNum = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> acc + cur;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(totalNum); <span class="hljs-comment">// 15</span><br><span class="hljs-comment">// 累加過程：1+2=3 -&gt; 3+3=6 -&gt; 6+4=10 -&gt; 10+5=15</span><br></code></pre></td></tr></table></figure>

<p>範例二：指定起始值為 10</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> totalNum = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> acc + cur;<br>&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">console</span>.log(totalNum); <span class="hljs-comment">// 25</span><br><span class="hljs-comment">// 累加過程：10+1=11 -&gt; 11+2=13 -&gt; 13+3=16 -&gt; 16+4=20 -&gt; 20+5=25</span><br></code></pre></td></tr></table></figure>

<p>範例三：加總範例資料中所有人的年齡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ageTotal = data.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> acc + cur.age;<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(ageTotal); <span class="hljs-comment">// 58</span><br><span class="hljs-comment">// 累加過程：0+22=22 -&gt; 22+16=38 -&gt; 38+20=58</span><br></code></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 筆記 - 字串方法</title>
    <url>/2022-10-11-javascript-string-methods/</url>
    <content><![CDATA[<p>紀錄一下常用的字串處理方法。</p>
<span id="more"></span>

<hr>
<blockquote>
<p>目錄：</p>
<ul>
<li>取得字串字數：<a href="#length">length</a></li>
<li>字串分割：<a href="#split">split</a></li>
<li>字串連接：<a href="#concat">concat</a></li>
<li>尋找文字索引：<a href="#indexOf">indexOf</a></li>
<li>替換文字內容：<a href="#replace">replace</a></li>
<li>匹配文字：<a href="#match">match</a></li>
<li>取得兩個索引之間的所有文字：<a href="#substring">substring</a>、<a href="#slice">slice</a></li>
<li>轉換文字大小寫：<a href="#toUpperCase-toLowerCase">toUpperCase / toLowerCase</a></li>
</ul>
</blockquote>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>可以取得字串的字數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.length<br></code></pre></td></tr></table></figure>

<p>範例：取得字串字數</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> strLength = str.length;<br><span class="hljs-built_in">console</span>.log(strLength); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure>

<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>可以將字串分割，並將被分割的字串依序存入一個新陣列中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.split(separator)<br></code></pre></td></tr></table></figure>

<p>參數 <code>separator</code> 表示指定的分割字符（依據甚麼內容做分割）。</p>
<p>範例一：以半形空白做分割</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">const</span> arr = str.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;]</span><br></code></pre></td></tr></table></figure>

<p>範例二：以空字串做分割</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">const</span> arr = str.split(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;,&quot; &quot;,&quot;w&quot;,&quot;o&quot;,&quot;r&quot;,&quot;l&quot;,&quot;d&quot;]</span><br></code></pre></td></tr></table></figure>

<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>可以連接多個字串，並且不會影響原字串，如果連接的內容的型別不是字串，則會轉型為字串再連接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.concat(str2, ...strN)<br></code></pre></td></tr></table></figure>

<p>參數 <code>str2</code>、<code>...strN</code> 表示要連接的字串，會被連接在原字串後方。</p>
<p>範例一：連接字串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">let</span> concatStr = str.concat(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(concatStr); <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<p>範例二：連接非字串型別</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123&#x27;</span>;<br><span class="hljs-keyword">let</span> concatStr = str.concat(<span class="hljs-number">456</span>);<br><span class="hljs-built_in">console</span>.log(concatStr); <span class="hljs-comment">// &quot;123456&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/concat">MDN</a> 文件中提到，建議使用 +、+= 來取代 concat()。</p>
</blockquote>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>可以尋找字串中指定的字串位置，只會尋找第一個符合的字串，若找不到則回傳 <code>-1</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.indexOf(searchValue, position)<br></code></pre></td></tr></table></figure>

<p>參數 <code>searchValue</code> 表示要搜尋的字串內容，<code>position</code> 則是起點的索引（選用）。</p>
<p>範例一：尋找字串中 “e” 索引位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> strIndex = str.indexOf(<span class="hljs-string">&#x27;e&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(strIndex); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>範例二：尋找指定內容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> strIndex = str.indexOf(<span class="hljs-string">&#x27;world&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(strIndex); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>範例三：找不到指定內容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> strIndex = str.indexOf(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(strIndex); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure>

<p>範例四：從索引 3 開始尋找字串中 “e” 的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> strIndex = str.indexOf(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(strIndex); <span class="hljs-comment">// -1（起點位置為第 4 個字，因此找不到第二個字 e）</span><br></code></pre></td></tr></table></figure>

<h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>可以將字串內容替換成指定的字串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.replace(oriStr, newStr)<br></code></pre></td></tr></table></figure>

<p>參數 <code>oriStr</code> 表示需要做替換的內容，一般情況下只能取代第一個符合的字串，如果要全部替換，需要搭配正規表達式，<code>newStr</code> 則表示替換後的內容。</p>
<p>範例一：將字串中的第一個 “o” 替換為 “i”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.replace(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;helli world&quot;</span><br></code></pre></td></tr></table></figure>

<p>範例二：搭配正規表達式，將字串中所有 “o” 替換為 “i”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.replace(<span class="hljs-regexp">/o/g</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;helli wirld&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>若需要全部取代，除了使用正規表達式之外，也可以透過 replaceAll() 方法來達成。</p>
</blockquote>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>會回傳「匹配到的字串內容」，為一個陣列，若找不到匹配的字串，則回傳 <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.match(regexp)<br></code></pre></td></tr></table></figure>

<p>參數 <code>regexp</code> 表示想要匹配的字串內容，通常會搭配正規表達式，若使用 <code>g</code> 字符，回傳的陣列內容為所有匹配到的字串，反之，則只有第一個匹配到的字串，並且帶有附加屬性。</p>
<p>範例一：不使用正規表達式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.match(<span class="hljs-string">&#x27;l&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// [&#x27;l&#x27;, index: 2, input: &#x27;hello world&#x27;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>範例二：搭配正規表達式（不使用 <code>g</code> 字符）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.match(<span class="hljs-regexp">/l/</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// [&#x27;l&#x27;, index: 2, input: &#x27;hello world&#x27;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>範例三：搭配正規表達式（使用 <code>g</code> 字符）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.match(<span class="hljs-regexp">/l/g</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// [&#x27;l&#x27;, &#x27;l&#x27;, &#x27;l&#x27;]</span><br></code></pre></td></tr></table></figure>

<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>可以取得字串中，兩個索引位置之間的文字內容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.substring(indexStart, indexEnd)<br></code></pre></td></tr></table></figure>

<p>參數 <code>indexStart</code> 表示起始索引，<code>indexEnd</code> 則是結束索引，若不使用結束索引，範圍則會是起始索引到最後一個字之間，此外，起始、結束索引對調不影響結果。</p>
<p>範例一：取出索引位置 2 到 8 之間的文字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.substring(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;llo wo&quot;</span><br></code></pre></td></tr></table></figure>

<p>範例二：取得索引位置 6 到最後一個字之間的文字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.substring(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>作用與 <code>substring</code> 類似，差別在於 <code>slice</code> 參數可以傳入負數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.slice(indexStart, indexEnd)<br></code></pre></td></tr></table></figure>

<p>參數 <code>indexStart</code> 表示起始索引，若為負值，<code>indexEnd</code> 則是結束索引，若不使用結束索引，範圍則會是起始索引到最後一個字之間，若使用負值，則索引順序會從字串最後一個字往回計算。</p>
<p>範例一：取得索引位置 2 到 8 之間的文字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.substring(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;llo wo&quot;</span><br></code></pre></td></tr></table></figure>

<p>範例二：取得倒數第 5 個字，到最後一個字之間的文字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> newStr = str.slice(-<span class="hljs-number">5</span>);<br><span class="hljs-built_in">console</span>.log(newStr); <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="toUpperCase-toLowerCase"><a href="#toUpperCase-toLowerCase" class="headerlink" title="toUpperCase / toLowerCase"></a>toUpperCase / toLowerCase</h2><p>可以將字串中的字母轉換為大、小寫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">str.toUpperCase() <span class="hljs-comment">// 轉換為大寫</span><br>str.toLowerCase() <span class="hljs-comment">// 轉換為小寫</span><br></code></pre></td></tr></table></figure>

<p>範例一：轉換為大寫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> upperCaseStr = str.toUpperCase();<br><span class="hljs-built_in">console</span>.log(upperCaseStr); <span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br></code></pre></td></tr></table></figure>

<p>範例二：轉換為小寫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;HELLO WORLD&#x27;</span>;<br><span class="hljs-keyword">let</span> lowerCaseStr = str.toLowerCase();<br><span class="hljs-built_in">console</span>.log(lowerCaseStr); <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 觀念 - 傳值、傳參考</title>
    <url>/2022-10-20-javascript-by-value-by-reference/</url>
    <content><![CDATA[<p>什麼情況下是傳遞純值，什麼情況又是傳遞記憶體參考位址？</p>
<span id="more"></span>


<p>JS 支援的型別主要分為以下兩種：</p>
<ul>
<li>原始型別 / 基本型別（Primitives）：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>symbol</code>（ES6 新增），原始型別也表示這個資料是一個「純值」。</li>
<li>物件型別（Object）：非基本型別的類型都屬於物件型別（陣列、函式都屬於此型別）</li>
</ul>
<p>可透過 typeof 判斷值的型別：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;Test&#x27;</span>  <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">// &#x27;boolean&#x27;</span><br><br><span class="hljs-keyword">typeof</span> &#123;&#125;      <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> []      <span class="hljs-comment">// &#x27;object&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="原始型別的「傳值」（Call-By-Value）"><a href="#原始型別的「傳值」（Call-By-Value）" class="headerlink" title="原始型別的「傳值」（Call By Value）"></a>原始型別的「傳值」（Call By Value）</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> num2 = num;<br><br>num = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">console</span>.log(num, num2); <span class="hljs-comment">// 10 5</span><br></code></pre></td></tr></table></figure>
<p>以上面範例來說，變數 <code>num2</code> 的值是複製變數 <code>num</code> 的值而來，但是將變數 <code>num</code> 重新賦值後，變數 <code>num2</code> 的值並沒有跟著被改變。</p>
<p>原因是變數 <code>num</code> 的值屬於<strong>原始型別</strong>，JS 看到這個原始型別時，會幫變數 <code>num2</code> 建立一個新的記憶體空間，並「複製」變數 <code>num</code> 的值，最後址派給變數 <code>num2</code>，此時兩個變數彼此是獨立的，所以即使變數 <code>num</code> 的值改變了，變數 <code>num2</code> 也不會受影響，這種情況稱為「傳值」。</p>
<h2 id="物件型別的「傳參考」（Call-By-Reference）"><a href="#物件型別的「傳參考」（Call-By-Reference）" class="headerlink" title="物件型別的「傳參考」（Call By Reference）"></a>物件型別的「傳參考」（Call By Reference）</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">let</span> obj2 = obj;<br><br>obj.val = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">console</span>.log(obj.val, obj2.val); <span class="hljs-comment">// 10 10</span><br></code></pre></td></tr></table></figure>
<p>從上述範例可以發現，同樣的行為下，如果換成物件型別，兩個變數的值都會一起被修改。</p>
<p>這是因為 JS 的物件，是透過「記憶體的參考位址」來傳遞資料的，示意圖如下：</p>
<p><img src="https://i.imgur.com/JcXKYmw.png" alt="指向圖"></p>
<p>當物件 <code>&#123; val: 5 &#125;</code> 指派給變數 <code>obj</code> 時，JS 會在記憶體某處建立這個物件，然後再將變數 <code>obj</code> 指向存放這個物件的記憶體位址，換句話說，實際上傳入變數 <code>obj</code> 裡面的值，是這個記憶體位址。</p>
<p>此時將變數 <code>obj</code> 指派給變數 <code>obj2</code> 時，變數 <code>obj2</code> 所傳入的值，也同樣是這個存放物件 <code>&#123; val: 5 &#125;</code> 的記憶體位址，而因為兩個變數都是指向同一個記憶體位址中的物件，所以當變數 <code>obj</code> 重新賦值的同時，變數 <code>obj2</code> 的值也會被修改，這種不同變數之間指向同一個記憶體位址的情況，稱為「傳參考」，或是「傳址」。</p>
<h2 id="例外情況-Call-By-Sharing"><a href="#例外情況-Call-By-Sharing" class="headerlink" title="例外情況 / Call By Sharing"></a>例外情況 / Call By Sharing</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">par</span>) </span>&#123;<br>  par.prop = <span class="hljs-number">500</span>; <span class="hljs-comment">// 修改屬性</span><br>  <span class="hljs-keyword">return</span> par;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj2 = fn(obj);<br><br><span class="hljs-built_in">console</span>.log(obj, obj2); <span class="hljs-comment">// &#123; &#x27;prop&#x27;: 500 &#125; &#123; &#x27;prop&#x27;: 500 &#125;</span><br><span class="hljs-built_in">console</span>.log(obj === obj2); <span class="hljs-comment">// true（因為傳參考的關係，因此比較的是記憶體位址，並非存放於記憶體位址中的值）</span><br></code></pre></td></tr></table></figure>
<p>因為作為參數傳入函式的 obj 為物件型別，所以根據傳參考的特性，再函式內修改了屬性內容，會連帶影響到函式外的物件。</p>
<p>但是有一個例外，就是當傳入函式中的物件不是修改屬性內容，而是直接將物件重新賦值時，函式外的物件就不會被影響，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">par</span>) </span>&#123;<br>  par = &#123; <span class="hljs-comment">// 重新賦值</span><br>    <span class="hljs-attr">prop2</span>: <span class="hljs-number">500</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> par;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj2 = fn(obj);<br><br><span class="hljs-built_in">console</span>.log(obj, obj2); <span class="hljs-comment">// &#123; &#x27;prop&#x27;: 5 &#125; &#123; &#x27;prop2&#x27;: 500 &#125;</span><br><span class="hljs-built_in">console</span>.log(obj === obj2); <span class="hljs-comment">// false（重新指向後，兩個變數不再有參考關係）</span><br></code></pre></td></tr></table></figure>
<p>函式外的變數 <code>obj</code> 作為參數傳入函式，接著在函式內進行重新賦值的行為，這代表函式內的 <code>par</code> 會重新指向一個新物件，而不是指向與函式外的 <code>obj</code> 相同的記憶體位址，示意圖如下：</p>
<p><img src="https://i.imgur.com/pZvGtHV.png"></p>
<p>以上情況非傳值（Call By Value）、也不屬於傳參考（Call By Reference），因此就衍生出了 Call By Sharing 的說法。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><ul>
<li>原始型別指派給變數時，傳遞的是值的複製。</li>
<li>物件型別指派給變數時，傳遞的是記憶體的參考位址。</li>
<li>傳入函式內的物件，如果重新賦值，此時函式內、外物件之間的參考就會消失。</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></p>
<p><a href="https://ithelp.ithome.com.tw/articles/10221506">JS 原力覺醒 Day12- 傳值呼叫、傳址呼叫</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>call by reference</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 筆記 - AJAX</title>
    <url>/2022-10-24-javascript-ajax-note/</url>
    <content><![CDATA[<p>關於 AJAX 的四種做法。</p>
<span id="more"></span>

<h2 id="AJAX-簡述"><a href="#AJAX-簡述" class="headerlink" title="AJAX 簡述"></a>AJAX 簡述</h2><p>AJAX 是「Asynchronous JavaScript and XML」的縮寫，以名稱來看就是是非同步的 JavaScript 與 XML，可以讓 Web 前端與後端伺服器進行資料的交換，以及不需要重新載入網頁就能更新頁面內容。</p>
<p>過去 AJAX 發出請求會透過 XMLHttpRequest 物件來實作，但是以目前來說，因為有了更適合的方式，因此實務上幾乎不會使用 XMLHttpRequest，不過既然都決定寫筆記了，還是多花一點時間理解所有方法吧！(๑•̀ㅂ•́)و✧</p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>起手式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br></code></pre></td></tr></table></figure>

<p>此時可以使用 <code>readyState</code> 屬性的回傳值來確認狀態。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(xhr.readyState); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>
<p>以下是不同回傳結果分別所代表的狀態意思：</p>
<ul>
<li><code>0</code>（<code>UNSENT</code>）：成功建立一個 XMLHttpRequest 物件，但尚未使用 <code>open()</code> 連接伺服器。</li>
<li><code>1</code>（<code>OPENED</code>）：已經使用 <code>open()</code> 連接伺服器，但尚未使用 <code>send()</code> 發送請求。</li>
<li><code>2</code>（<code>HEADERS_RECEIVED</code>）：已使用 <code>send()</code> 發送請求，且可以取得 header 與狀態。</li>
<li><code>3</code>（<code>LOADING</code>）：資料載入中。</li>
<li><code>4</code>（<code>DONE</code>）：資料載入完成，成功接收所有數據。</li>
</ul>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">xhrReq.open(method, url, isAsync);<br></code></pre></td></tr></table></figure>
<p>連接伺服器，參數依序分別為請求方法（<code>get</code>、<code>post</code> 等）、資料網址以及是否要非同步執行（預設為 <code>true</code>）。</p>
<h3 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">xhrReq.setRequestHeader(header, value);<br></code></pre></td></tr></table></figure>
<p>設定請求表頭，參數依序分別為表頭名稱與表頭值，以 <code>post</code> 請求來說，會用來設定發送主體的資料類型（Content-Type）。</p>
<p>另外，此方法一般會在發送 <code>post</code> 請求時呼叫（<code>get</code> 請求沒有發送主體因此不使用），程式碼位置會在 <code>open()</code> 之後以及 <code>sned()</code> 之前。</p>
<blockquote>
<p>相關內容可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/setRequestHeader">MDN - XMLHttpRequest.setRequestHeader()</a></p>
</blockquote>
<blockquote>
<p>禁止設定的表頭欄位，請參閱 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">MDN - Forbidden header name</a></p>
</blockquote>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">xhrReq.send(body);<br></code></pre></td></tr></table></figure>
<p>發送請求，<code>send()</code> 的應用會根據請求方法的不同而有所差異，若只是單純的 <code>get</code> 請求，參數只需傳入 <code>null</code> 即可，其他請求方法如 <code>post</code> 則需補上相關資訊。</p>
<p>需要注意的是，發送出去的資料如果是 JSON 格式，則需要先轉型為字串，轉換型別的方法可以使用 <code>JSON.stringify()</code>；同理，接收到的資料如果是 JSON 格式，也可以透過 <code>JSON.parse()</code> 轉換為 JSON 物件。</p>
<blockquote>
<p>相關資訊請參閱 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send">MDN - XMLHttpRequest.send()</a></p>
</blockquote>
<h3 id="非同步執行"><a href="#非同步執行" class="headerlink" title="非同步執行"></a>非同步執行</h3><p>雖然可以選擇要以同步或是非同步方式來發出請求，但是為了避免網頁阻塞，一般都會透過非同步方式來執行，而非同步就會衍生出資料尚未載入完畢，程式碼就繼續往下執行的狀況，此時可以透過事件監聽來解決非同步問題。</p>
<p>針對 <code>load</code> 事件進行監聽：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">xhr.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, getData);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(xhr.responseText, <span class="hljs-keyword">typeof</span> xhr.responseText); <span class="hljs-comment">// &quot;[&#123;&quot;name&quot;:&quot;王小名&quot;&#125;]&quot; string</span><br>    <br>  <span class="hljs-comment">// 開始操作資料...</span><br>  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText); <span class="hljs-comment">// 將資料結構轉為物件或陣列</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>針對 <code>xhr</code> 物件進行 <code>load</code> 監聽，此時就能確保資料完全載入後，才執行指定操作，此外，可以發現資料的型別為字串，因此可以視情況將資料轉為物件或陣列使用。</p>
<blockquote>
<p>字串轉為物件型別可參考 <a href="https://https//developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN JSON.parse()</a></p>
</blockquote>
<h3 id="HTTP-狀態碼"><a href="#HTTP-狀態碼" class="headerlink" title="HTTP 狀態碼"></a>HTTP 狀態碼</h3><p>資料全部載入後，可以透過 <code>status</code> 屬性查看狀態碼。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(xhr.status); <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure>
<p>以下列出常見的狀態碼，以及代表意思：</p>
<ul>
<li>200（請求成功）</li>
<li>404（用戶端錯誤）</li>
<li>500（伺服器端錯誤）</li>
</ul>
<blockquote>
<p>更多相關資訊可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status">MDN - HTTP 狀態碼</a></p>
</blockquote>
<h3 id="實作練習"><a href="#實作練習" class="headerlink" title="實作練習"></a>實作練習</h3><p>使用<a href="https://hexschool.github.io/ajaxHomework/data.json">六角學院練習 API</a> 實作 <code>get</code> 請求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs htmlembedded">&lt;p class=&quot;txt&quot;&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;https://hexschool.github.io/ajaxHomework/data.json&#x27;</span>; <span class="hljs-comment">// 資料網址</span><br><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); <span class="hljs-comment">// 建立 XMLHttpRequest 物件</span><br>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 連接伺服器</span><br>xhr.send(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 發送請求</span><br><br>xhr.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, getData); <span class="hljs-comment">// load 事件監聽</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(xhr.status == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求成功&#x27;</span>);<br>    <br>    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText);<br>  <br>    <span class="hljs-keyword">const</span> txt = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.txt&#x27;</span>);<br>    txt.textContent = data[<span class="hljs-number">0</span>].name;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求資料有誤&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>使用<a href="https://hexschool-tutorial.herokuapp.com/api/signup">六角學院練習 API</a> 實作 <code>post</code> 請求（註冊功能）：</p>
<p>資料類型：<code>application/x-www-form-urlencoded</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;</span>; <span class="hljs-comment">// 資料網址</span><br><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); <span class="hljs-comment">// 建立 XMLHttpRequest 物件</span><br>xhr.open(<span class="hljs-string">&#x27;post&#x27;</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 連接伺服器</span><br>xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>); <span class="hljs-comment">// 設定請求表頭</span><br>xhr.send(<span class="hljs-string">&#x27;email=test123@gmail.com&amp;password=12345678&#x27;</span>); <span class="hljs-comment">// 發送請求</span><br><br>xhr.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> responseMessage = <span class="hljs-built_in">JSON</span>.parse(xhr.response).message;<br><br>  <span class="hljs-keyword">if</span>(xhr.status == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求成功&#x27;</span>);<br>    alert(responseMessage);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求資料有誤&#x27;</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>資料類型：<code>application/json</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://hexschool-tutorial.herokuapp.com/api/signup&quot;</span>; <span class="hljs-comment">// 資料網址</span><br><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); <span class="hljs-comment">// 建立 XMLHttpRequest 物件</span><br>xhr.open(<span class="hljs-string">&quot;post&quot;</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 連接伺服器</span><br>xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>); <span class="hljs-comment">// 設定請求表頭</span><br><br><span class="hljs-keyword">const</span> data = &#123;<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;test123@gmail.com&quot;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;12345678&quot;</span><br>&#125;;<br><br>xhr.send(<span class="hljs-built_in">JSON</span>.stringify(data)); <span class="hljs-comment">// 發送請求</span><br><br>xhr.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> responseMessage = <span class="hljs-built_in">JSON</span>.parse(xhr.response).message;<br><br>  <span class="hljs-keyword">if</span>(xhr.status == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求成功&#x27;</span>);<br>    alert(responseMessage);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請求資料有誤&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="jQuery-AJAX"><a href="#jQuery-AJAX" class="headerlink" title="jQuery AJAX"></a>jQuery AJAX</h2><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 學習筆記</title>
    <url>/2022-01-20-git-note/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="請輸入正確密碼。" data-whm="該文章無法校驗。">
  <script id="hbeData" type="hbeData" data-hmacdigest="0b4ccda3a4d6b2834320d421ab3aac8df37f766c90dae6fbe31a336f46e13e41">1e426c865627bf534a6d7e02acdc3a5be65571b92757d6c23e1dffa1c74d6d18102647b8f525474a229701e0f2c7c4142581c340071b644915527dcdcadffd0d01401969df3aaf0ea724714211fca6f98cbf41957b1fd5e96c823e7f5f33eb4eb6d78013723539913dc872700034ef95a6412ab3381f32b9230122e68dbdf04087bbd1fd1874f435bfda659bee67d5b72c64de0eb3337515f0cfae96669cc24fe3383e55dd7042049f47da7686be4b61e9d4d3657a7fe42cc7b435c90c76d5f05a33bf3dae5b7b4005df648a2b38ff7a634183a3d3541aed79e913db90875958f81b48f02f75fc895546e218921468b4dd982b353fc6a237362ab133a6091304f390b0377e46a5cfc15b69d95670a5410a61d6066579ed28a96143e5663593f5f03f08e2f6c5c624e7844b6b2fa44bb086f8e08db09fc28f7a90160c861338a7caa16079fa4a4bdef9edab3729bf1c25eff1b060eca258f4face7c2d398f6639aea989465f806d70a1c1e2d446923587e1f57835bf7d9839c547a2cb2cd9660236323a1514a879ea95d2894bfc841babedbf0334da69d8aec04b86df50117eb3fb7db0fd5c2d14f1da213d9b608e36bc1cb18c6b0be7ceabacdf5b13cb08747b0654811357488a5e7ff8e518fabfafc0d4fa9c9d8dad007189827e6c157378d987ae3d557581c1f8ea4040e4d25e63c53af0ebf6bcb2a15f34cf2673178d64de8be8e1ccc2a74eec310c8c29985e163d3a4b70075aec9e57f3087707317448342b19564c90305a1ccd968bc5d3bca2a15842c6feb1b3970f6c7bf9cef4e83eb63f089aff32924555770d2a0e0773e7e544299bb5f34be584b9d0dd3c3e5f326ff5f9c493a4c3095ca2934620d1539edcd79d0f41e5c8033674167c554eeba7ada55bba8be489fef988a8ecd25761cf521dcb1b81d522cd8221e2457506b4b2bcf1811e553c309b7e4491eca83e7de66f772c1ee4ba6f49cd6edcb13b8c8986c1ad7f91f2c44e3ba6aef57ff61805f32ec92cad35c776b819116d6574ff06ecdf334c43efd5c5969267f48e09b5e9d8d90977ae25a69a0807bdb886a8a952b1bbd8092731f2fbbeb25c8cda4546adc8c288b3e22a71f671a079b0ce114aa64c009cf412e22b3b985ba4758cb598eccc33d8d82ec19f81d3fd3399c398c377211b11dad7b30a8e57c21e312e9c106c57679de90ab3a72de7a1d6903292a728c44b9a5a09a0591f7e034e028d60beca7171de23981e916025790395ba2c1c6610f20c6ab5588ae4bf46f5c92028c2e8baaea2a75d84e81bcafbfd3029d033fb71d4455b55d3aea9eb22b743959a0326c6de329f8914df0f38fa111f8d04036dd30286758cafbbe5264270e23c1e5c0a51789754bc4eb2cccc2e231dcbc8572d80f63125b0534ed72e984db6cfa09802dc4d28f2370e1113d72e01709fd0d1385e55df6c5c77c7aeb3a2d18c2a708a1638c283c82561eac0f416a7344f1b07f2ef0318607e31c14e60e367117689722b97646e1e13e340a5f0c56648496907a99bb7f55def4490bd7eb5e7eeb6781cc6dfc3d80472e3b20b47221ccef9d056cc18925e7f7b741633941a120f8feba920870ee45d53bf9b70e8fd998d4c36869b3c4f68509431f4aefc36e6826082adeadc65e6c02acb820cc3e0bc6fc841452dfcc9be4e87727628e5697e33938fb33f55d92185ce4c822212cab7720c2985a94fb0ea1633be3cfa69facedfe84de7e77dec55369e8e6033de2cf16cffb5233bf3a4976b9083bea843bd1ba9a6b182f78569efce7e85399fa22410fa7dc4820caad5dbe8534c74b4f8e2a0a3450d61cb5110e8eb72ffd05564ff4502154e7856c63182524fa655c20435ebbdbaffaefcce7be1942ffe49d87188d788ce7d3fd1904e239c71a63c8569a83bd6ab47d9c935fd5d06c7362e349fdcda16414aa89f5f19f15f1b71ca07c0bead052b97e3113ceed80c51804f4e457ed7cfd211548921785dc8ec79f543f03f1ba6acfd693bb67d93bb9a547ae135e3ee017d212ecf473efbdb0fe75f9d07802c898cd9bc082c4ec8c5c75000815af7db9f328b49e3da1ca1d543f1799c1787c6b3fabdd159bf2048ff70bd9f0cf37622248bb11c4cb0a0dc2cdfd0051e4a368580bc80ccba9d940600cd16e713e8695ad10c2f031260249c623787e0c107cc8bf152735b3594185abc4102ea1221b1cf3b3485ff09f672ab7d6488e770b87c0536ef9b120aca313148416d520ae3df341eae340058091f932020770e58f7ff5e75aeb9ad3005c55aca7fbdbf348f0f5352d8375069c7186b3f1729af968f0fa4835398c7a4c5caebca85faa3f0e41c03c83e860f9b9dcdadccc69323fef9bd0c4387457a9e150762a941efc176e07f3bfc3469e9534cfb15b5cef35bde2da8363b306cc13ded4aab1e58f066c21b174097466b47305e28debd3ab9135fa0d28c0f3d6dc770a38fbb88e2e431ba8e9660e6d7cdc8804cb703dff9831fafc5be6622a1b529bcbc686919ec57b26baf16d646176c57ff90f8c866c71b2094ccf80457945bd6823a5f510b78ae4ea252b539b9b0a4d8f607b8acd55c4e63789de36a1b2160133814ff5994c2296fa869acb661466f2e7ae812fda78a001d24baea322424c480402e08c417c61444f876aa813887ce0722ad8b7b7a4adab2ed12439da4750097a854cc81e3f508c4e37cebe3a9c5d0dcc43ca85051a96f30f34de0481b400d5e2a13494cee3dad008e378409b7d7154fc16b64bfb12a87ccdaa13e13181b00a3795ba36ebc610ca2f970162a398f4ce987710ba16c361cb3f238b9b5b267249b5f2af2035a300da1d860f294fc50cfaf3718c9da73bd0b4c6c4150c4ed6b808a1be39ef65d4f235cda8229d69ee74043d12b9ec46a132a3b872fb4528cd7902e0dbda1c962d6a89423c3f6b6db250609280d7816ae1aec019b25e3f8149edba6f4f8c8b1a70fce94a3acaab1e7bc162cbe56127893fb19dbc6a5079ca44e06554714584e951052296a08eafcb51071f2d29aa2e16f83766c741a867e0417a58cddb943a3d4efc25cca9678f513d0487bf8417a584de874a560a373937228db1d8c45b6885f809684b4418f76e412866f2a2f4b3cda68c5709dca92fac35cb44579d0e730fb06be0c5e969680c977bd6395aa8f6e10bdad3223c78526500f04321c7ab94091737ce0f96703556f976367e45586c887b322b57a9a1ec6daabfa89d1e884fd78a8ffaecf45c17161255dba4dc808e07532c8931acc92a240ef17feecc9759cbe90c7d808451244862b3f73c0fe3c9a130696576c68172e68384025eda00322bf831bd0764178e76e60e67d05dccdf4299e149f072267c253132c073af412f026ec8479f2f4301dff09d4804bb9ab98b82c3eaa6fc4ade30786cb586a44f688e77ad7975b685ef0c7d8c324db1720aaf87e1aebd20f5daa10a280f753e0ff4e28383f1afd416cd202617a9e80dd9cf2233e4eb155c953280fe459f02ecddecd63176bfda68cb5bbdcb75b7bd2ac3c8f3e2e3fa006c887d0e0bca5ac2031d46512005d8f989868bc5ea62e521ca48f87f2f418c380d666f5a86f5d391ebcbcc43b8cc421d453a539ea3bee30d5a3ebc65f7b3db430f3654fdb36ed6825eb5c23a88b1fce9e586499038e9c690f215e3e896950bc65d50b1738e8066ca297d392667df1a8c19a7b49f1280b247694fb1d82d51295b8961fff76d6e93515aa552fc0aef7739a1b0f05610407db4d1106c5ccf500e83efb932225f69fe2cef3deb23a391581133c3afef521dfebdc7be6a2085984ebfffd96673711b3908c1478b6644797fc71e6bba8fff2c344bd1b7341ea55b682d5706ed7c1962c30c62957cd1b9f574ef34860ea9f3b2881d164f68085deb359814828ffca308651c09163fb5d4e155eb9ef533ff72b5507c9fc3bf7ef7528653079997704dbea9f6641e05fa2b050b2d25dd0ca98dd82b00fbd77828d1d32a235ceed124f733eedc7e57d52677b7a3397bc3bea603623f869ba0386e7f49a57c3f65044cc4c1070d805010b04bf8d34b8722360f1b4e9efb28fe174449394c027b0ec8aaaaf9071b2f1e2e5cab8ce1b7e59329b440a4a5b6087183e937ed1e78808701b249ca55610f6835233b094631756d7dc31854f3a2ba2866274233a34f934afdb623d46a0155adda30671072b9d7c542238ea956a10cc7f8fc07285976d8d7509e8be7032afc4d0ae0fe679daf5da44d317a65d06b070da9fc9889c49fcaf59b6b91a535cdf2b4056866c739f0dc722f3998a165ccffde057e29a417df4d450a22c49a8817157c58931159941e02d5da2aeda6ea3728b2aba1d7d0cf6950ec6b0832f034044033aca201ed0920a7ecfb8796455ac7055f2d171950b1c32aa3ac36394034868b49083186da110109a78c93f45e3a3901a2f055f117e9c79fc3864f02a500a24e5e19213987e6ef66a627d02e955faf0097576d43d121c559c0e41b8d48a48ab300200ebdd4681e99b23e4fef25dc79a87622c21c46ede6aa53301f7c326248569736c51b3b3dd162a4d54091a0e71f410ad680c0cb26bcd87726a6b28385bdfe8d70c51afbcf568417c82e288b847d3102661a10e22815ec1c5770054f6998dabf11f39fa07a2e39ff5bffeaa1e94f81a1c9d69bfeaa18834d7ca3d21ddcc3a2c915f878c8ad27b320f48c61fa4370f78e7f490a167b29ec89b766e75e3d1f24df42cbd3634d5480eb3d2416659a66cf9e75ca4b57fef13343181483e426c9df9dd85026bd36e2109a15640ff5dabe9bac61568d115925f8493f3be7cfb7d08342a945119f8c14eae100bc02714f894381560bf99b4e9ad8bfea170af2bd9904859d80f95424ec8973f221fbddc106e6f29e22fe5f78619f5afc377cc6784966231103cda4f4c8a7761c32ec2e78110b3615f69f8f09eae0e0c6edcb4838dd9667e7e08e0ff73dc3bd633fa0e0cb25dfde1dcbfcf27ebd8afc441c20754c8b412000e378d961cb255ab70929cb7b0e0bd09d3654b2cb4be7e2279566be87f9419842192ac168acc636fd9e9eac6fa608ed45c3a64e7260cbf50189badf7452e659544e6882a86d9151a3a6528eb93d2c1c31ec52a84b564d8f14cb27ee8b2789c792e42a79552a187776af8312c186873b7c0f0b78aecc9993e6cc66b7c3a65577143e6303adda1dbe8f819294360dd46eec372d24a1b4db4e022714dda71da3dc6d2daf84e8dc9f4b79a04d10635f3b29dc241e22bc35c6a2eff56618a78fdfb42ec359b3a12fb998a698ce46f4369ca44bb2e4b524fcf657d3acabbcc2e526212a974106bdae1707ebf72cc01bb3422535bc8dd1228063c7c78c40df803d4e03345db4110ee4d28453ef6f2cdf18947c2d0c2afc1058720ccae2fcd857869f5530eb6530258f2525885903e6de41608cf782f24f6cc67cc7770656ba2ac5781995fd35d2e631801595154a4cccd5769bc844e469c8813da27f96923ea53da890368ca3c382b75a29151d30232c2426bf704154d9188fa2a8c244ba53b6a6d1577089d7e761c1dd4d76510e68c73d13e67e6090540d2cb30c489ee2ec548fa528a80d8e1462a138f9e8c7788cb6dce3c227db87bdb136008d6ba4ca3e21f2c9284ccde9539e193442858021ebdbb6087fa70f3ee053808ca4fb408faf65820961bcff37027457e444ebee1842f707fd5a3be2daf6d21925e8c43bc84438ad19a1bbe16f4352ee1af23b5190be764f7ce00bb3d1d8c09d71206368d72d7cba3c8027ceecdfff1e9a3c1d486eae69197c9b1c3b00ea7196a662abb595bc5ca48f13a9d4b117c5243836cf7cc62ef6063f14399964dd65aaeb3e7ca90d5744bf5020034065d5ff4e4a8c0f9b8853fd864fc6f1f6fb67b6be7ae03227c5937a01be5ffe1b0ed223abe856977423758c162d96419070e9220f06e962e689676341af9f642306c385b31d081148f7c8aa194b1f3136aee6dd9a569e689c3773cc5930051d248dfbbd79dedb38e681fe19223db6ee2ad337f3e62772ef3ff634e462f771a10a68218250d7175b3cc6a428e5bb013150471d445bd5eb3836a4a90c4166ae1be937c0d706ca7637dc14f407b956c3a8054aa99313adb6c84647f68f06d02e08a60953e47af8e700dfdf670649d7e6d8dc036d532f9913da738c735b50579aec7a6840e57428833fc40c90971ee351ca65c32d93325b064cbf43d202841a58846b97219f871f503f996c1fdf184eca898a34c1530e8a708f9ec06b05865aab23ee6d1581fb1b2ef9550c84f96f1ee3ccbdfe0e337eb5da6ebfce0fb7bb1f2e68cd3708431a6393ff032b841b53e76e623cd2d4ce87222ad07e9f768a706009c911dfc7f33f2af13ff77dbab62ea2ec103f3f079c14354478bca57193e6a272a4191169f91a9e8dfd760f535ef737017822623a034cf596b05c931dc86e15357e6644c7bfe75e59243670c898c7bea15329faf9d717702ffc97115626626f9c30032d39733ebab2a20d66eeb5c4d401e152b20fb7570cc6ba434dafc7430eb6679f3a5fab37dcd38fe5b3153a1f90548912c7da4246b93cbb843da80861ac8348ef5a0d7f567e53a67b5883f1f3c080ebbab02d758c818619961bac04164586eb55860362e339fd01eeafc7311975d47845601f803be501a3313f73c7b51260c07cb564eb272804b7cd3d44a73b4cf608b6facb41f0126f1f921189335e161cdc7299cec483d21632d08b834267235815b4a6452e6828dc9e3d40c0021a1841c215d38ecbfcdd19e223ac42b0cd4898011d70d392863906d9df4fcef24f701d71eea20e10d14fdf0c5e5dcb36aa2a7e6c85cc945df8f94f302c18c1a6ce97155f9f26e0b216e4d91cf7996e8f359c3fa0f367646155a40239c4186f87d6c5983ebd3f347510e99ebfac721fb4b2049d2637a7ec9fecf33c32cd836eb014f5a9aff238b7b1c61abd3f186ae0bb882beb481a8df2749550c371e70971453568f64711a1c4f090792e221ebb09723a37c078511d416eeeede473d54b05008687d29fc17545e9867248d2b1ed5398d7c7962d0bfbd80bd771d9ea1b7ca5015f75f6c3604235ad35fa574da78e50574ae693ea9f2eacb4e6fe4ee2e3f678f4a1a5f2a13e718daadcc978bb055cfbce23d4627133424c912ce14eec3cfc1b606adf39565c72c725b566b788bc379cf0a51ddd5191dd651cdee69e3484c6d1518e988e0a7ea8719e95e3c44338fafd008a9f804113f7e241bddac2d4372da376f64aac2d92c8907ef316b3dc39b2abfb3390330972e9e9f7be9c8e4582c916fd3c5520dc56619776f8bff17c32c8502c38b5f2c1c904cbfc02b8a92528269831d58bf8c2a67690533359be33f06fa01005dcb52db418923f021e35f74efa68b0d9a730c9bc0a85f65bcfcb31d5f330e2ed5e8817f02998e3fe2811318353f5752f875c51793092eadd64c9f7a15a526aa453474b0bf905b73ac553f4494309816c9b194470372d9956a4e6600083f2cc62571a396473f3b2afaa00d3e2539b1bdd57771ecc7e85392a39b93aff549425d87ef928da1afed948944a076841155cedfcdc86042dac0b4d18dd173cefb877ef9ca13dc056dbf0411f6a5ccd707432257e4b352370f5209f06a75799e01fa555b58450ac1f55522e63214e497d03026e8a74d452500ff76e186a2978963d90ba5369f90b09f33d7bda42e6c246c402c167dfb233739564863f0f654a46ef44a21e7ac0a53328dbe94ce4a2829b1b87f6fa8592ff141f53298474a09780151316c0a780ddb4c6fb133ad00747336d11a1bb071d985b131080d438be6f293ed8fa70dc02c3e792365464e95256017a27b4e5d29ed41f83ac7f808da94ee1a21a9a90268909750ff5398fd9647afd7bc33c18201fdf451a854a9b2c39b623d1271a498d43bd6a9aae5189f37221b8ca509dadffb12a4b3530674f029a276f33e57cad9ad0c85d7b2b621a7b5b06fc688aa2c8f23768ce090c33c6d5d6d44512c7746a8ed316729b3406cc5c354b15ced6ba2656cea590e997f42fe98deb50f675b2704cdf682ea53c7444ea5028968a7118a0fc6ddf497a7bd72cad5f015b2e332c13ea6b66f07b137f04a4b947f5ef7d06a3609c1f8aac94ddfc7319eb43dd5aaded73ab32c150ddeb0fc6ce8e30316fa57d50415c3ccf76125027c97780c3183b1ba67e9653294241ecb5caddfa73da22db81b671990960716a5c9026d9eae24cd63e63fd7791a833a0832725064647b48ca77080c189b7eb79feb4a2e683c6775bc845c8ea4ed1f4a08bd5642b541276a2b9b201f6f2198e25dd6b9d6d8dd525ed5dc514533ff6ee8f32ba6431596dc910feffc5d1d2806250b7682a627651abb464c0dd725b31656cb4fe1a8a98f094583edbd4dfc18619ac95a488ebe4b31744edc156a0fd2ffccc83594f544dee0437f7bcb68f8a1d31b798d38cc8aa653e0e8dc7357e3eb8e3ec4de27569803c2685408738e6f923f7f2e2fad1698dedb42829da3c818714c8b3deb9f299eef3293b558927b3bbef343c2e3618d2c93cd7b5c14d8fa41940965d0dd85ad9f4066cfa303624872f0c6367c0357192650b4ab034741a4daf3db13896dbfaf2d186c43cfaa52f3146d3890ceff89d71cf8909d400d7876061f7a2fb8aa2c6a67fd6185b761b0d7585a0036ac88883b32c985b6ea3dc8d049ebd2f43d084e47443be467c7b8bc6510f11beda13774588df7f2ca316592f3641f5b8918641d7b6d41329f16025cf530d79df40ac98ac0cbb57eca6e8cba6ed9b66560da35a8d3e8a80ae8ab5aad4cd061028ca2241e5d562f49ce4ae86ad297cc0f459d7d1ac4718d71be6bfa380d296c1eff768994f4a97139a714cdc53ec61a0dde1a4138e3aefcafd995aa0d985c48218be5b7f34cc2bf5596d595b54da415d14acfece628d3aea53ac63519f7f446f6dcdad8cc0a444b2e8b068b8eb19524733220c97140ec8826a66e521270d62ac801ac87ac3d8c326d3b4b028098952d872a223bdd3b69e2686605d3793a47f076a4dd62daa3a6a11e5f7586261865a785d25ab01952049c2349525a93122c3be36bbef0ee661d084784337caff4489f611b5f62f69bc42b1814e234a0a2cbe4dcb2f0e5a7d86fbfb50fa7e8922b68bb3783102666f10f962164e8c1b2e56c5b023ea3649dde88e8d93000e4e653d79002f274b9aef76feca13aef62b54a38ea92ba2fc602512254609668fbc048fa6f6f43d121c99e55b4c19288d62fd27359cb785830f5614dd3da806c0d2237bebf3927fb4926e7d4cc91434d218445021e39154d4ee3488345a7c3c79ed4d985b1611fa59fa44478e77ec844dc248f78791c7d1dcd43b94daf0029832d38e8bf8270c4460dc89fce0021986504ff4411f8644d491cad10b45c48f5ef31830e03c522c33f84c2b945fe1262915bfb597e090e479cda11fa786679394be634fbb96073ca7fb2c24d638c5f5a2a7e5d08dbbcb1d2fbb4295965b4e84376ba0bd559c868ebbefad1acee1eaba5a2feb8f512d5931046d53aad64cbd8425fbf6274f41cdd043a5a5cff2f9a51130ff4f574a651e0bd45ebc826731acda7123ce8c1559bbbda8f376021d5b19b9e8d998051e6906d1226c7c75685cfdf53fbb616f52aaf057010d40f1102d4d439abd36456bb3a7fdb07bd114a3ac4dc587ac11effc22c2ef6f6a75b2ea1b6c171382a7490614aa423a440400c74d91833f1983c686f14cb48bc3c61db3bc16409fc8d2563d53111f0d9e6e21dbe28f7e158b6ab5a2fdf7cd877c79c408fc6ee15cf175bc6088559927c0fb75a1e08f7b75d69c20631bd1fad81f7840735fcdad71bdf98f52cb872d8d3f0fca4deed603fe2c474a6fce172bcad569c71b0c5ed6643932a2f1c63f776a89cca466f722b95a60584b855148ec6ee8d9a4588b94e15555da5669c928ce55a8b04e1d37dadc5f92851cd16c473362efa9f29b19e9e90cca0d8de8c9079d2b3e979fb089f26b86809554492f2b9395343e76da8aad3c62c584913ab15c22f0cbf23064dfcfb4e60dbcaebb3dd40c44d77d883f58ecab45385625d88f9ff195c235cd41328332ec283a8d871b47977d5187a9e84c82eaced27161191598ba79ad98f1704cffd1684eca1a55b772a47b80f0748f2a91921def2dd28fe12b34f42bbb4764361a2f3eb01507922ee9a8f71618a05eea523baee8d3f7dc07e9f8ceb6970d82d10d6d7b49ad42b6e45030f9d51a8b23f868bdb68e6e89c8c2c11252ca22737fab70d818527dc751274be3c02d2db4e3b1dbcb521caa7b1d12b51f5b5ffb333f12bed56e72c6867855edfd3d7758427510b20e2dac4f302397587eceb906cc8a8d11d4b4a6b4a21c603d942ae7d93165f06c1bf023f3cfe11f72d757483a9d8abdad1e202a133675a9f6b913a053047cf266e0fa094017f7f2b6f792812d10a47031fc40c7aee67f6cdc04657d5acd00891fc18bca26db99166f136f296b91d7df70f3bbb1c0f56627ef0cc387dd77b7c84a8b26817215b8d6c03c1488f4f5cd90d496a9b69ec3058b10c3021d55f8d47e7c7ecc9ed178180da5529ce68b7aec2dcf07537494125a8df2a58f681e7b7cd3dc98623160dbb3784cfb3b1df8860f22a7f6a16f4e23eb8649032fcf0af71dfdc1b1bfbeadb3029e4ea659c28f1b1d5a271a32f661b6ca81fa89bc001e404c3a1d70db1133a9055f57c24a552a856eede00c004a7e853222c5e548c2bace94d3d4f93b7144c9f101dc8bee08d57b78e7f8ecc53906afdd62635078917536df7344743ca780371e004fcc04e3a013397fd17b58eec9cc686093b6083ba1258727fe09a5cdee47637961c55c1b0ed53afddf9f1318d74734ee8fd7c184870ececccababd0cdd44d0dad31248a2a9f22a07c6a83573f1483aa00993b0ad16a53b51ba62c8095fa3df5506be176160082745d87755598c7615a87a8ad6e9f1e5f739757a308bc80812ae8c5c1ccd620fb88b003773531e3bb572f08b82911b5d88041a34e9c82230f5477e4fa1f71da3310b1b38b3c0dc3abc2d4dd4fe3cb731afbf501733f5de99d959413a6f8da7016e49dec08a791aad924547f34632dd739f6c34bcc94f2f4f282b1b3d30263754fde7a6328300fdef1200e325c76fad640e73b123fe8b65f1ec78e959aaf84645096d05336ce208d5700d99173ca9b6d5ed7cefcf91459c0e5077002c370e19c2fd2b2e773247b80fdfb5bc2bc10f1d7b1305bcd675654081997a10562d0849f11beb1910e63f35dbdd02688f37e078a5040d9888f7b09621034514a4944a48544a367b1561059b2e53ca796b7ee5bd40557d3515b8e3bc0b0164acaef0b00589d9b22daf9ea0690dff9cecf6dc0bb42d13d7f163c5c2a7558912b52132845dd79ee067a059598438c82804c5f8bb179d5dba73f0a87e5e014fb0c7c72288183dabbee6eff10d70989c2bf819ad7308fbc80519862b440d55454837f62945789552adbeed1756e4577f63aab99a0311a0dc5b63a9f41aa416c23344edd82e9926387a0ec85a560c8214c20fa68436557772aa0badd97718cf9c7c2fe00af300cd803623f49f55feb121c38a35e50999a46a7175e03c064583866b00c1d37e7f585c8606bce016ab19a0e35e070378e9b477e5d6dd4525c58526ff14eb7ee015ad3f5cac36839c229355988e3cc761e12117b208b7879c51c502c39fa706bd8a89fa34ea511b497f444040f17b7aae15b60afd2e509c230b40b3b09a7861d218fea76ac8acc3bb2d594777ccf638a25cdfd685f70ef5095137ef947b842b199f48a35167f262f9d40b5c304ae8a8780d48806ed933b1f6f9a9d516eae5c37b73afe10a1fdc18bd56471c0175aab2f05bf4b39e1af4fd2d838be0a81a57a2bbfc58268b21fa80967d6050e6ad2b7afa905f76f238771dd6a56410b0734844827302a62b07c9525150eff37c1488f2976807c3d5ad1093537b2433c81c5f0eb4e81f36853fbe97fd11dadf510568082e81175a0864d46922b789b1478b3b0859a2cb11ad7b844cdbbd7b2b0470de6bc2abab5ee8ecb6094cd300758d5b65eca66e97ec476ed49ef1ec9686c899af74281e3994b1036294fdc669262d741328c5b87a86ba1323adebed1018e756763a141b8bdb3df780f4a4575567e1f3bb060337bd1bf8c22a0e7547ef591607acedcea052ff90f64d9eb7163cf17de4e48b166b1410a339ea3a2fe6101727f170eccb81e7c8b479d31ded7242e8a154237ff0d93001133e861ecfc1774474ac0f493091a66b863b7350fb133de3b0a4b2f0ad597c030f3f22b274ef304d8b186cac702c2759be40ed6bbbcd64a0c2e02738136550c1678bc1b587205944f7afde03bf092613660a7ffdd4f4e9f316ad37ab54266474981841645802350dfc967423a9c6ca5663ea1bedd6d5e0d3866bdd0aabdb656c6894acd4c136e4e658c15de22890e3193a69dc289833939010b86a8b5e82b3a395b8d147296c4ffad2f055e3e8a973e05ba9c6667797487e952f69b697c63b4d82e2c122d9ccda4f154996b73aa093df9704f958d21ee535a57a03947d770f0ede8e7d0cc36e132d0293c449c7aecfe32dcfe741a016b9185ff01a54951ff3034b2664abb0aa667702400920ad294a8f784129cd1dfb9626fd64364d511388338cdc0f949393351c1ab14aa552b7c2104283172cf97d29bd88a289a426b6b1568a625e5982ecd25d914efd524644f4a027ea2b041d839bb37f8e2fd278d568cbc0cabd14ab2fff11110758e2d57e07b7f3a6e7cf1a41d9959aaa37b4829539f2b1fc134308d7bd1b6f537474b07ab877e6a8568730ed845c2d52fb5ce50c97817b597381177656500e626f43af78d25d71564613b318208ed43c21acf11f8c111a80958a9e115bb572320b403c128b4bb3f371fa363fae6fa67b2a2cc430b868d7a056ec6683f82015f3c5bba2303f488e4cadf7ba311104cbe0aee05e35da08ee0eee5b0756edeb3544faccfb7ba79bd9d3de215c84b918d66ac61d856c8142fd0d9e4d9afbfdab47daf8bdfb06fccb0918d418f6feb57c08a1bd02db868b8659920c879cc4489c91fbdd2b2fc1966126206d6c803fd4a0c7852996d22f2f66b89fb9cdeaf461338ea66e818d9f85232b33758a31a723400291de1803cc7f97869d5c8efcb2bc6ae19d449dabd95a4d926f2a72f4e4cbd2ea3ecaefbd8489245d00cf99ac91eab0fe55860fcffbd7e1e5839347d1881baac4e1dafc2e0d2ecddf316b8b3e9a4823aa53a9fbdb850366aa4bb95d3a744b1f099a24253ac73e34ea823b337706e989a27085200be999a876a200cda224d21df3f75bb3a5807d7e9a7cfa10cfbc72f2b73a700c5e7d0cc38c396faee863d946bb7b823ed33773587f2a72f90c019c6613bf1ace5ad2e48320d413525d2902aaa0192106d3cbe715ba8d856913513205b0f48988c15e4f6a8aa1216634b994334c8cf009f356bf8dd26af0486320a73a651c6a75e933df864f2b6d83cbb1211850318a22319cb51361830e25b7037284164011dad7058c33714c37e1098eb840d422605b698e4cb1e3fb61377ced5807bc9a341dc871e47554b0d34f58bdaab21fbe2191e1f4528a8e102ab5a3c439e11a83fe89ac90e3238e0fb10769ea06d93ae856b090aec2c8ef6a43f36abc9a0c644958075c297b4ac9b82ae75b4634b0acc796a34aea468ae7d3ba9733888918f3c3cd1ed0671aa2ba330d082c680d6c13fcaf78661ba9cf53c77edf084d645d276bd4441fecc5503337eca4a77954957a40084312427c0d44bc49c92e0fe599ad4e577f3db21113fa5867cf19eb75d8b63259cced49e93ab6a1f262ef06ca93a5c00136114d70f36205831be0e6f854b23aacf49c7d0a79ce394dd7bdad1524cfdca5bd1c90d092add2d0b0e002b43e35cea0130b9b82e6c2aac255bff7db5c335cc5c1dd45246d76ab57466e034110613edff6537546362d2182684c0295774f3561593ed2b3920e295f8482128428f1ec58c3b69d2850944620c4c86113c8324535556566d9be984496384ef0d0bb927e2a29ff5472de277137e3c51e326ac4ec68d6148bc521571ca0ac0c797d57ab8c429a69d1370818cf871199d3ec6ec2e07be05ff7cc4feea511914479c177967a6e5839d0f25c2f8d60982ca792178eaf0370f4e9ea617a44d88bf736a8c85c003778b718841ccd3a83a3e4f68147f57248c053daa49c95521f6c7147c1a18d3b2df753894303ee11f97696b11ba3f3d5ed048ce6228e9fc0baf3a516db92af7201289b361fd0e4242e192a43ef86ceedaa2d1766dc0fb7b94173d033047544c45fe56af50a864ab888d222cc325095a10fbc1ddd8d0c06aa8db2c4f21a386f114f3bee419a6a3e8bf118dccbac5a7dee3908e81f527c78d83f526ce3a2563ff2192e919ffd3ec2893b90d57012ea0f23928fb07781aed2f14d5634a1ad2260ba0e4cd9992f77403d782689f4e3306b160255a6d34b8ebc589b8832783be675a37f079124b05810d88685791f1ddb6ba560cf24cea222bbd241a226e98f28f640e3ad759ba8f45a25491921b572f2fe3160927360bd6d3d0499e945575974657d2b2c0b439f958949ae8914d007375d9efc4c199ff95cda6cfbb74753b88e17cfd751706b5d3ec30845d18954aed740bd26606c6b0dc72f317048750bd43d1818796d66e0f532823639b207eb7fe0fa9c8517aa87d55a6a353a9ceb4ddba5e4aff27be34bef8cfd2ed1776e1d60f0bc696a99e0ec3a3bf61cbd52e06fe6242a361f1383104e9a50f4bc2b5840d6605542ba363f1efc6d236c8f29dcb76d311d37cb97dd3f8f3ae1458c6295b3576d718435927ce2964caa946396eff28b5abedecb3d508bbb5fbc7a1c81b302e974d454966a7d1701376c8c3c27f4d6ff69870be01132cdb859064cbfbfc5a7f508f3553a73311f872e774165ee7cfd85ca2b22f3041f4eb41ff7a7f41806ee26d95c847e31cb943277a5ca066290c18dc294bfd64f4d37b3cad8f64e5237ecb5187561a008363f5b436169bfaaa21b64ff391ecf895b37121ee30882e5111f957dd3645e8f77bcfd4696c7b461a26d1fa915617e709bdaaa7eca6101c2179273533a9d6e41b47c941342869bb6ebed8e954a3f751ea3506f1ceb2d43cc6f275d30a50ccdcd6b50da4205e444bad0ada2b3d04bd465f958789ca42d2d98bee91e065521f2101a42c623d84b22dd0657d43a96440a8d8349e249117dcdc49a6a078503e786c1506e03d67e84899e09645ea686923029518e4be75c6017f055fa8d38eeaf9f185393200a320f79e42b2bf530ce2f31eb1c1db951b4e8eb7759e5d8b77279786d3d7f55b01eb0f9667f0bdde7124b6c234ab2bc6fca9f88feef1271de199ce76b1ae853f03ae219ffc0fec7645413bbeb4832f12807f4942d249219b527d2012cb1dd2a40ff3ccaa60c1bbd760488eb4c3a2598e8c79f6c273df36bad9a31059bc4c695f863a3e1a702a2b0545ff71c0d42fbc24ac73b701fcdbe045c918cd541194b48fdc216c9800ffba6e70b81561266fb9e9b30d9e0d60550f736d8d59dbdc5035bc19b30e583eb55637aa1dacf355e519b9f246b227d2dc5b4432b7d835f5b577a99d1df3dadbe689a47319e4ce3ea8ccf9ff7e67f746112fd823751045be73fcc3723358d60967cb461a7d2e55464254636ed5ab7ab2de7e03a0b4b9526fccff30813168691c831ce95dc8c8f1d97291fba5a05d873df65b3a33beccb16db3a0a68f59e371b2a8f775c19b40cc98f34fe365aaca9351a71cb61676fe461dc19ceaa6cbc682c430e487f36da74ffa299e55eb575aab306389a209ee3d6efae310e537dda1c0b03cadd074988031a98a52fc70f254193deb46382163c7eb423e95ae4f4c1f06cc44fb9fdd2a9ff19cc90b66f2f4952b88c6da30fd261215654c8fa6667552c1d34c165db9c2f702379bfac0ca2b4502727eaf1661900cc087b5d064ce38ce8d7079117aa910d0c99e51076ddcd4b2e4ab846c7d572a9d9b6b5b10892b1e0b8d13b5dacaac315a388ee5bcfa3be35a8522091eb6112e757db3e9422c8ef05ad0c7c64fc92a57d050639e4efca4354683817dabe0670481cc156d70417ba22c474797b505df02dde53d2c3aa7a3a468104918fb7baa1f3cf00ef162ffd92b23544de12adb4f6ae6a09da673364b70ea7e6bbe81795c4bd8d845d9913bd8ca250af48b1551ab1738d7cb848e5fd654df94a7ae5dc90d912353d9a313c0ebf801731a2080f083fc2ecd11ee34d5138032fdd3a21b12c09466e43f55586a36817ed124a9f03680b49c8c7f53036ddd2be77d3601fc893b1cfc3dd94f33cb4bf4ce332f088c6749a8fb34ba87922c5f351e91db5530f957dd163f187b6a712a151b0144a0a6548910f3ad0ce878aa15d30cdef24d9041d2bb5957af8768b7cdc209d11df5acc195d39740208d47ec19fcba5520c658a204c0012113b2675038e19b7807e0b894677aa677dadbecb724aa53503c235c1765a0a3f3e3702c262cff44e2f00b9d57b5eb92612ec54f37de57d0763dd82ce543243a797ff3d444b61b36941a015178fb595a8290a042d99b066570d2d8ad26d8a6abba5a7257e47bcf715af16b4b0a1f3b4b16f3c0bbee844da58c4b6271cd2ee5da63056b665bca97509804e90c4ac0525960ca01ea859184acc9330203f69c301e28f5387aea4cfd8b49c04c9d0c496a67f53179521b3f0faf95fe521407a5d52541637e489196d57623333423ef468bbe209d865d0e795d563feac96af23e070b12c9ffbfadfc8afeb76eaf9bf250f81016bce42e0c5d3b0088ae6833ec70434493fa572c39cedd60f37bd694d23311d08ae624e0d3a69c27fe60c9beba4c671863b1bad54eba72b0c6e514f11e8ffb5036604ad6c25882df43a6b67debd8495ec31d0a504a311632037daa822462341dc5748b24888e9b701fb5a56c6dfe46374a6c888c0af193b25c2d407e5a4da5d9e69a26d07c4a9f93de7d6b360135c6a7ed8f240c219f5c043c82956716d5bf3d3525c0d60ba0c76b8514f2c59921bfe3c737e3cfb3afab21559a871de73d3285161c5faa0dad28aaad344e41f8e265663d70d80b395e45f57e74f51c700466efe5ebcf8e147ea7894c2689f4b3ff909efca78692403879ecc6f6f0fc1045b52abf5d95806a0185cd6cf42189b6c85572cf5908a28e0cc8a88a2c4d46d8ba375827a57bc234f72fafe42b0da29374ef7faf25f64205f3fd87f652ebaba372a698f9b2f622798734193804e030e635e74ae95c34867d09dd6f0c090412fac5704df9038d89349ebea1ca5a119dba1774704d937f592cdd4cfdf845d2926ef89838e323fe5177600358d354399477c15b2b68d45a68643b9aea8250082603a45d31319286d02bd70232c496504cc559802fb5acfaf8e053ab8ca4c1ca416575fc28f551d4c7d8922f850f8c7d37e15612876e06f6a4ed1c597dfd7c364e3cbbeb6b8dd94ac9b8630555f19e27d20b6f59fa62184370a256b8de50bbfd1481c46dbcfa10b0e37b979aaaf0472b441148b41680579b75a53a579d941d4da7cdb959a6dc4a8767eb5c368785b7a84d2600954251e0d4baf2a5e7acfdad3a8d849b3d19bc9f8577bf1769dc531cf1702f16a035bff93338ebffe7550546fc1b439c7c9ac359baf7ed17f9aea8144f78cb1f5b7484dc27c304b92b2a1a6a8447f5bcd7744142806010d6690da5bebceb7954178a85fdf33310ca576222b35380396a3e582a7a129f19f215a0b44cc41807d324268fc12c86da067a6678c4f7ea4db3fc48f3c8ff831006262eb0e4e10a521b2462486dd72816fba3a6370ff0133759b0361d7ac42ee77a618e8a2b5cde8fa927b822ff0169cb43b708c8c35fa2ce371d43a2fe401ac1f1a80a9150138b457b05c113c169d80cc8f79a39ef2ed2b04fea81823b408db8ba437c12f5d8ce860ef646bad35294a3fe520650ffa29eec4ff2766d12b710bc62ac36abdbcca7867639c42bf476799ff87f8020194f38a41b03fb929a20451725a09cc09c29f1fde0b5b13f30dae74b8ea947680080cabb702517d851725a487698f98a66bb66b35072db216e6354d14fdf35b72114e6bc673f57e0057ab44c060e650a7f9386d7eacc898d1d62b7bd6ef1b96cf8f9b35bdba91b9cf7d86a2dd0b436ab165111e5ca35a24c8ae52dc0e647b7d60fa8d16158fbfd677699d18ccbb3ccf615a478137030bd690d1e7dc7a79da69b3c4672e9600ba9b2b9340f4274d9a5e5851a4b03072dfa357f177bbe676014a6236b31b1efc2b8d30d73d72e002a2a9140681f49e2a8524042474d54579612f0a62ce731ab45ca58bfb08842d5b5efddedcd7793b121f03c957248f48bd1794007d6f2bb50fb8d86bc0de8387bcd610b13f1c2481629a27f1790a2eb0a068641562ae2c2c1fbed1b656bdebb3786148278abce7976c9dc1035922df162b31b66e824b90a738c8b0167d29d9e4e271ee9a48fc309d1eeacbd26216cfd8245cf63e6b6cf0ea405074644eb80163dd8c40bc89a69f83e3f9bd089a104606cccc9970a871127e8d184cebb6cac7fb489003b6c731d72b3040531ac0e625d2ea6f11e5df6f6d560e79fc00d4d3336bdf2506a71d55ae17093ac0d4b6f0fbca0f7f3c19cd130bed8d5091539346bab6cb220f8ab82c97fad6c56950813cd0aabe31524d6baa6cd7f39c922009f3747679d0807bc6ecc061c8f83b63f708db515dada80b6d440468a210ce75e7d09e985e97ba7d9fd42e7e44df7fa224a5f1946a9a2d3e002264a4d47d9b56c547708332a6036a72da1ae8f9a3c678c2db2576a73b7d41d5f9bcb9aab1cac4f15908ded130f64bb958e3f0965cc60fbf4cf41330588da2049b2a7bdbef2aabfac306e3176a2e7ed7661d1e0cbabd1d73472c4c5b25c7c4530ef7ba8688e144462c91be8f376292592916571718c95b78a502d8a424ccea21cbd977794841e4083a414d1948d1409712532667513ad6bc3aa0204997a27997ba3a6e271e7af23d1e2e8ce875a266a87bf040c7e49d286115a7be8515824ef92c07b9516d8f773c2951aafa65d097209f35a3365020ff0598aaac8d429cd6f102c73b20d61a852a525cc9bd92bd175045781c9aed57557a2112f346977ec1596d3cb93010d731fb134ff08c4251d7717f37a843d678ba8ed8971ebfa3fc29c752978110278bffb7f05326779d05149a92decb24049014c0634f18cf2293c22bc3479db47901fbb96be47875421c9bbc0999903290345b3d4bd00d16fe7a1d1c44023a2f2adff61e213bc4be82689ce5d84e3c69e5365fe5ea7eb9262cae893657265291473cc670d1e8bf34fbe6e54eee1ad553589e05b940533a2d4ac56328f86c0fafb814ebc9866ae6a9fe71bc577134582fbf31134634ba25a6c54fdc2a87bed2cfd8b554367b56e6c25af8d652af856a9cf5e9923c9cfcc4dc669497fe472cdc49908bdb4aaa118bd0ddfb6bc7463d237a872715aeff81c50ddc81c9102ad8c0d40ae58623001172c8947c5ea68c9c410ef635303ca9308167f0ba66ffecfd472ca3510cea9bda720e64572218bb17bd45828f08c434ee15a5ec9eaaaff5db8d83e228c0d4a54d3e521f14eb925b1f6636f6d68ea13d2b4f8fde93d4a698e99feffaac282661831a04d7aab4e42bbae3249ec773eeb946e4f88c85f4199282951c108c01f44c5a06619686cf450735f8e09f40e08203b6dcb90cb5a1755ef2c6fd62a9e0b2787fa249c69ef1ab507b2b02e85df8de5aaf3fa35efa96bb24e49bc6804222766fd848e8d51632ed3a2ee854d7447d844430097aa95875014f5e3ad06cb4c16ad4bdf9a82d6d6335205cb39705ddcf75eeb775ee20353e4838a32c78da67c08c3d7d173732d29cf19511dca02f74589e003d864dbb74dbdea5d0e29d50a58392340e61f087d166c420b75caae2aa8ef92a520d7d76284eb59c5528cd67cb86e8bcd53e264a94b7a8ba23235e21a591652c354b4e357efc3f5a946d929652fb472f93dd839372b56fd56f13032d79f9203d65a0132bdfc44f15c8ccb7e424e975f3ecdca12f638ee397cf812bb5a33c85e4739854f2cb496925c1bf59a63c587dacec1bdcff9ad7e7633c074269c8c2ebd4f61f0dbbe0e4aab7e67c48d674b0ec3336cda2eaa1ca6585de4f2dd061ba128fe1fee048c120464ebf151738d91ab66a427105ee0dd66ba54005462ff2f362bdd4372acea94fba7e5b70b720e057e0d8d2f154946c140e4c8768e418d3008c5f7643ded1ec2491e3860edcf6b460583825d6b526a3705ccb53b6195cb9d9c78bdfece5897483aaeb88077839507f9d67d59ccbdae251f0e1cf496f1a042e696330763e88142e80b5e44b83e4cde3b04aebc00130af47d0cd2e1e7a962109584be8874009839122b097d83780d7f7311507ad6cc619367747d1c6d7d3c10324b831224a86276040f0f55ad44644ec3fa232e718f7e0b34c8d03af456a405a762a32431fa0491ec96c5f4b5fc840ad0107c0a3aad31421ea596179d1b1f39a8b862fc6bc4fad21eef826bae4fca0e238bb1be3fcf1fcf9db4cb58b0fd2adca68393f9ac84e902b6f577790238a6b1d00babf9c6d280da39502687a3239d1365247a22e356334a053084660482b5c48541affb2d9f9530af244e636fd17782d2250620ad32cdc6bc57a6d5b0d2b8dcf70326b01fafb646d48edfc4883fa91449ed989a517cb3b2ab20533936166f5b9cb2c20d5a838da56f5bf105c70b82212154736ee85254d9a693a7890908db9f546a2f085706a4941b2b481e0fc9807b322f2eb916ef60ab27bb0b9e4320ce861d41f7125e18dd9f84ceb2ccffd8331093e137a4ce17747bcdc8e3c22f0fca027ef6269713c6f0926e39222e9e5f62a444a3c6214a8343078d0865290a211c7f3e69ab17c34d6b27448e8f68926320809f386d9e0399c202a9d4ddfb14a81b260091a44e19e452871147a81702f259fcd3fb04f02cc8e98bd7db64cd36ef8489b894d3a4fd876199158bd0598af4e1b450369ee42d683177774d84ea8d33326cc0aa14e46e4e6f91ba6d846c03ad45128aa79542d0f2b295c7b85d5e33d0cf8f938b60f2345a66de4f706216861713df30fe233d6e8f9f9f0b570bb38fd69fcbeeb65dc4df7f6d77088fdce9e2336a33b19d37d28cdc875ff52c986e2a29001ae12a4df6f7a9a801b1a3cc7f44f54290843637d788ef0bd4d6b3ae055345f1993849a21a7543d1b4738327209f1c4cd04998455e06c06380c6f17f5ae056f30475b3362ecb4fdd80eb35008583afb16c094af83b45866946c1ae3a53d490cbce09870ab63c4558904f9bd0d5c2807c8e5e290e174dbb39a752ffbd25824a0298fea2a631ad67a9dfcc8effa57fe8a37d335524e7d7af3fb666099270be83fb84ba9fd3ee42b93317d5b99fceaa6279bbf2867194981bb4192b8b51d543315e8ca3445f7d84e498a90bf6bca419238eec0b1ed913b8dc68ada56d3522156fab34bffe99dbcd851d42c87e63725ba94eebf205964f060b900d0a3f13694432c28c8572f88a66f35642ae8a13aa22b154464f99bd93da69ef918ca9ac75a4adc292d6e4e9dac36d1931a5fa26d1a19f45e9db73acf4b2128d5d03eb0612af22a4865168e4d8205df547931adc8bf161dfd8ad3cb6e9dfcab842b73241d55314e6bc6e7e855ec71c6c3b2af07c244f8ac597b91b47c1262d1be907fbb98c11a35cf8bd8165cd54c253c8d7ccc1c94f0a828d0a32c1cf1db1635987c941359fd58434d52a3bc208e41880cedb621c2714c91dd5643adbb58b9e552e7b0b5628cd40eb096eb290e4fe85785dc6bf04132f289c5acca90d85ab748ebd44570d7c16e4dd918452db17fa6040e7d1b2e96425ee51c682d000ce00d03bd1b58da675cffa708ae7d2e23a5d9cfe3fa788df06ac08f84718969a90a2db1b0882061397e7e1410552082ed85f9978bbad22c88719d26b4266053c55f159ad3a4de6da2bd4ce25e8740eccea120b94030f5956456f787ac59f0d3866183540bddc764c3db515439f9e0d50660b7c10d098bc4f8452f3db4bdc80b135efeff6ceb0ae1a224f840d4f566a0d209ae2d5c3ba529320425c7f4aa7e7586f6600899ff0266caaee6b144da8f364c8d7ef0f674ce8daa6bfa7a35460e237a818f572a3b292f0dfc32d8d3b5dd50f9d56157a284cca18fe2873430f3c00afbf0cd05d2869a9be8b5dca42793b042e987da4cb1d351a7bcb72b7b165eca74d6d380e6c6ea0d612b416b192f2936a7257c2dd28a3f755e95524cf572fb27368b3d39a592d40331d0f9e3b290a058b37dd0d83c1fdb9bc18e778fbca748ff7024cd79da365282d22370824d6981628fd7596393a1aa797f4835a96b18ee12a6c92bf6a29614fdd91d2910036f0c64d5eedcf02491211c6e1586dfd30463b55ee7433556beb845b88e42776e13de7bc155b543a23ca1ce4824f59109d31a0c718cec7db5caae666b2736b146aaaddfa0cdf3d506a91b10d1c569aac3d122b7f3c5369b31ac8e34a99a845385aa927d4d1bcb96c739d4826047aa09b62f4d6c98884e53f2f9d261d14908608d2a75114c91827ffbd5d53c6688df3d3e784eb7e97a1386c278a4914aa08027f21bd24e471845040c3a8b1a6ba6326db19f837b7764da80638cc45e62118950358348a2201ab11fcddb380f6393534cacb1f1241279ec410baab3ca5da1467647a98b5b97911dd96bb428f107bb7c74f0266311c0cd7d32d03d59e714ebc0cbb199bee60d6d4711ae8ba941ab75380e5830b0cbd00ecd2bba78e86157385f2ef17910437962f230db0f669e31835d147f9508c65393677cb01dd68ff530da8264f7621f1cb9e23af2debc65fc9cd59193682dad32e1c39286e394bcab703ae57838fc8baf399bf81dd650efe62e2d231c043d2d71c86831656baf7b88481b1ab03fd606dc6bc38beebe2470a65bd87cfb1c9e06994ad400cc0c80b245834c9c5e6a3bed899f1d378a0fe3145f4e99bc98a70c33e7687a777391f58b2d5c304b1bb793b0de241bf993bce168064436bf7ef7b5a27ca58527e9ef720ab022ba0d106b93f3a30c8cb946c6c2a1e64b8c37458d1c39efc8d0ab7400a901b6ef622f284b968e2343724f1ab154de5e173f4a7ca6ac6d50765f31c44f938f5c9d27b42a88a7dfd5a14acb65d24b1d23f91c3aed6381afb32478bff4e38d1d0bf12eba4998c33b98097d8959531c1432bba65c05b221604f9b7510be1457ac06a1439327f0c4fd9bf98faf75da58b6f05288e2c6d3aef17dbb48d8bf31e9c71f0231851b27e8d58673df36e205f29800333adbec1c70557ec48da7721d07eb4a4d1a429b0db970ab358919d954d693be6d3b2ad7048432aa64e65d9709458f3f8745ad84254c0168afcfce8ce64cfeec5a63ac817566b5028a0b7daa861a5958ef70bab928981025c1451cacb82cde27d8672cebf753350a913711204be821051736b7f80051bbed0a8b277fa5a6f19aca456f593e62c49eeb7fe1d354cebff67ec90e21fe84eb7a3098a91ade843e15350abd436724502d6b5c29fd9c499334c39b860bef44f80ef90650d99126cd9109b18af71c43de8ed5afc088ff05e12cda640a2efc60adf277072158ee9e7f00faf5e2144c03105a3357cb26ccf941afc29121ce49f178035f23326ced4c5c06ef9f13d4275c4dd54d4a7a29e3b7ee15d82f128d4459b46114621db09903300eca011d7f3efaba61a84a86455eec605ec7d954e45c839a8570a3f81d07cecfab5e7ebaf7b0d08b40efde5938d684776648ea7fb659036e2bf176691576ed1ed153fdd187e867d3c9f2e6f577dcebb4bdacfa86e3467bd59e374576b8ca5d97b35f5ba1c698c58139311fcaa27433ab27e812b706e95d313b745fde01def76d9bb2325018f2fce08b28ac9a476992adb5c981a35c71a90e5f4d30fe1da63e5328562b80b46a950b7fc2fef9d9ad3f2537110a8e03bfdbc9f7afd4974eea4e4a7f71bc4b751b1d3a540217e03d438b60555409763b3e3afdcd2bf34a53f33376e6ac953963ceb725ce754edbbed65d9c6a9007e6bb46d82119cf759fa2a8f491813d400cc4245f68d2e4696adcd206d8681cc3d2faa3edf4717bd666ef0fc10c5e34453211442c5ef34aa17c59ecc04cf11f01b5c3023c7b9b51fb9ac99d3a6c68420568ebcd9b83fe9c74ce045d814d26766ed2f186115394f770dcfb37a7e5f2dec64988c2eb95e0ebb497f4a34425af2c541608c8a9af7f5dc8da09d578fd314f06635b2bd1209dc4f89cd93e72ffaccb90cb7a2aeb4523ca8a5c85cd59426e160a7cf49c9ba8c9f8898d6b87ceaf3817183211f0094f9132b4d5bdcddee343808eed275ffa37589e8d82f8f09891db2110cf49f6b52bba54cf65f2b7198453af419c4f226519df84ce2416e0b9f3d7e6e909e4f159c05b9922d6a8174459d7eb548a6f00a9fe09adc678863641a36736e2b5dde5c366bd7ce4a1ad4aa4c40e1a3e1415cb2980c4426717b32eacae1f105ada024656d2b68ff6cec5e83925080b7176b31f4b0c8c5d9f79efb71600748020934d9b75877daa51865a9a24d97403a1a2a3384bd6d6a76acdb3163bd2c48e99742ac37e4498fc959fa1086e7c419586cba9508b2c6dbb5b094b4da890258b9d590bfc28edd17a35701a627864f024447baceb65063fd99b66c64d297acedb721b7fe6a769abb7304004a69b6855f8bc958fc9203b3d8c376ff6cd584e7f96a17f0030ed453aec92673c43a73e74eddd5160f5ca356ca8ef0b948f09596be350ab38740128dbdf0575a3a9652a37fbee1baa522b472a2ddf502dbc27272f126c09045c4edf8d4134f41684585acccbca56f2c4269f7b524e3cee619a877668aa7ffe32cde3ff19a537db2237f02f5a2ee108ad103c9ce7667635c1d25e923954d1296442cb1e404c7e7fcec5c95d38f3b4246b0077341d713fa8d8acc0da8dc036cb5de8c7075e436a59cff11ca5dec9545f5ceb6411dc6dc9ef56f96234b954edb0380934e1d3ad728c9e22b2e54b7b433ce8a0fc4359023b96fd78f678abd060a0094450f4102380e0b5e6dd16c3224e229418d7bee2659d8986caa14534e4f74f9007c88ba19e9ed3909da8061581e56611f16a4ab8ae9d4f7f140f1fb196935ecda4e6a034666379df241ac000d007dc2f52788a064b3f70b769e75b5f6ba70e985e7d69e8d3fbb35d5b1c98269f73351765333b6efa9f5bf85378138dd0e82a17741528c817e36aace4517a350bd2e1929bbe664ae47befdae266109e75a7b1c5535ad5df87b7925b45e2160960f84867c8f69f66c1ea3ef01536d848c7015161a992b51e8809e4f11c6d8782858206ee4c181f21651680b90116a44f04eb025366cc2dd1371dcee377214520a4438c85178d9a5406880da3dc417002f8902f41bbed76bde09e3bf734a5dd1198ea830d1b3fe027d517e5e66a170def23ece1b76edd7c8d0d1a8e938c59e910134004127c591fcb03537ed0d7511ab78448a6fe0423e4b3579002ef4ace040a980ed72494f9aa897882cbe0900629ba7b35e55edcff4b1433cab8a0928a880b51374d09459206ab359dbeb3c285b190c711e6c5c2b8f9957fdf394cff790c4179ca2b6faed70457f08d2240fb4e8798864c1da140c2613710ef1d3c8da404960d6fd33f2d8c14dce5b55f888939879c6ff3c43192d0c6d6047b81786bef4b28461c98f5552907cc9b1b06e0fcd6c07c002900a9442d0865190620fe726672058ce7783a2203bee26219c01044ab427646959248038afc3ef9c64994bd5b5832b3ec7cbdce0cc3a58b0316a0ed4793d1f5cc40a7352e7a7fab2399728b0443ff35ef793209ed5a7eba9123f17a851c0450f5fc6a6e8ea16fa1147cd4857e0771ddd02d1d3facccd120b5a3193a84dad13d212f8aed01ee01c59790b2fa7cb9ba8fabeca0f8c573554bddfcfb32dee232840d2d7a543ef8c2b6dae3cad9ea1c1995edef46b58d6843441f2f81cfc91f890dd4fa107670335dc84695e692060223d61ff909c5f7f7f1fc528a61670178890929d7335ec76ffe46a5bd063209e7c7740076612d6a720981524d9af10cf4aed938b221c61be27a4df592c77284eb3185597e0551d0fb5169def110c991cd7267a846d4522c09072cce109ee66c41a97146e0583920bd6a694b878ac539e83bde2200ed195666f5508cb474c203380cb5ad53c01015dd7442fe8399d4864d5f0eb17c68bcb3b8aba9e04b421dde751dd98b285a3ff51c1e29e42ccdab1b001dd7d9e829b68a0287b2db8b1ec5664db998914bffb5bd84edef626cfbd550e7f00c78a883af4f6c1c117bf257e673fc01d11058d5c3be6ed9e4db357bab8a9cc1801140ef91801231b84ac5e31a2a4db22da94942548ce64afeaa2679a63ea72009bb143ff9d015088670a2316ace4cc45ff6470313b90318e60eceb03a8d9f713b373152e19e4795d1b7aa39dc3cb1b2bcc8c3597ac5e4c65e9cb02b1fbc03984e03e0e5f2f775d8a451e4f4d309a73e6c228c88faa4e6b62b77efc4aec8b38115a74a62c901ecec711f9bec493ff4e95d0cb1153818f0ccbe878f192bae962dbc3e3434f03a57065973386285b8d56f912f3ed651e4643cddeba79dad07bd4cd3d0ca67ab8124696c3d76da1747aa4f93af3f0c95800866ae3ab85a88a9e3b9d7c98d3b255d6798bb4acd0680777345f69b994d31cd6c5b5105608adcf7ef7e99eb1359245bb9e85501afaac5cc6d8e0f50c54675e89cabcd038343db791b132e823c194b05f6f00430e156de2b986103404f1b2ca46bfcb543de48d11fb1bd0ba2193387277fd5b9ecd252459ac4ac543e347881b4c870c0657f028580ac3d2c22c9c500c565c2a8dd25fa6eb19828e73486ae5492c79f2cd15a031af17dba05808d2907e085d40d4e275a0c3c8ad939c560c2011401c977b65bb13ed3b9cd7a2370bbbffe3de8459670ef30de3b5bb7601af7b2cc8888c279123d758a24aff1db6c03e832d6ab8247169e4a66dfe677f2fc086da4671c0943486682fcffe2a533a4c32942467e54b2aea12cd04083fb146c274d4d518e8123bf3c1a579a0753c96e2d2bb6fe5181767ee33a8df50fa2384ff48788764e46e25945f54d36765427fc23b075b623b3f86933a2f6a933c578b99f55d692e50ed5e3b9a5a0f6611b716ce797428135c8e4e65ce6d76725103ff39f83c729a9ef1631a933ac4dab530f7d97b9c358090994fa37bb31e857ef6ec51fb5274601d0618356cf76b8e868ba44b9d927f415e346a779dabba037d99a9122fdbc6207cdb84981e1f22a0c0d055fa1aaa463e04b5757d5bb5eb79c8e36036695276b6a392c6c955488c237fa44050b6d65ce014230cd1bcbeadb6dac5fbc07b2bf135d32f6dfbf8d5c4f437c3342db4df5c80a9481f3aa57739969af3ebc5030b04347fdaacacb0a1cdda10b0dcdd2d55eb1757f3c009c25f923d62903b4dd90562da5f785e053d634250b39b52ea3e7d1ea3c572a78cdcbd8fb03a38b7c4f7bbeec44398a792476df7677e3c4ac2ef80c44e8f7fdf8c1e161688c0f89b13a1489822d648ea3dd495de624510d1b60ef6a3da12c22c5c04e1b2bfc0f13ce3bcc79bd62caeeb8a31959bc6954071e48da0e5d8c9d1865ccd24e158d750e0e4b3ffb48e46efed73dd09f3ae0d9edd9106c3132de121240fce05361403b022c5bda47a7cf6c120b09554d9af17018a620b3e0e16e1583c0874490e7df43d5745f7f55b379475a05db31c740157b822bda96ea3d4ba74ded3b4e73b1ffc308ebbfecc9b5b26bb013f0b4c0e5898c1a7b04c0c91c8617d2e9e42331f0e1e5c755a1b4b5240dcdd90778e97a53fbc0bd593d36be76827c1cac5f510e6c1ffb6a66a05a7f5ea7bc74e556b030431ade0c6e297145fd49fae68ffb9a3815b24c95c27d29d622540be35c7c8f6dd0dfaf2ccc4cc9dc454b9cd01b62d3bceebd7169e55c807186b802b6850c4774ac82819b73604c7939acad1778b756f0626ffb1e8daa16d332db69b11f2373472b9d650f7b8542dc6364638b29ce11e4a94d88a800122dbd1f50e09bc6d4b174102bf04aaee356456728a72dfc846a95da8f6e95175eb2b8980b08f2a4d2763ced51517da1845fbabedc1b2959430515289dc021aa1d60175587c402953abb4a10c972caac327f704873c9276383bd68e43be822fbade75055ddf2efa5b4f1da8ea198ff79031f435071bc3b4decec87d3312edcc4ccd916379309f7cfbb155d78d46bc7beb8b961961173f6e2c0284492cd37c1bbd2e87104fb37916170cdb4f192b612411ed6352ecddd361be5a684e22e5033c8a34f3117e7ad75b91eeba09395d7b53cf22dc6ea723a7a6b8d1b5aa9937436fe6d519ba1efef304847f123eb795b085c65e3311858f7721ee405c9e65eefa94ddf1676f5a003471ee92ecd104ad1c6f01ea136bd3003d1b47ee99316b7253ac2716771ce65026bc7663a8b8eb12041e1146d40c3f09db0ab0ed7f847d0037c50cc1d77204d1c840ee06f96810b4c717bee72c4f96c736ff501a67f5b64d1ed8b3f17ff26245126f5ccef8160293b53af164f3ab146e627a928fbf4af9d136f621cc75d7c7976c15540f0e5e4c616813e68c1ae136337f754888341b4a440332f9ae64dce8f0a732ecb1ad50de5ffe7c4343485335ad43736c0e41288c8af29a8b94766e5498ba3e3d392837a394d87876d8d43dada817e2b199c55cb5ab3595d362d1737a26682fbd45b6a2424c6e116e2711a51423301796e716d734a2e5f19ea6ad116fede9fba7ec245042d181d96d75c32d1f30b4f7f0a0745749fcfd66f88ec8225d5db1d577ea6b5dcbd48895a7fa6e9595ef022646019412e88066572e10b185555ff6ab7bd7877b6337706f4a61b7ca47a6807b947c9b933c8d143e445dcf1cc8335386c6556e9820e32bd9bd6ed53550998538ffdef194c66f3cac0343ecf68f4a75e207423fa08ce035947fb879f9ebc3f4bc12ea9babf1f7e88521c2a820e38c25386f7c5f336d3cd9db1529daa394afce44577da15ecb99af7f11599efcbceccb468d1809d8abd8b54b68e1f02dd5ff2d5b394f51607d7412e84dd4e821c1085dbd1c8a2784728c44568baec3b2ecd5031e9322dee4fe5257ed6e4c1f846f1e81aeb6afb3371c19f285c24f9d00d896bf6cf2a7ee904ee774faffa89f0be928ce4698ba2d6540368e41648152335a7318b8a67de7c217f3c756d5d12872ed33d94203a95dd8c24a6664db34785d2e7c9fa7dff457e941560461e882f169ce7188edf3fbb22628faaf72c97047090bc73d55e467127f2b49c7bff1bfe83b44b3a945904a5c558b086aab40f79cfc0fda344411b00e73d1f3759c06e98378721768b272bc2f63a1ac8fd8f4f3b6eaed229a9d4429d64bf21c1740d77c924fee30d6574cd1197732700d8863c5cdd9c0e476d9b30150e9ea4561c3cf43746bdf8acea7a5ddfb314c0bb51717105492aa0bf276102c80126b44b83e5325ae4725213830fe9516a8143d9ecf780b3f54ad5dc9ee6d6c80e0086f0a1ece58ba6096c8578fb8bdfe61428c0410d6608532f1f545b6be18d7d9a10b4139f1f1d99d20b2e1bb743bfd5037372c53bc2956ddd59fd63768f452f1d2c004b5a0ad64df49cf1b0fde3bbc8ff142feff17eac155a63d67881df0ea2825cefda1af68a451f418c3dc06fa87700044f62552acf85199a5d361aa7b68b9011e7e2b8c662cb32011d9206e24ee58be853887eee0240ea2b84dbdd92c5c0ecee9b8b1ebea0e18334f4e9ccafe347c19c8b2a04b3ee7d154a7b3bf46839107499d238170b127f507320914d6ba5ff33be8d2a1507426c58f37c1fea37fe25f38ae0554755591a9efd0963efddfa098247b738187f06a180e33daf0895ea073ca121fa9269d144d046d568e308c434abd38d76fada50c74901d297d12cad04fc83c4eca817d1ba7e0197043c5366c7d8eeed70239913dcd444d0918aecb8ff10046c97fc9e7e22683e3d1c39fce618fca84cfc26a777120b0e9e9b603cbd8755bac6a726e753ca60ccf15a0c365d7fc33d53438bce2e8c15119eeebc3cbdee17be885f96028b0c114e71155aac4dee4c79eb7dd1acd001719f46eb80e7895e211be90c187d90711c7b47ca19e7ed7bccd3ac1b56dcd4b7de9962c25ca019af3f296262b3daa84d58512ae26fa4e516ca91ea421cd30f79ccc0f78ea5617b6dfb6f7259c1088b42cc3d306d09e93ff2c07b676017fc2a0657d533e32231823ce384532d50d3eac8603625787380fb5799eb0cc9bbe1eb45fd35cbe305a371f92fbf0d852ade7ebb5be2e81107023fb6411b29f2c695a30213c38a1d80415b56a9b2dba9c2234fd5748dfc16f0c485848f5bcb817efd93850a7008d04c0d1f8d8b1b5d4c6784555fdff3083aaa1c9c670751b68c7f19e15d23f8167191ccb44eb0e23fd592e9e4b1d9b6fd0ca1548539ad7890981fa09e59a21d0334d308535135e2da8d5a3d8d415eda64626fa96081b7c52a5a7c9be2b78039d7f1ebc8b7df9fe6bc5d511b91b03eea9183eeee3256d6121f9091bf9410d69636f24fb57bd0a72f58115761cf03ddc86a1143adddb6d3034bb28c5dedabfb6459143f41696079c6674ada44f99b8b95404da6b6eb498933af94f71f5b26674c0280a55717ce23542c41a2ddfbdf82ddb658f625ca990a800e49853b2f2f6dd0e2fa19811322c6502b1b23854c4c28d1ba9fbe9158ee0b033644c0a45c9edb1b5d4f96529d771fd7c21e3a3ec3e504b5704a9bafe9fef235cf669c06784ceec43fb595c9e0436844f7ef40d951bb5e497499e041258bd6cddd70fb0c078c7071608862927d866f5e5bf40de104f26e555cb9272e8a7403ffe8040b8bcb6424b54d2c0a935b19b37dbc6bd9a991d37ccf10cef292860c7a1065c49640249f235f1761720f84ed948ec44ee5a546b70dc00ccd5bff3edd1f7d79aa4e960db57aff62552b2d5cfb90d112685adb04b4f86e209218fd7dc5d3502281d8e34f2f4df9f437753e46bfcde7e58310a6d84bab8021a4b3dbd87ac5246585c69b59d14bf561f95b41590eba7fd63f04698e6412c77d358bb9f75be631b07c4140360752a6547d4079195f2e96be20de970e9359507b2c53432a7b9c385a6727cab47def707102b9d58a2ca57b3c74ca65272e2b48d3254161daef8665c0224fbaee486512d65345febb28c5eca397147f19063adf85687cf434fc0d69a7cb48e15ffc9e94e80f0057de759274900b4e08155348a6b32bb46600ddd6ca0649b9e5bdf5c213191be2e8e65953887c8c9387b88d12f7ea5d05b4ee375405bd811dad2092556cccb7218ae96d2d7233c478fbc8ddc864d40c02b626382dc56966e6ebba732704809f0af37541bd96edef2e4774d386ccbb8629513ecc897a2bfbfb639c4dc38b588a59c756f9d9e677065211ea4921467cc8599b392ce93e281d601b815ad9419ad722afdb00fdf6a8cf58be9686338bf04dc3a32a5f5c6c22a97a708c8c39e344a1385e227833ffe3eaf4c2ddfaf99bbd2f6be27313705ed5206a1a15f00d42dee617fabea8d217d05d70fb3e088b82083005cf1c9bc7c8619ce9cad76b415128849cf9d8cf39c784e56dd20176a1a130cc039e7bf53744288e33ac8539ce51fb88e6932b5f0e8ce8404c013b1799b77cb821641cf8857d1d7712156a2e2363634339d576be338577a5981d26e61deb99c60abcc2385cddadfe63af081c70039ee5d5ccaa82874bb56a6cdf8894f8b573233b878eb6bbb5827b1a73045c50693581ba44e11eae098a7abf1321217939d488bc1073d6b5312cfaed6780eee2d133ff1259ede333204ff6784fdd8aae76ac04aacbb1aaa51b776f67fd866a06452b1b2bf171075c77bac8486fbef34449f51ababfc16160a56f3c0da42d8672485257bbb56d70aa9844b9254631d77c462d75ab1ded2a164376330ae8ba313a3baa551a96af82469c5dec5f48f219c8ea8b2536f9a7ea417dacc1cd28fc865d1dcea773bdb9a85dc3c262566785c490d22a2e3534a1fbf16737499a018e3fc4cc2c0b8c138acf190a2e3604c7fb3a42bcffa0d6634bf8c497423ebb2075c49de4259e1ceffb9a6d3a4889db1f27a5010f92f6eed7a1abbcaffb6e02e78046c69fb61e8051ef8fd382bab174d6f9e9b553c705a9478ebf617d458f9a29620db6c602caf5ba141328c0243343757fe19ad2b09da122e2f30cacb49fa6ff07d512a2e320b3c2fe9fcc5825c484bc182ca28c366f5ac06cdb451be62cf292c99b177792fd0c8f37e2f42853c0c93fc87daddca5b89980d6ecbdc7fb39577e90f1160e7c58025f8c1a8c59b6c18d464f45d32bdabbe9c67d9675f7a187d3bcb94f6789f7a4f71b2fabeff31ea9059cb2a2f1e69e72ae7112a9f31b38e0e2ba7856ecb3262bc1ad01202f788a17b0535d00ae578423693a90d497a79f0132c33b3a3e87a95668c6bc3d78891e29943acd9300b9b108d6a953f0324cde9c47821b307779b817ce031c4a26783401eac37df0e9091e9f3999990c89b15e9b69ad1cba316a848318ea87a879b8baef4cf095dd2ccae5285e189fb1ff9abe7be4df3d4eaaede203db966b5b255254684340eac1f52e0fc4c835f39891bfdde5d44c23545c519163e3637c24470b5c075c887cc76b8b3f76f072a1297d194a708be382b829ec09f29c6c258e1c4cff4d8754b7a1890a99b47e2acea561bc33b5cb5f60ed75e4f59337c8af292e188d941f8910502bcc272b4e0562b922c8715ee5dc4a4f1a73f09013300b63136ccd040b59b8f83be86cc6fbb923badaec20ec6290a123fd3c6f63327e26f1314b6e6e81ba7dfff2c15d2e57333d3cfebcfe90205961a5dc5d2a38fd8697221b8f2dac5a09b412157ca7ad8eb76b11dcc92415075c5da93aaba20c8378e34684531dbccf964dc69daedb331b1ddb7e9b8d5e314f410a94811e3301d5d64c6d42bfb97bb1f9f31b943fc8d21f1dcaa4467f1133fec0b75d0d06a54140cc281d625478a856bb5556379315224876a1b389247e6fb6d64a4fd479f67ce9cabe8fbb06c50a313114ef4aaed5dba0e981e89c406e961cd84bd9b0031e46046c08fb624e3bc0692d4655ee009ef5fbf4378dfab48adad4704d029592071d84d61de3a8bc3973fd2976d70adb1bad0e1a4625029d55aeb2968f22fd2de227b8b67f9a04c40d92677002e480c650d968a61d19acacce457af775b6be6e311e233e6d91d7f11079f427ff85c937a42f65bbf6bd4f0c943f37627b1091f653c0c5dfa09d6b716dfded8cd4bc30eef73280a850be54e0a9ce54971703bb239d0f03584ae18b392816d84097f52560bba58d989c5e5a2fa4f19497502d848c9c32de16595b2170e1c8b610efbf7dd471ab4622b7e88e3cde95c031b1068560310148a391fbbeb9b6f8ab683d41e7f0af6e19e9d6e3d3b2954ecb264fcc7a6a5dca0f376160465a4637bd8eb6dccae22d8c06589c333c23b2e0b8d3bd2626e49ff0b266bad3148a3e2539f0122d8d3f3701d018cb5bb027ee11d9934f1181472d29e9a0e4231909d21e22bd426dfb61c9d364c121220511d4a6a614a152a4aee5038fb669b20d2756ee6fdb2b3fc41d677f52ba1e80ac4664d351a01374da36586af9a7367c257db25dd18b70ab65f5485f653a36e2addfa28e5603d4f6e2e8d8a1a06ee0f339cb5b5a72951e1b90ddf4602249ab18f0fd0dc7fbb1c0a1e69459e584dea3e09eace2096a9f8e30edd38e359659446df70a579dde5d40c31d0a9bb1c44885a1d45bd361d1977563dd4e47211f25c0a922b0062d1f2d67a5198bef67529a86dc0e1b84a03e5972caa07251e4ed2b72410f88035318202263dc59d8c92199ca6aa502f8f401cca91ea40420a6c7425b240c47cd0065a2d7d39a28eee2aec093c849cffc0074fa465934ac1accb577c0f52efc4eb77be9f4f4998eaa356b14b9036ef2e17215ebb19d2729ec69c8c27faed60204eaffe072d5755fdc8ec29dc3ebee087b3f03f12eafd5ae1902877d8a9d3e12d33a68c090de5b994e55718fabc88270f86731ceb3c976b306f0680446eccf88afa3a2b90b405871fc477fb235ae83395228516c4678d8b4a120fd0fd19aae3365e0f475ee7c16344d00c06a08bfae302793dd1bb3c8ad5157a0ad2080780da95ffd2f4163670db532e39df87f0e7f9b8ee05cb794ecd3d98a3ebfcbedd28d50f0436d1c051e4f7c6963e6b23e65ccf9a83db5dd11117c8adf36a7373bfc88312340b4cb359d3ea6f687d6304201783a34857e11a86563a391cb3c98ffdebab62ecb91b67aae02948e6f66e35cb8c8c18886d7227d3491855e182d2f0c13a4eab0a87f854b24f6fa3c665d3f33e512dac7cd06dbc7980bf5101d15281cbc51d9daa19d24de6418ee6eb14f4c3cb3933e8410caa07004615b0d51868a1c60c692a598f43aa882a68bd11053f450d40e534302af5aaaf8479ff7708ee21cc7cd789db598ada0e056dfc7f4cc0ed43a23a9f9d206a444da68cc2d1bea545ca8d02c66e8a578ab5285dfcc1c57a7cc6b9d3be70f4373ad30d3fe159ce6ceced5dcc7881e7ba7f50cc14d5f4f4eb2004ad903f919fa223d8cb36cbc118c6218d72017b6e095c36826fe1b08bf077ecc41f4fb6f050aa2b6d1173df14a51fa3c98d04e42224da47b72782db1988eae4e2677b8530c6bd2ead1eb61c8f7de9199bd28dd7eb770fa1fb2db0e6f972627317a3cf2c1defa182761158b06cfd626652192a5ef2dc09896f0bdfcf96b7a9f6f8a412f250b8bb737d1277c42702e78e573c9a0e5d4723f9c0941a016a435f90b6a495cf51e896ae0cc3c9e92c3bdfabc1a97d2a11e655261f7705d01092315411f7f57b31e452ee94c87e8e1e197518bc6999f3b3ecfa0c1bf2e5005d2cdf71bf91a93341277b9806466e32291f1b4db0b420566ba1d68db2ab8ca21b239fec4d5cf6881a57bc452712bbdd38c92d112760f6d8aa044b90108ab263d4f7bc0fa08fe0785c9e74ad510512434e3ac4b8af0e87b440c94a10db008fa689ad5702d150c3b1ad77daf47f84faa6eec8056d1e56e54ffbce1d77fde57dcdb14c34ace6d0551ffe0cbc33966b689fe30ccd0e20176e26f3b307465b3fb6973fe4a44931dbfba155aa031105fa34aa7f7ce9ce51259042ecc53ef45b1aa6def3f96637da2b61aeac91e93c704701f40a7acf9a72e83a6a8d8f509f504a39d776b00773ce88d70c9beb52551311a57786368bb3b8457f6a233f1a8d7327f0bdd486470fddb53b92b9f500e5e11c9f7b6c6db4af0461080a7364557a92bea504cf09723fb04fa084fb8403132860dc02dfb626a2649fb9b850db379bc6fb9c114ea28e47e580bea3b145dc13f6a31430ffb7b3fa03cde8f337b90873dcb99f985be551e382ddca61ef02fc4d8facfcc7caf28777c13f876483c7e5d208b154eae170f785b6fbb7aaac86f52c845e695289ad7ea1b82650d99f1f1a6f0b254e997816a6b6a2a7844cf69ece7f411a56718e8244c58c896010e34592b97458d8d54e90882ad0fe5f233d45adece7b64b24cd009a7e55e9a7f7234fedfbfa7bd4a079913638d907256dda8a57ac0385c8a240a7eb9b88a61bb1f6d33f447812af5a533ab1b6a09a6aaccf9bf9429b01695f4754bfe69b7d790b1145adf59c97930d472a15d1a7762e2feb0ed6eb473c67a2d286cb99a246f9142354524679f3fb5ea148b6c03224a7dc1518d6e72e414e11bf368eb29cd3fd98987d713b7d9707d57ff975a91d2f71ec5500f6add40b18470e54282f8ed9befbac4912da74d9a37dce2389bf7c929fda00f8ceefb0c07cb4df7ad675b5bc8f6543ab0918fa5b65f68fcb4870081daadc18f49699688af7a066de37d8031c1bfa6776a6c3671ca1610c41e44bc8b2966fe440b5d7d6cf0929f6a1cecc71fefb74dc0bde039120200b2a2d6aff1417106664aa9eb97ddc1e133768ba67e0aa47bd1c1e2f36d3b45630b4a9735a82f3d8cc1ef8148fd9c2ed6ddd0297132d27e38cc28b5461296dd5c814f78e1bc82188a96636acd63319ed23ada66031dde219c67f0ed88cc1d230d31b26d2cbebd3b8c66ead4ff0be5347bc4e73c73c753328d33f6547f50889ba2fd06ba77c75d3a05d969fd0f63bbb2c4d2c0951c523530e67bcb576d7142f57c50a409046e81c9eb3801195d2398af328e2d337890730fed42d2735562965f88614e9a643c45134a69d15b0be230f64d06bebb3936454382bb6497fbe28cad2d68fb149086e1332b2f49db8e059c3fe461bc373284e66ac67a163e59c9ea0da7e1a1911ce45b58dec07b865fc526180d54ff0d542d2113156b651bb77f9e604b7c755d14252bc19d58236b364dbd58402feb4723804b4468e7090e871b6c27439896555eecbfbf1c043e9f0a9c420f794ceaf97bafe347c606fe738b929757d4853d8aaad5a39fadef5d51d8bfb5ca138c315af6deaf4ecd9334137fc0d4f606e5e314241a5335f67481f530ca37ed572cb8e4e7f17827bd2dc902adc43f0f5d23442838a52e80ac513c88f7030136c258014e102b0610aee0a10195a1c0e9efe76b87916e85e8173051f0cd8cd317140be8ae15e1ddc398cb5c6b3a123a19086215817f106f382e986cab6145f3060495c460f91b9fdcb2c182d3d2c536f216c6f56065b69d380ac6ca31cdefd40db8923893470f13a4738eb852685a3952839a4a186505e498d471fb9c44ac5c54b6c8a4c3277f6b31c7ff480f8491481603e0c9baf01ca22b0e7f4c415e22a1ca896a924954b69d00f664d2f337488dd1264dbb1045fa8222d748ca66476f88818a53167d2e8529a0963885a8a43b12eea0055fe124e818f3d19fdc7301797ad8e9754e47e3b4e5f1f742a4cc2bfdcdfa37603369036a2e7437fd9ba43e5a3b6b2b35f09f1f091ba27bfa098ed66b14563b32a143e1e83133b693675a96d61e436b41ccc6e71c748cf504fbbfdb48bef65b2f00d6c61ce941711d35f6bd2def6e71056292a0c957ce769c69248d7ac129fefc6a70ed39278e3b5a000b878424e1d8eace2830d3028c23bc567cf8270dabf43d5e0754305a4b73660c115836960560fcbd422f307b67fcf9232a8289595e8254cea16e35c2343a9124286f18e7d22634a740f528f46e71af4522b44b951af07baf3e874f5fd40947d902e592535c82e3354f69707e371bd359d8ca635deb8098bc8bc2b578dc8625306c71a791f26fdb93787172965057fead2bad6036672f24cc4e2146817a2be99172796f737670996db9d7e1c9556c7f32537c1aecf09fd72b15282eaa996f30d99c2436815960f0774da2012dcf743344c5dfad438b817226c3bb9dc42cd431f584e033a76f88cfd22b15cdcb6f2d97d81728dd0134052cde1110ae8e3fd3098d1d865f1f1a1cd22ca43d0cfeaa8204fabcd328c907552e6d5b3b4f538709b96306a107afc960019f0f598a14cf97539865d6a7c90b9cd7ed956b0f9906e229ffb65d069f0bd11bc1ce2342910a3335a682b337f142a9450248bab27980cd8683aff4e4ad5ad42ff157f00bfb9fe591ed384f91e39faec617a57885813f695ca9dae0c31c4562701882756e4f810b792c6030780a32941dd0b91294533040fece22e608e007d6030902691c00c7791dafb5b7214a65040652d956f7781cb7d5972274dafea8c1bdee3a6456efd9a4e015e28a2059f3f00f8e28121256f22bd2c16a06f03d0dd9c4c8166d26aaa04ac303191a94d24a35ddc584082c17800a97348046e6a6e86c203a2f796c1c9293c7e51776a3998dc2c384aaeafd4928b4ea6425e4d1be2b50b758774a66168f00022e9128467f1689e2efd0f61f99f43364c53d27c7972340abb62f079dec04effb53b6386fcc5ddcb122ea732ed8cf891b3674fbea642bcc7311d3a9d36dd3bfdc45de1ee2741c473a161ddaa2ea7b5d3e6a9ba04cc14179e31d5e1343d3691ab84de35c95651b88986f0a40816e9ecf25f589344a9ca793a00ab2c6aeaf796e873cb3c2575e105ecdea6088ef6908cdeb5cf750745780a4119f591a853f1b3e0574547f433262f33f9e3a13c96448e0c2c427e1e6bcc16f7e927ab376f418d7bc660e53fbb1309c57c6df1b77e9c45f8e683ea34d3a1891640168bdc2dcefa43f66f8f1d61c530bfbb15c9dd5bfa8300dc5e61927e075b3a79651269d6cdf661c16686ae7fa37d022db92dd8073526c7571ed7f61e00b6d9ab98824dd669427fa83ebc93f446b134fd96a63549b1a88af2e9e6885ce77df3da35f555c31987a60f328314d38207cdc10e3a9ab425c68ab43e741fe43428b408e8f449688f2ac83de7857e0623957c11cd0b2af31b80a65788d3bc9f89b710bfffa4a0e447c9f6e6da77622193421a3767ce37e327e9bc2c9f34b365c6a7a52feeead7bbf10e477629683b30bf7d2f3ccdcd5e5b8f0d735e0eb787a053bb37dffafdd52cae575926295be3e9101fa12e9cc19f244a8bc4d46067091513c4173fb9c0952fe37c7a7ee3be2fc354192e467a13d90da2d1abb0f2ced451477e3fb9a5f21341ce63e03f8e8d489cfd96804917b38c58b06e1c0dc67a39bfbf019dc5c7c110c9079092a9f2226c7f5930873c055b70da3d90378d6f1e54e7c903f30d6a7379cfba58712bfd9abaa9becf9aeabb9a6e365c069881fdb536d8d599ef0a343917327d5813ce95868fcd8910b5d518c315e98a926bf82eec0c57e00d976285b1710c94bb0604909cc57903be870c91db3a83da4ade104c3094fe0737fe266c6571a6946ce937ee314b8185f0ba8553c9927a7212f0a4ca1b49c50e80789ea7ed440d853b3f7445ede065ca8c5f6432426b88612192270191240f25c428b7c10ffa9cda298844900d0e410febc1fb99004a19a9e0f6fcafe938b3b8535a3e2ebd6a9ded44c45912df6935b5b65af4c0b284c218f0a5cb984011234c2fac8e83442563dd130117fa736cb17ab60351d5e75ed0629c2e1e608424d1c16e0028a3c64af609588e97e68cac815b1de7277336a5d16b39e4fb0db3caac2a0c33e620ecdf217c3f002000d0792f9e958ed728381d0c9d4269647eef016ddc57ea598f78bf369892fe8edc8e6f0951246f4cdf659797537407c6d81757861591472d6d8f94fa7bf9662fc15f5ea36d1641c6567259dbca4ab09401126c3755af9c827ac6f8d16fed3c13e3a31bba22aa1af84f2319a3244ec4dacb0ed05f69ed8728ceeadfe26a1ffdeb742ed948357df71dcdb5ce634e44c2df92349db021ca3e472a91d94be69d4ca992f080011a0994c61723cad8ec07940bba57e3c9bfe1a67e3682296b1558eeb64c94d30b4de569e6a509d1a713a6fddf9ebc056f7514d4dcce66decbcf3bd60612d39acb4bb76a32b437659ed805fcfda3693d0d23a8987107804a3ff177992a56ec474eebb5f8b311ea1695440adc63a5ddd5adec24c8b9d8ea7e90996b92c845edc27d77e47ee22f247de446dafd84b52934d17908f1cd9ae9c1c9b4605699fa2b2b0f7275d133946802caec370231d9317c7ce221ae0be652af9b1fa3699abc7fa49de88550ef0bd0d75fd7c86ea9d016d878ca3ca8fd44e010fa775fd0dab513272b51e45098ddede647c01a581ecf16fb0f739f4991748fc4e911107aeb3bd41d124a22bb0d9d77364b51fa86c187bf578ba1d603367d0d20805b2201cc3d59194d7cfd93802ff225c036f653600457046e2842bb5549bee867d8a0490276af27e57fa153182b54f45f697cf90b4e27713228db22c89ca3b85ce919c097339fdcc08d2c949e1c0b99eaff33113d828db5e1cce1c2ebd70e5940fcbeec32e0540f4919e1ddc795d2bed3643587da7f73c1df90902074cba8cddc499331c91b3c9592cf61816a60bd35e6f96f6ff390a6465175021f4cf4dd3e453926ee5fc56c0fcccd5535397b90ae5523973e9e8fdfe8633c4497ef09c714629a04c5844dd8613f7ff5915b86971d065c1f7e1e0c97d4f633bc07d5618ac6049bafb095eb845620632f9acb0196a00e26437533d51db517c81676a056dac5921d82d6e5c5132b9b4a280f93892e3b80435a25fcf557e3ae262cb2ada93e7f01c1885ad249fc4102356508ecb9dc46e1d11aa4f62df57bec69ca46a9838e05cbeb975cc6dc84c09a67b3cc863d6893d6deb460198b8974b0addda3df43b54088bb5c4a3a43db99f9b150b671d49fae4a30f07b7de89beba74fd3b28b5ea5b2f1db4766d533c9c3380312d4c18630f21216cb2f521db814c7f4daf5b62eeb8fd531ad20bf3d0754b1746696e6c255651c1165108a5dd7934a1a4911f4ec11431a5e48796d7312c8f65914c3c94bcb08637c0982765096c88ea3ec69c1b380275d2f8332fcd2ccd9854eea6ce7c248bcb6d6c87a9c1d953c3a9ebdabb93ec7b1885a6c83e1e3223e135a6bc5bc461b2e1d8ea7e8b315d630620849784e9c0b058458e2e8cda9a80c27c0509b82ee758a3449646f4f1ace231e4c52727804c5ece0cad3a1e70e1eaf5909efa8205b952895941bb22424179eaf690848a118cf5c24b0a067f7929c50902f6eb7d2e6420c3d77375838d7b7acd294fbfc9d6f665020cab4c0a0a342653206c47c3fd4b66fa515f6f9a1bbea332f6ab3077a2d7c99d88916042f85dfff8cd45858260c2044e287cc5d758595ad23004d383536a6cc07a4a0ff20d73ed71c2a37925fd9840c223e2f253c542a0f6b466cba5d35d5cf90ee0d97addc3dda27b86a012fb8388d6d7a45e459452f0668a7d6d48f71327ec26d9f278123e977597c22651b549e3a0b5bbf134d60ecf8a2b2046224829b65a491c3619e89d4189769e7b6c3a3785dccb46b8fc0c27f1b908cd80a50bda46937f1eeba951cf06c894fd00512340846ddcd2df5235b129c7d5308607a413c809de99e74b9a8de13d9e0dca6cef03b077d6c0eccdfbd85159f348bcaa1444309bceeabff4cb0415438cf68e2be01e0c862d22a16c754c1fbed8254d29fb8d722009d09450d06f0e4c8927b088e547517423fc3766b7d946ac05619ea41ff0878b5493ecf8f3c7045c737f29a23881a912bdaa2ab9336d0c5fd8929ab2bd57345f4bf9ddd8e237db6380532d5f26be4f96a742fbfd67184bbffe86e2bb4ff3cb3a1d2a4845788206f83dc9268226a5197315cf4972ac7caff64ce73187c5f868f76ddf6596d00434adb3782e34792660a90d1a3be1de7fd764005758f0e720019a29412ea4454153af4995303d7f075df73d960d47b465d1598d516b59e9e0b37c670f0a0056b9df60134cf0d03e35e703d49db62360b115c4dbf6d1a6a5fef159bc349854d510e4cb17c395677cddb72d515aee008d5b30fa7b4cdb77a06337b59ca7a7b20a06f3788eec7bcd48637bef0cf11a297649a7e9ec9af0f89a3beadb40379190b2b105dbd0b9a4e9485cd3b8f81b28979cc0bfc82afe99e35b10e1c76e1ada727e58282750d15d60aa72ae54a034cb77a29b584d93f069cde1399625f5d8ee263aa5e9e6fc551a1ba6cd9f37a1aa48418d6f72308f6cf5af9e6ee77ec016276e469a214e0dfd2fde9e27900987587a8463dc694dee09e1891a511a1f9c7b3617649ad98c8cb5c6025887ebd6e832db1c8645007086b410431b093879023a0538d75f9f126b77bb458268bb7ff3610094bfd0fdaf1cb4d28eb5f9dc27996346b88cbef637fd9c5c4be10a5e91f51702586f3c1e06dafb68745d9aba3aff71d92c3adea39bfb070572edf13c40dfc4a709d8898119e1a0ff2b066391c1ae5e68c97d1a8d4ad53644f383ca1d021ec604430b0151d2b26a9829c34bcd99006900789eca388b057b0d3ab96ad398016ca665ea5513b8edcad347f1ff380488429f4474cdbdbced8f4b1da08a414be2c6fbc1aacccdb58fefbb8adce887f7f2bce40ec412d6b6a12703ff70f367725a340daa09de13569def014da0e9b45b77725e589517eaab0f5d69ba0a2aa36877de0c3399985776fbbf92322199de81e7975067629201e2e4425e75987704d0b443647393ac99892b153d7b753fdd3d9a9b58c04bff05bd5ea66abd6700594d876f67e328ef718b559857de3ebcbbc3b31064210085554ad13cfc5460e08432232b477d340e3b4ac9e0b659e27b0da38aae483659816dfff1bd0b862a07d1ba7a9099737753177ae725f864ec11231faf8a1aaec8b5eea25c67034404d854cae5857b82d65a399817471e0b7683827ca73417ed86e14b6d768998ce38f4e55240ad5f6176c07f1a1334ddccab6684689058714557a0f8945beec8a5793cc4fad230d4f28b1a269f51ea1d6e06007de7e6b3778eaaa94ec7d0c2376fb25a7d642519b9202662382141ccef945399738150c01431ccaf82022a280c8e1405ee8fd267cdaebf615f2f4852ea6f3f1d4a8df4aae55715cc78939a7ef578ebe958b277bd71f2abc8586ae902949efaa327df4402e3059097da6a29a648bb4141da97190a9a57d1cda83bb8c4c9adaf909d3ec1471b0ce310098ce8cd9606255ac25751eca3d5b18a034ac2915b6fc5d1dfcb44035b52dfb58a193a6ba5fe06c96d9f3339aa76a52c6669628e4ba82f5ad1f3666bfb7be1a6328a2272073d06704ecf76273b0bd5414d2fcd923f196c372ed834bd6125a0caac88794db7ff2866f4d7afdbf3c21b1da748e202a63a73e6da0762929151d2598ef65589ff456a9ee066f555e898e40735e7527b4d2d4dc5a32cd61d3300973f0a748316e7021c3e3c2f3f489da35d4ec35a9581450ac7eaee00a89340615d190ed7fccc2103c0f7215c0743323e4c6e5da66841bfcec3af6294fb482d77d6e30f4119d53d6c14bd645398bbd4940839c98183eabaa36b11422107b789d11f3c5b5f0e461381d4d412ec605c6e11925c5d146efb227dc7220d27c732ac5cbd2c2cebe8528e878adde06819f6832bdcab56dc95be455cdf1abe3306fb6a59ef6d4ab3dd035f5833a24ec953b24ba9137a660ec2abd5b996e2b3b50f289c11f33918ac2de4c5c4f0915b6cf87c496c969737ee5b9c7a053b8ff6ccf5d2d9e00dac86de87a4b8509b08a188bc4f4c07a87ecad654ef9874f2f5de163ab80f72fe42ddb6d5f4f2fecf7733092ec44280169dc88c22828ba35018ccde038418fccac0553eb7ed5a5c6b2d287ed4732a43586c4bd30920fd9d0df3a61d185f53d3d7280740bd33976362a7f85773c9d2cfd17725bb124c753e00e8211ce368da3e2fe5ffab694fd8f2b3231dd91e3085c7c83135a5aadc2f21df7d5303f38efadcbd69a2784cbe05a9ba8b1fca29294254577b8287520913ec0c904714ebe42bd5fdfaaaf6ac2634445a50336ffda1ce579f5d773210b8a065a1cf277fcf58b59990c01bae5a1354f8f3bcf4b50a663b1dd98f1c3982e011cd73bb3923fd40ac771c8932fc0517ad1cb4c0875d3da6c25980ca2dcceb2dead799d86495cbf25f3ff88fd480036bdd266d898bad20e8dc97940e990bb581e627bae835e5114b3b3ddcae2c66d54b10ed8561bd4591e96f69b9719a7ee7a3d539c1ef38fc27d80c96c4c05d71136a6d080bd3772abd3f43605ba055c38a61d16fdf624aafb0edfbae6a191e08b3d4d06da0b9078fa31df413ff5ebb32d4f7ba3d995a4a07401bf49a96282862c178f666ecfbe5e34df3bf5569d8b9b6185d672eb1757aff4d599b58e91791b11d7c35bc61710f839d315ba2add74e7050385b3c1c39a8496d9a53f265818e39d82522ab6d8d13f5d36109e38e4619f1639d70c6b0625a599f219696005e44c0d61b1c8bda6884ac9681f0e1b19cb2cf0a01cfdc85fe713b034eca79e5b062e26aa0984acba539568036356e6763201c50cef9eef60ab00421e7bf0f619aad6a3c1d3dc165fe849cdd361487931a42bc79231ad9edf1b0b0b2d9b233b499310130055b6860f20488b067330b48e240e2f7eec6319f5dfddd83d4d236f825ee4ddfa0dd1e5e710e2a51c68bf1d625b5157eb0552024220f1c2a552ea58f270f6e5c9101ec38bf50289df9b2f316866b7fe2d78a0c384014f521b27b49fb3007ac0fcef7596e64a516e028fa7b4a1ece251e8527d5e20f874560f3218f664e8a38ff514d53eed44ae59cf75d0af908cbb67ee035821696ef0993608695c16c5c524faefcf4bd4403f2559aa63ca1fa44d710afcf9a8dc64c8bf5351552e8720f4913fcc3ab6e9d55485b473f29e0b79c72f927053cc889b82eee73353ca5e1d17a2841cb41f1b4b81fa70d6f157e364ff11dca40dcd6bc844373d3412826261edcbe9b0d1b912c0d8e86a271093d8006c05034dad47f0ece2ed9bb4a58ac61fdf32744a1d0c92e912f27f86ecb0122b410167dcb31eeba1dcc2b624dffa3425a4b59f72b9a6f83f84c90035fadb58474fa94a2fd607733e22524ccb675be2766672e3493707bc9fdf96b8f01b836ed67f83d290803ca8eda177e85f3aa43b63503e5786bf497e6e9153e04e2ee502f83f65296b82f7b72b81743fd05c9ab65c559b54db0b0f1c97dbe288b28387ead5bb29d51163876c73ff4f5e56851218782bfb3228cc544a7033a992634ea6f4eb16b503509c5b4a31a42889587b86ce780b3e60a8ea35a1a81c329d97e77346301bb48ed413f4692b77d01c3e8867febbb59f2676011597f0b809a224be9bc05091761794c0219d8e29d175a66463583b5915da3ae96c068effd336c7b33a49945f3ed6b2e7f2b9901fd2eb931c73bba389ccaaec298d72061b7b7386d63778657700fb50a580b1532d50501e380f081b13452f0ddd39e2202af206839991d9cd966644809f26eb89121165c8c37f80ee30a253e95524aeab9e19880c62d130f6d38c13af7a43fab8d7b30481357cd6fe2d400046e82a86b67313d2c6d34f93a03bc4ae2ac159bfd7605dc6dd47bb53994b384cb1b21a1caa100af11a8b56f6c6e9a7fbea084865460e49144d8015902aa948b9fb831a661f1057f7e7df5df7a192619a697c1c00d1fd081da45387eb825830d982f4c40e3e04544db904363495007df4dbe1875a4f806254859b6f3d4164f0dd5e8d2c8003ca9f9db34f452fc51b66f3a545155c6c793e5c8af207c01899edc5125e86dfbcbccefe9a9803045dd1a5f6efdc5afd50a1b8fcbc66f9993b2deaaca89de824be262149f7f64cdc3b977225afc2aacc9512f27e594cf540f0c2564e1da267801e7a63c0fb5f4d89c7662771e34694116169d6488a854d244fddbef2e1b7e3b0d83d61b841c222b9836fe5268a4a573cd37c5feeda908af986477d4f5ec1e33f53eef1c7423a1c90ac627f4bed2a0fb1566f02e935e680891b70b821de0eccd1dccbbd1fe1354b4093c41aa4a4c352148551629055416c12611dc1a43d3c696d38f1bcd9020583c2e205b53ce55cc6542e59a9225123410ed7bb78c5c512141f322fa4efbae7db582e8a86bda4b18fe92b3bd7c11ed0864bb951ed8abaeab8f84fada82c7b9821760af4ac39144c125dbacc1f5e0f811dc38a954b548aa7f8b146898e4c06d318c9ebad7c9116652b263d459bb76e5924e2c2cccab0a79c2e891d250b315da9d424b93cc405cccab2d93a5ad453578e11059e8a1dd745fa97d3e04c84660120306840f49c293fce60f1a85abd66d77b594c5ee59e534c0dabad5b05c6a7348b0197aa1ff34e8801ef3ddbdfaeaeabc00bf0380df13c0c2e3fa6a5775434a530eb0dc9061700c541df6279548251af9da30827aeb24823493b63a2629e3f441a2bf684b2f836f56659a1ab78ad60401a7be1f174c67f3c27eec17d1daa56dc919e3f6e053b38cb9ddda7f4fae78a23832440c8ff407781525cfe42d87346ed79ab72ce730b9a43bc9fae64558925e7d3dee5c2835618a77ace3027ed7e856e41e994672a9b681abcbaf0276fd896a3236a9c76a42d7e922e0139d59d812c32f50fad9d68b4b2380b4036d0c77ba42f34d66e015825cff87b31323837211457365b6738227d6e29d8cc9715bbcbdd67be13f6412992c5226abdf4718cf09a083f29b0a625cd3ed5f902b9d725b3f55bdd69ac4cb85ad2bbd75d9364e29754cd4237c7d5df11b0fed939e960468e0e95bbf9872483a291d08d793946e459b2aa81ff9c853dba498a1c866668f786f9f25314f8c69eb8c8fd1ff224fce86f9a9d141eaa05c1f0e0e7a1d709436cbc9f7bc480081c5e302992edf13a5cc67adc53f3d53d230156fe01ad11764651824c4ea8f3bb75c6e4bc054f71b5b2b693701a0426bd863d3518884503fbbd18e8c209649b8085d5dfceea2ab891201c66dd8b8b1562f0e9cff33ca639ac0fe3bd8673ab93715a007a20434d4c7cf33dd0e4c074d69ef80ae65199f17ca1400b359e8bd9ea838bba59354b033c186136ebb44a1f83960ce66810be6d33ee4e89b3214bae0f8281a63c2c86a149f030e3d19faca2e60d4e159df60f7368f2912b3ea7c0471895900b1c3d102c4c7a57a9aad29827a99af789a47f518c7d6af17e68afa9cf93f67db9214772c139ada7e00243d74759024cb58214d4dc26800936e60b9805bdac5bdbcf005a7ec5df5eb92ffb64766e9b2d867149f4271ee0fb17bfa5e37b5f40574c43d887a86bd84262b3c83ce9164f406b1d85b50ed016f15ca00329d6a8a9c6dc98b3d625c573c911c3b6c458aeeea310c828717ecb2888ac460099519b8c76496991c8f1356dad2dd80cdd863991dad666360f481fed901e43190cd661bcdd2af7b051978d471d9d5f2324e9becb2c478f403ffea69702edb7d60f331bfd19e6e552df6d34d80ea723fd7cf06f6a1689bf0a1a45906ed3ba29d2c7b18f839b44b95e28c3fbfa8fa2f76003bb6ba14a6aa5c86cfa87b338ce2bed54eaa166886a114184b7ef903521ec724ed1c56eda1a8b50615447074ad5ee2104d3c9f8d950c6213fc52efa7447778a8b33e75221f143266055859d2b18a86f0766ac31954038be33bb25d852caba8b0ae4591f1e9c98e071b5817f1074fdb1584d1e864bc7f31032e5842ec354e576f651a7d1011b8209aff316e452e858c2a8ba54550685a4c30bd43fcafd81c467f5335e78ac4d7201f6c8c5219ac84fd00f6c8c48916622f9f6e7e3ecc5b5ec90c71fea70674efa9c72300f5e6f8310f2d27a34624779f6ad1f1ea3b26bff8b0687fadfe8f215ea189c5680636a7b8128d463dc3bef1a92f28f54ce9a96212712ddbce74caa289e5144447438d6ed420409c8b0997fd6149e88ae8e1beefc4452c5e5bb4fdad04cb52f4dcaffa9560d8fc1dfc8208aec07e39825b81a9b139c7e3b9671eeb14345294cb47027bb36726e5fcb6dcc9994cf4f2e14593fd20a0408e465386f54b4f15fad55db3496cd7e04d501434505b3f0bc565469d9eb6e5bccbee662c02788483397c3d2ebed84c3bc9560e0ba986705bc54cb1fa55baf861a21fd5eec67a6bf6740f9c580def66a39aeed974f576d1f45cc28d92abcf71a22b72ab7bac6b83cbd0b07d10bf2a06ad46cdfe5a7c84beddf3f5ed52cf1fb7d100f310cae3aa40932e9a2d93c91cb89d39e372a58d04d002f890d979138738312094de7cb61ac086ff06897bb7338493ef9b3ce1944311596c6aad2bd226b8428262a4f4b2fee22f8548e6a2ad31f8a678db180e984a0eeaabcfd2b7e0ccbde3cc5f91eb987861a28354c60fb7b0491c4b4216d2fee83b0f519f45206f33e914fa29f340da844abe86df04589ffadb3bcd500f6fb9ecce4bd8fafd65688b8aa15cff14888058ceaf5089f4a40e6ec04104f4b31c2e4a59ed150bc1b371a900c9cf14c8ec133d3a86caa2f4c41b50b492aabd794002a44655ac40105b94c2168e4f2d7b628bd72467c47e0792debc68a2b5cc091bc39934d9b1228a489140fa5200f69d3232258e69148b15894b54f13f2bd9be6a82067419d7791720f3ee7f36b4f92c5753fd07971e73ea84a0408155fdb09dfa3f05972f857adc298b86497d5043fe3d7161ef507914c54f4fa2876496be3a9687a97c7bb1bac96dbcea93b0db02a3eb51377abeb90248b60e40d965127c940ec4afc496a43475e7e47efbe7d824287414f3e5de9315eaa7709cfc60bcf1f268a8648c173fe9185b2cf6f87e4570ac249cd0c7ee948df5219281fd825a1cb79642b78de177772ee205b31c200424de53b40baa0ff0a7d7b7f3192771562c8cbd736543e0bc8cc769c70d5017f4aa5500b6ab8fd13d0ba713d7525ac03d7129ff237a3184a668af542a3bc69b8e71a2d41b2feaa07f8509fd51928a4b4a5b10356406865b12076294168393cf335518db366d2ff0548b317b8e7d01a72943a51ba23e4050421400e970e51e20ffc324efccd6c32a61a12067b728bad58472e48c5c2409be171889034593d453079a9ed97dd23706ca45149773f9f2361f87986f72c787a68a7c804c8db29cefa1615efc6d8997f923e4baaf7b439020dfb47596aaaf4664aa5a61c1cfc30bbabbcf712a0b54802e35cf22eb34f2d0ad84dac6b81b9c5487ee3950ae3d821299c3ea13f408aa0ac998cacfb31976594d783d6a7ee5904d0591eaa71a96bfb2be4d3bbcb15d910aaabdf249f5a32f3e7b124450eff265f760672b24799fa39da6b3cb96e1b8561f3ba105a4be137ce6c4f6f4e2b5b469ae11c30054f9aa747f43d07ff4a3b43ee7c68dad49697da587d63d78cdd59d745b921b62c75169066487e609b38216a89bca8c8b3d0ca43942b27f855d1ce1a1769d035e1386a4fd16602ff1050d43830f4a3f832f88b160f209022d20bb3290fc9bfbbe9eaaf2b1e87a60929c0846c47cfa306e2cc47a0047a323f0a9f26e3b7884936703c96daaf792e614700e5319d357f094672ac6d7424b297f839d12f0ae926a231baad81bd836a643c347ecda52695e1136a60aafa074a9a549cc021972e5980bae0f7b0151d5c966d820b793234e452b36a566241e3eee5ed65a3a835dd2f1c1a22cdc1a23e2fb7dfdb5736ed2f1c299f34e526c31e33f546f24ff8308d0965453a01dc010b9282579560d9ff1f1a89a2dc4912e81f8ba1489a276ea1e83fccc62ceb8059ad0727c6539c3ec9975ead5dcf7c595ac59479c28e513b47c3dbbd667fa56724fed3dac311c7b3cbc6c9ef8fde34cf86cf11bc06d02156815d5ce35569d54a754df2f99ae94dff307cbd7fd94dbebb7b234e5cab326fa0d34af7b617eb49a009df13e51b32dbb9ced15fe6fea59599790b671bdb8be0968a7cfd734be2581db135c61e8fe4ab02e402edbe8912a8d9cf94a7819694bc0b9133b3c08319abc36b4335c167023bc531d033f50309c2c1df1d8e6653df2d58cead2af6c0e038c0767fc5d4a0965e78eee944a8e4aca025ea4260384b7a24a64855fce3c5f34b4bddf4c3267ef03725cb960a00e2cc3709faaf22fde514ff4147f56233d2f3c17e7d4d31fe6d4913d2441eabbbf7173b48d6c5d0b7acd487682d4456378efba99e81b349a1689639cc2e3e036fd0aff97294037c68fad42a28b36cede371356392e7d5aa14e53d4bf4baa1fe5fff59dae54ec3ad8c676e802cd2f9c06d7ece7854c0e97f2b413132a91e2b0ebc70fce091b1aea94a8225e828c9597548882a05d475b44aa68ea2f6fbc8a023b73c3dea250a2e567f286895fd4b8aa912c8ab4fb35165f0d22ed6dfeebeeeca15457d7d8fdd63531d5e607ee7983acf554190c3cd46f797faba9e121f173a2cb4cb2eedf5af42ab7d77e51e8b67a191582c6f82413aa11dc42ad95a1359404dbd51f6a17e9c842512126cae5db79f35a8fd8becdcd3326e28eeacf8b8bf534b9bd5a4b47223da0493bdd73b3c92146daf8fe101659e7f02a568b3dbe556d84386007cb304d073029e21cb2a759ce9c4ce8016eaa43faacb0c1df2384f3b95bf30e8ad4b53ee7e95928ec12ef82029cf548d10decfb255275aaf78613ffd651b2fdd25d2471bf779be36221efe4eb59ec0b7aeb2f866d07e223d2bb64fc1fbb0d27df1753b7d51f22704eae28d1dc0ef93e35ceedbce58b895f1363aee00e57cb99838106650c4b04501b7135967369f41959f014b42a2b49308415ede13df399dbfed88ba2d08e774b959580aa036d0f3fcba36d92aa0d7a30fb1d061cefc9f93a585ed9ed6e5aeb179d5724d20f0c9533d7f158360168ad67a9ffd3c5f8e3a8b6d52bc26011e58822e30c74d315398defac1b3cdc2d7717eafeb05eab7c63fe5d0617c6de711d3fa210ed32ed731776caab5f80a1042d37ab66eb19b5f88bd3057cbd4ea9e7be875d6f969ea7d145b8d6509b74982eca9ede56c65eda1df44f02d3ca237b3679ff516fed6702fda1c8f7701b6d901956b29947bc7c7d3c3b638aaa014c57aace9e6243054c4a18fd95425d75b8ccbf2c9449bdabcc6d18205b8aa092a107f51f3aed70ca68386b6bb8954b1b7d91d107d0b4ba451b0ee1036e9377e904e2948f804a60cc143de86306550254a2e34f79628e30033ae11967ea7d9bf6ed43dea76365587a8c2bc9cf8ce7a662d5595ba597996a36c31811439bcb6202637c5461e6f88b5e2756125c91e0c18d51c18bffceccf9b40d278295b4ccbd6cfef8db9f3144132fd1fd4cda07a8fce8df94c2271ec11b6408b0ebbbab493e4724d70f5aeced9b78065439042341c3b08caae6b43bd55a54a8abc4027eb8b65b0c1d586e57a586a3fbde63bdd28251b34f0afc8f1d884a06eb97d02ca2baa25269e4b879b4d406377756c0a9ca8e088f688a26c3513edc58e8d0bc2c546a0fb937511ca5a418cafec070db28015d23de888d5fc6d867373d5e128d8168fd0cb8e18320bfa6d20d845402dc8f1fffea59b1524593b0b006022edb30152dd93c49211ce18ad52e5fed71449b21c3701a7207a4fd4ab28b9acbbf8bc6a2b7fc7c773157435f699a0496479aac1066874925ab0a86d39e75ba50a01b8d5c113581a9114287aafa40a1c79dc644461c25e09236c71f2023a12737f7ebc0a96c9257e237bfd5e9c9de54b8a0301b8d11b0b8699e0d9dca42cb236ba5294db9e820bd1382c9f097b5ec688ba01b01e8251454cb3c600a919d8fce89212457bb42238cae0201ea63d577f45c73caab77d616b25cfed53f86e9dbba4cc7783184832ea21f051ea889a4868640360e8f7bac52335ef351659aaf0aa1a728c89d5eb1782b85f55067d0d0f478df4f70eab4f350cecb91ff4b07f4b7b9c6277abed8be8c46488f995d4a420999c76fd54908d15935fccd501e6f07c84ea9151effdf2f2b74fdbed15f6dfc6ce91c0e2bc4c28664aef3cc5ed39d4212685a16958f8e52e472793ab9edbda1fa60f10200c10e4a53c089368f94707b2e7d5a8b25da2f7c3ce29cb788bc77616b6d21582b623ea31fd703768041e7d4145f9133d9a6428168edb00afb2422e20026665ccbef80467bb90efbb3ec18b41cf65068e3d7dd97330600d88a6222b73b3ea5859b7d3344c918723383493d4b24a78cdf7e7f402c629356c4eb31bc6c8740d9d1c05556c47b7a2f0bca5e6da0c44bc3f72a3a0693baa95b4fca4e8a9b554b9d48a039ef7478067b6297973dda779aabdc0515ff77bc0fe53f2f7056918724a345638b2ed046d13d15d7e4672d13d342c19ffbb1c185652c4f261054f4e679b2e20fd0229f11a6dd52a69e6577e1d1939c5658d87ff2860d02d0f01017b7830a26e3811728e0d274e082acfeb273d8bc72cd4f40232fa6dfc3cfbad5acd528ed5f0ed5fa66c9d61807e7412affc048658f6ee75ff51fe25dddc76e921591b5a9c4b915a5536c8b33418e4d06aa2a0a88f1996c2f05b03380cc29341744a097df770eaf1f9c27279c6f8521ef27d7834f45f445adddbc8503d978fa39212797cf4e6a0224756051c814953907bf77d48be2e562625471d1dc0723644fb9f18ff70da1dcf911cc028bb75345b150744d55b733732eb19978c5a64e9bd6566b708f85bd5c58d5c7ffaf40dde7a18bb1b0a902a0591b4cd3f5cda728b933f4b53a66645db4dff28247492ec3cef0cb8f9918dc097c97a868b92ee3497cc40b36b9e99cfb63e210b31ae6c173703380c28f96a4a1042ad17e257a20395f540197cbc3daf0619e889bfcea56088d3bd6d012c91dcfc38ebe2efc409b1fd8aacac65098f3da45b5a94aa7ace55dd2ce80da2d3e44014cd9f03a4fa2089bae96292e47cbcf099fa5844a55fd91c160396b61efa11a82ae2de1109010c796c9ac90255d7f748963691a26774659057401b1b85c50710145cc63e2d68f05b4522821e27c627c870242d44c56b27a1805e08b8c526263f3ec9fbddc571ff13972481ac5869cb82b1566e15b283dae8cbe0ec5b074f07d2ed068239a123ea394083b730af874e4fe99ae936ce257226f1b3aa176bc8a8a58c9ea1a7a67add05294440783e6459246edc983f9db2f7a8e99b0438668bec914ce8a214b32e2ec78680ecaca0d64073db83bacbd0809776f4460f1b3d039fabec78a5f84642cf58389f364e1266527a4bf2c46953f758016cbb287f5681fc19dabbada0805a7a4dea19b6ae2fdd0fd4afd8cd32b897d4b7fd934a99e098a0398a062022a4dfb399b83ba7a987deec26a512f5a369c2fe3d83e1057cc811aafc2e447569345ecbb5e608bbf2cc5886b2cb608e465ba489c695a811ce4a655c41bcd2a313298fb0da4e2896bc0a7fa523845537ac9dabe8dab1276e94f34e9a361572eb8fef1a91215410f0fc7c9b5dff532f0ecf091d7457ebf6e2d53914684010519e5fc5ec55d0fa2f781173f4a0f4e72661a2b0099d6048e34c436d5a35b23edb72ecdcec70360d5ef6503b02d3cdb8c65b1779d4e703b2884b7bb60f552976338af7d6765b7ca74e4631de142374352e6d43229afb099789548b64712a1759860e10a0c86a33dc3b6e668634f679220cc169b2940778bd6e23f5759ece03245119cc7522f20d1edd50b3ec5a0778844d436733fef46f4c538dcf0835bfb7f4eab136aecf064742f0f5d9c7a05124ac4dd819442e293629f90421af1e29f659c3a5db3aebc6d837a46c7019fb372c2bf4f075e5b397268e0286715b921ee9b5f6bddc3f293fec38e05d52e1fbf0afb53f52a57afae3e9d982fdb56536d32a2bbe363e1b50c64cac9472c92e30494b87b78a9657f1d8a1306258436c8368484673ea7aa1cf33d61c409d7fab372c8d759aab53a6e2a7474a962f006d7e2fb3a51f774ae0e89ee94ff043467115e37f48818c0eb44d2340647dcba867800c5ae20c37797dbfafd9036d019025eda5231931a498af09f378cabe57585793a22dbe93fc5ef511394b40de0ef8b6876264ce4601329d32b91f72f9dd3e718dd438da396e5067951254d7099c77d9406bd80f11321e250eddd5364d9ae5f1f9ffb05a47a0fa7dd1dbc8fca06422e27ba430b54a1ec781e8a0a638a1ead4fe9800719c590ab029be83e0975cf317000e7f0c98885db9f7ba8237912c9f4b248377e6fe0dc2458e1407f077d58730f8d9e95f0ec495029b47f1adcd9974cf9570f762d6d5382799fe597622e52ec543c7a2002029f44c70a948b05d48b63f77a9cb66edbb8a3e004de8795f1ce698b98f9a7b422f648e50cf21c7db6e2b8d7db0f120cb9a631410d88e41c339ee23ec3a540614518c88436960d51a5d8f43bf2fa6a8c9367e44032c9681bc807012a57ecc6454de370d6b29ba1a4f2632096486f7ba27524127ee473a9aa10e38042e4f42404591c034500be60f59e517bfbf758f7b57e86dfc1f605b1c9a61fa4cbcd7e0c1a311ebb87b0a17d3d0b560032fde4c87eea03d6f39889696ad141c64202ad849567b1763083aa8ad4de5c7a8c70e5b627ff1bff01e67b417db8aedc8fa4267dfd7d98142ee472f40d3cdfc782eb61e37d1e0a127920d26952bd29dd1c029570cae34976903c71783609e05e60852f254db00a8f7496be2c60bf140ab42fff13ba48e28a38dfffca037daebcbfbaf4f1ce4614ddd4d6300a3916c90e9b6a5aaf10c8e1f0092c4165a21e051d06094b0dbf31d2ad04bc71d9bd69a2afd4eb11aedced2e151475e689a63034f34b41a51b6165212f7a17e36f7e69d995f2f71a33387a741810f7435f66c3d1a140b78ff9674098ef3dd6b6e8853264cea273a24cb2e2486c6ea63bcb5da7d031f0c31971f1771532022d2a56c31332797aa36268bab59978b71d3c02bba20ae7f2aca6861de5fd622885fce6a3d9efa229997624fcc2d0c6a49ec3ca93d675904ac87ca8b5373552828f8631c0ede0309e47bdd1fe5ef28e49255d36813e15527f359d6f4064f2ee0c802a6062943212576d7fd6cd1ac7f6ef98258639e9737d0168a378f770d4f185af8fd17404cc9483bbd25423bc5673b17868414a0d17ebc21057fbfdb95a3a57b72ccf4ea3e8ef2b778ffc19f3024fb20f2a93d6033d608150d089ddbbe908d10a7164a1ffad3da2c67be2eaf5f430151bbc4987e022b683a6666186e05d4ce70147a8666d947ac7f00b0eff269eda9f89c6ae8f9e5664d0e2e3072f806065dc84ff7373be48807ed36c620a54ecbc714882528dfd953299e23f98430ae78adc8487335edecb24854b9e5a3c838b4088f668c604c2879ec60697f2949835180a3d13652daa221ea09e9656eaed5c7158c5cf64e05acdc747aeda66b38db710aa5af6413ca91b395a563ba09b68f40dd9fc237e7959e426ae6389b1f855e75a885c925fa3168d99179d3915695fd1a0949ba06f08b7ae5f430b3e29f743907fea50d219e8f8d15a93b535980542d58956fdc826063a7709257c792522a677135de5dd0f50489aec9d2385eea2054ebfb3d9cae3ea4bd658a7a811faf6bd6ba461e6d30d03139f980d9a692072a1e6baf9340131e294469536298a338a63e21c738a3062af5c64fe64678e438fd4cfb1e8352e9a2585d6c43e2d0ddcdcb01974ba848e5a5fd9b232e55aa99a34ee56f142bdf01cadd912bc6efe479910023a9465ca8271b01d0102e9094d05342dc3b1670fea355607987e59ca650ffb94ff5e54104b64d2857b744b7688c693bf060c1d9dd484844b411358ffc6e9ae6b9597282d7fb9177ec8d8292dc90f18b73b01a948f2b965c245dea66fd9ea204d00966e9eb7b90197177302cbbef3b34a1054bb4de83ffac4ab7bdad23021a34896083520b9c63e4d9a91d15b9c8eb095a87de5312abe0bd082979ad1016757c5470687f9b522efbe28387cf3f6e55969f1d62a8e6b7a8ab1175e5ef75017f451bb928635c0fa75f7f47ac6d875b130c57e8babfd1ba22ae401fc1129cc8a20883be6f2361b8c78be473814fb3ae0a47869beb7f1dc6d1aa41327161729964f57eea4a1a2f49e059e20cae95698d8373104be20ccdcb1ac9c07275a0d8c30da1d1f35e2ff1197cf9b71aec3cbf9e730640e4d04ef6f15995d35699b6659e21438cfbeeb5576ccaff92c9a01e5d911d633bb1b926707e70f65a92d338f07337176655ca2a60b67f2f24a82ce3d5a1723ba7eb27afabc5ce1298e75fb26a7a6e5ba0865b3a2ea48874555691f5d841ea01ea31800d85e4b3e6f5a5ac709a60cbbca826adfca48b903b3b17d936d03740473b9e6a28f6d6d56e24138564293e79862b68e0a850f056499c608054b50b65baa411d4acd7e813b4f754d3624c2db0781027e0a09ffe1c8861c7daf79fc60a711255b7415127806e317656e37d2230167f4cca273aa36ad719928ea4e926fbd183927f314b4e111ff37c5ec4c24f7c2c5e553108e4f66b09f3ba500a5196f808514bb5a7e37f464cd38b5b2bc11760121c6e4f19ce8d8ad118e8dd745815642b360da51d68be8539945622ad7c5ca224571f6e181693bc3ff89188f322e423efce229787bd3a130cd79f06eade0d017775ac980edcf2c046d8dda44178850d635d8f17880cc0745fec424d33d10813195d1d7f547d201e84b66da495008a05f0effa01449a8f77fc1c19986aa5f5d081b12edd0a7e7e9dc10b585143644c0bd9c8871836c32ec472e885c192fcae94e829518a1dd6e766839c1148a036da3a50e774ad51b6cd68332410ac2cbfc2ce16df2cff44536fb41371a55ef79de8c7efb8741b7edd85bf69a55211b13d63bee0667ed0a0d29f639df79e469c3171e67758059b8d0be35b2676cdbddf56d92706615607b0be32e6332e84668eb19a414877ef2645728f505206cba075d72a3a411baf2553f0cf9de74853259bec5f4d154f9dccf0aa0aabb54f0b1c319761b00fb2b7def2402488c58ba53dce52581a3c3dcc8aa962b53faeee9386f0271437858f1f17e575374d4f6104ccfe77d6f55428d6da7f7a32f0ed948460649a6bfc8550ea027870771700f1eee71861fa7c5c68a0fe589711d317f042e178b00068cf3175854ebeb2e0c764614cf0b5d16bc31fbfc7f8ee70e369d4fa41f2242a9b515132533fa7dea2957ab4290d4dd9814c7698af9e009511d5ed16201954ba5c66b5947cdfca9d219f8d89f1ae916327aa414c9549aa9b73061daadcf9996474f30bf1247b3de1eaf42eeebcd83140a15f6c5eef56661ee117a8b8709263062539d568245892786ad950ba172f158a9fe44ad1a64d084de34147ed5c12b299b4be52923fbb2939c703c94b8cb34fc7d27614d1ca7024a91315f4d63db68aad53ef06815a15982198771a299a01b8b3602bccd6012098b576f18f39682a493f7b808184d936c8e20e186c519a08b14756837775f119c352469e24bf61322d07df1a6215bb47b9967531c4948be1aad3f07964fc6cda1c087c42443ad01da61baa52c0744448c33fad0d64f51d70c27a98b0283106c1142b552703141c71de4791e3f01ecc8ea0c830ee3bcc3f7362f87f544ce657128839722737b443495734896d7511b84b78342133abd93e7d1497906b9592796b604b5ce7fa588cac3e52b77e915536878def7386fdaa4ad59b1c8197c83c8e9d9b3221c906dbaa28e2805d90af38ad7339644b841190685d5ffefe5c8059c5039295c2f1ae1a56c1572f4c691009d5fd4f5e2cfdbb6a8863acc6500a1d26de46b7c016d63a2fbdbdbed27a3675588a76d567471c2e43d56e30b51ada182ed7976b80dbcc6e1af6f08f1fd01760a935c0b95d6316b3b934e82fdbee01091f8352d647610dc8462a61e89b03988abe1aefb03c62fde38bc8acc8736d5bde5f2667f02f40f8100ecd9a3c027c83f8f698a1c246d4f910fd6a19cda26c8e0284e524d285337052b2a1e56a4d5709318a9d7e51ed3b604d0ab926bf8b560982bdb03195b3aa5decbdf7f7115391a9027b49faec1da5c70c4a5946e212b14a9512442114ad47d10ac6b246bae254533bf4f15e04c5ea57f7fadac3a704f0d3c713c6a65ca87ae9dbe266d7b6ca649d88e06b50296269894c3226b4815bc9465b6259d8e06cb18d291de9efc5fadb9fe14a332eb12dab6dcac673c2d99a695fde1505e0914b74bd5776e2dd299124d5ea8e3c5c3a3269d48791864bd8564d37e7bfb5c3647b2c4fcc5cee65a74a4c652bcea1aeabc905cd0388fddb0446d2636c5c669755f6d6059d296fd5773dfaad8f8906acadb8ea85db6b0bb32cfe390ab9519f98930df34c4721f2dcd7159c4ea3716893bf8c452c760503b5ca42611737ff28a0c67356deb1897e9e9deb3411128107a02418b079327fc83657b15a0b3c426605f4a553f2fcb92a64e48ff0eae952c7a5d94fecfcb99197b0233aab2347a31a0310c83af5f53de57af8725028085c40444e99a6042f162cc8cedc44f83a1625d2870d46b2117d7b14f4dbdf717b1af9d2499e30a822728ed1d6af2714d833e0916427d70f778a8c563b50a6283c6043f2b79ad1be1d66336d36f7f348c9cf9c1d0d22485442b73742bd886497cd2ddc792921d869c7b39fa8af6abf3c68ffe8c4e9c2b563128c8d5b955fbc0d4b493d8b05bd7780c6da6ac33ee6dce185cee93b0eb66a3c4045dcc2db3487e6d7e7ce3dd410b795ce7c54d733732e0ba97e6a50853c1c6a7dc54672301868a4a062739abac21d12828b56c603c91eff5240021b01742a83decc6b5e04014beb8808be5968cf7018d417c2e6381c084cffb280e047fc2223a1678355a6f9cfec8cfb38a79a00369629fa5d84ca7ae1d9b98bece639b284973dd09fd47494ee43de725a6ef2210e3a5708dfbace6b18b35f79355b12edb39b7f002c882dc6de25428d341e8a563d96c4eef99923ac977708cc43ddf94d1cbd91ac0e4fff09c828e084be9637f1a9a77614e7f020482d007245243d8ce609d3e9d4ff211479a0b43e5e85a8895ba7c7049e46f0f5636f7251fccbcfe454606bb53dd95774270e5c6899be9ea110b5fdf0eb0d4d4bb081d18c1f486d19e1523f368d0fd3777809821ba4f7ad1dcd45becdba61a64636d2845ca02bc0a1cd8fe451effd67d8ee1a329f0ad2014770ccec4cfce6160e8f18adeed726c349fc4ee02c0f32ce09022fdabbd7151035ae99ff2bd915d184f78a76b31d78718aa5ad2b34e1207b420c1752db4d1d43cb94a105b7efb05ceb96531898eb9eb70014093f53433209890f8476a8b124ad1d229246eab1480717a0e6c5cc7ab2894da0af845104b2d9eeb52ce7a059abad3704091aa6f53590639073dea31998e641290a668e23fbd7ab65821d2e1a6a1ecba5d86ddb58cea86c83caf64554c6282f112dacca6f3067a461041115384509d8aec2177321223f31d13d2a18031a5d410acc7fd7032fef1774fab4670effacf588a9299898f20b0d4f83dc9a02ba1d70b54667fa439e519665e6ae712d462f8050fc1c9c18ae66c08184aa62dd543000e2aaeb8f91001fb75047da877ae81373e679f5f5bd0964ddf38b5abf828a6c0381d9e09c94ad81b01ec269aa62e388a62a83d82a0e336808cb4a2f5e6db2b864c053206e22ad77d500a1e46368bc224e9ca214896d32267f6da810a2cbd61e6dd3443514bbafe03a06b58e86f28205cc572ab11632ff4e3f9412582e560c6691e6e5223f65bb517df50db7cf3c6c7bc31c746032820cf5ecd3ae795beb9c3366913b37e7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">內容已加密，請輸入密碼。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 學習筆記</title>
    <url>/2022-05-12-javascript-note/</url>
    <content><![CDATA[<p>初學 JavaScript 的筆記，因為沒有一個學習的方向，因此幾乎是學到什麼就寫什麼，筆記的內容很冗長也沒有刻意整理，不建議筆者以外的人閱讀。</p>
<span id="more"></span>


<h2 id="宣告"><a href="#宣告" class="headerlink" title="宣告"></a>宣告</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>宣告的值為區域變數，可重新賦予值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 宣告一變數 &quot;price&quot;，並賦予值為 60</span><br><span class="hljs-keyword">let</span> price = <span class="hljs-number">60</span>;<br><span class="hljs-comment">// 重新賦予變數 &quot;price&quot; 值為 80</span><br>price = <span class="hljs-number">80</span>;<br></code></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>宣告的值為常數，僅可讀取不可重新賦予值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 宣告一變數 &quot;sunNum&quot; 並賦予值為 1，該變數值無法在重新賦予</span><br><span class="hljs-keyword">const</span> sunNum = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>宣告的值為全域變數，可重新賦予值</p>
<blockquote>
<p>宣告變數的名稱可使用駝峰式命名，此外，若撞到部分保留字，會無法宣告，保留字可參考此<a href="http://www.w3bai.com/zh-TW/js/js_reserved.html">連結</a>。</p>
</blockquote>
<h2 id="型別"><a href="#型別" class="headerlink" title="型別"></a>型別</h2><p>字串（String）、數字（Number）、布林值（Boolean）…等，可透過 <code>typeof</code> 來判斷變數型別，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例一</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num);<br><span class="hljs-comment">// 輸出結果為 Number</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例二</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-string">&#x27;10&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num);<br><span class="hljs-comment">// 輸出結果為 String</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>更多型別內容可參考此<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Data_structures">連結</a>。</p>
</blockquote>
<h3 id="數字（Number）"><a href="#數字（Number）" class="headerlink" title="數字（Number）"></a>數字（Number）</h3><p>只要是數字，並且沒有使用單、雙引號的值，型別都屬於數字，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">typeof</span> num );<br><span class="hljs-comment">// 輸出結果為 Number</span><br></code></pre></td></tr></table></figure>

<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>當兩變數無法進行計算時，會出現 <code>NaN</code> 的結果，產生時機範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">let</span> c = a * b;<br><span class="hljs-built_in">console</span>.log( c, <span class="hljs-keyword">typeof</span> c );<br><span class="hljs-comment">// 輸出結果為 NaN number</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>NaN 主要告知輸出結果有異常，而型別屬於 number。</p>
</blockquote>
<h3 id="字串（String）"><a href="#字串（String）" class="headerlink" title="字串（String）"></a>字串（String）</h3><p>型別為字串的值會加上單或雙引號來表示。</p>
<h4 id="字串相加"><a href="#字串相加" class="headerlink" title="字串相加"></a>字串相加</h4><p>字串相加寫法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 寫法一</span><br><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;hello &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment">// 變數值中帶有半形空白</span><br><span class="hljs-comment">// 此時變數 text 的結果為 hello world</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 寫法二</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Cliff&#x27;</span>;<br><span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( content + <span class="hljs-string">&#x27; &#x27;</span> + name ); <span class="hljs-comment">// 使用 &#x27; &#x27; 取代寫法一的半形空白</span><br><span class="hljs-comment">// 此時輸出結果為 Hello! Cliff</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 寫法三</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Cliff&#x27;</span>;<br><span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<br><span class="hljs-keyword">let</span> content = name + <span class="hljs-string">&#x27; &#x27;</span> + word;<br><span class="hljs-built_in">console</span>.log( content );<br><span class="hljs-comment">// 此時輸出結果為 Hello! Cliff</span><br></code></pre></td></tr></table></figure>

<p>寫法一在變數中使用空白，但實務上會比較建議使用寫法二、三的做法。</p>
<h4 id="字串長度"><a href="#字串長度" class="headerlink" title="字串長度"></a>字串長度</h4><p>可使用 <code>length</code> 來查詢變數內容的長度，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27; Hello! &#x27;</span>;<br><span class="hljs-built_in">console</span>.log( message.length );<br><span class="hljs-comment">// 輸出結果為 9</span><br></code></pre></td></tr></table></figure>

<p>上述透過 <code>length</code> 所計算出來的結果，會包含空白，因此若希望輸出結果自動過濾左右兩側的空白，可使用 <code>trim()</code> 語法，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27; Hello ! &#x27;</span>;<br><span class="hljs-built_in">console</span>.log( message.trim().length );<br><span class="hljs-comment">// 輸出結果為 7</span><br></code></pre></td></tr></table></figure>

<h4 id="自動轉型"><a href="#自動轉型" class="headerlink" title="自動轉型"></a>自動轉型</h4><p>因為 Javascript 屬於弱型別，因此有些情況下，變數的型別會被自動轉型，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;10&#x27;</span>;<br><span class="hljs-keyword">let</span> num = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> mixBoth = str + num;<br><span class="hljs-built_in">console</span>.log( mixboth, <span class="hljs-keyword">typeof</span> mixboth );<br><span class="hljs-comment">// 輸出結果為 105 string</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，變數 <code>str</code> 與 <code>num</code> 兩變數值的型別分別屬於字串與數字，而變數 <code>mixboth</code> 將兩者相加，從最後輸出的結果中可以發現，相加的過程中，變數 <code>num</code> 的值被自動轉型為字串。</p>
<h4 id="手動轉型"><a href="#手動轉型" class="headerlink" title="手動轉型"></a>手動轉型</h4><p><strong>字串轉數字</strong></p>
<p>可使用 <code>parseInt()</code> 將型別 string 轉為型別 number，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;10&#x27;</span>;<br><span class="hljs-keyword">let</span> num = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> mixBoth = <span class="hljs-built_in">parseInt</span>(str) + num;<br><span class="hljs-built_in">console</span>.log( mixboth, <span class="hljs-keyword">typeof</span> mixboth );<br><span class="hljs-comment">// 輸出結果為 15 number</span><br></code></pre></td></tr></table></figure>

<p>因為字串與數字相加後的型別會是字串，因此若要正確計算上述兩變數值時，需要透過 <code>parseInt()</code> 將變數 <code>str</code> 的值型別轉為數字。</p>
<blockquote>
<p><code>parseInt()</code> 使用的時機像是需要取出 <code>input[type=text]</code> 表單內容時。</p>
</blockquote>
<p>如果變數的值為非數字的字串，則無法正確轉型，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-built_in">console</span>.log( num, <span class="hljs-keyword">typeof</span> num );<br><span class="hljs-comment">// 輸出結果為 NaN number</span><br></code></pre></td></tr></table></figure>

<p><strong>數字轉字串</strong></p>
<p>可使用 <code>toString()</code> 將型別 number 轉為型別 string，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">20</span>;<br>num2 = num2.toString(); <span class="hljs-comment">// 將原本的型別 Number 轉為 String，並重新賦予值</span><br><span class="hljs-keyword">let</span> mixBoth = num + num2;<br><span class="hljs-built_in">console</span>.log( mixBoth, <span class="hljs-keyword">typeof</span> mixBoth );<br><span class="hljs-comment">// 輸出結果為 1020 string</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>toString()</code> 使用的時機像是需要將電話號碼的區域碼，與後方的號碼做分隔時，就會需要字串與字串相加。</p>
</blockquote>
<h4 id="value-指向"><a href="#value-指向" class="headerlink" title="value 指向"></a>value 指向</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例一</span><br><span class="hljs-keyword">let</span> email = <span class="hljs-string">&#x27;test@mail.com&#x27;</span>;<br>email.length;<br><span class="hljs-built_in">console</span>.log( email );<br><span class="hljs-comment">// 輸出結果為 test@mail.com</span><br></code></pre></td></tr></table></figure>

<p>上述範例最終輸出結果為 <code>test@mail.com</code> 而非 <code>13</code>，因為 <code>length</code> 只是計算變數的長度，並沒有實際賦予變數一個新值，因此變數 <code>email</code> 的值並沒有改變指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例二</span><br><span class="hljs-keyword">let</span> email = <span class="hljs-string">&#x27; test@mail.com &#x27;</span>; <span class="hljs-comment">// 兩側加入空白</span><br><span class="hljs-keyword">let</span> emailLength = email.length;<br>email.trim();<br><span class="hljs-built_in">console</span>.log( email, emailLength );<br><span class="hljs-comment">// 輸出結果為 &#x27; test@mail.com &#x27; 15</span><br></code></pre></td></tr></table></figure>

<p>上述範例分別宣告了 <code>email</code>、<code>emailLength</code> 兩個變數並賦予值，而第四行雖然執行了 <code>trim()</code> 來過濾變數 <code>email</code> 兩側的空白，但並沒有使用 <code>=</code> 符號重新賦予該變數新的值，因此最終輸出結果不變，如果希望輸出的值不包含兩側空白，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> email = <span class="hljs-string">&#x27; test@mail.com &#x27;</span>; <span class="hljs-comment">// 兩側加入空白</span><br><span class="hljs-keyword">let</span> emailLength = email.length;<br><span class="hljs-keyword">let</span> updateEmail = email.trim();<br>email.trim();<br><span class="hljs-built_in">console</span>.log( email, emailLength, updateEmail );<br><span class="hljs-comment">// 輸出結果為 &#x27; test@mail.com &#x27; 15 &#x27;test@mail.com&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述宣告一變數 <code>updateEmail</code> 並賦予值為 <code>email.trim()</code>，因此最終輸出結果為 <code>&#39;test@mail.com&#39;</code>。</p>
<h4 id="樣板字面值"><a href="#樣板字面值" class="headerlink" title="樣板字面值"></a>樣板字面值</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Cliff&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;我是&#x27;</span>+name+<span class="hljs-string">&#x27;，今年&#x27;</span>+age+<span class="hljs-string">&#x27;歲。&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( content );<br><span class="hljs-comment">// 輸出結果為 &#x27;我是Cliff，今年20歲。&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述變數 <code>content</code> 的值雖透過 <code>+</code> 符號來組成一段文字內容，但這種方式較為麻煩且閱讀起來較困難，因此建議使用樣板字面值，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Cliff&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> content = <span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>歲。`</span>;<br><span class="hljs-built_in">console</span>.log( content );<br><span class="hljs-comment">// 輸出結果為 &#x27;我是Cliff，今年20歲。&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>樣板字面值會使用兩個反引號（tab 上方按鍵）符號將內容包覆在其中，而變數使用 <code>$&#123; 變數名稱 &#125;</code> 方式插入。</p>
</blockquote>
<h3 id="布林值（Boolean）"><a href="#布林值（Boolean）" class="headerlink" title="布林值（Boolean）"></a>布林值（Boolean）</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isSingle = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log( isSingle, <span class="hljs-keyword">typeof</span> isSingle );<br><span class="hljs-comment">// 輸出結果為 true &#x27;boolean&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述宣告一變數 <code>isSingle</code> 並賦予值 <code>true</code>，最終輸出型別為 <code>boolean</code>（布林值），與數字、字串型別不同的是，布林值只有 <code>true</code>、<code>false</code> 兩個值，通常用於判斷是或不是。</p>
<p>判斷 100⁹⁹ 與 99¹⁰⁰ 兩數值大小，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">100</span>**<span class="hljs-number">99</span> &gt; <span class="hljs-number">99</span>**<span class="hljs-number">100</span> );<br><span class="hljs-comment">// 輸出結果為 false</span><br></code></pre></td></tr></table></figure>

<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>除了前面提到的三種型別之外，較常見的還有 <code>undefined</code>，當宣告的變數未賦予（使用 <code>=</code> 符號）一個實際的值時，該變數的值與型別就會是 <code>undefined</code>，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a;<br><span class="hljs-built_in">console</span>.log( a, type a );<br><span class="hljs-comment">// 輸出結果為 undefined &#x27;undefined&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>undefinde</code> 表示該變數 “尚未被賦予值”。</p>
</blockquote>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>null</code> 表示該變數有被賦予一個值，但是是屬於空值，簡單範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(a, <span class="hljs-keyword">typeof</span> a);<br><span class="hljs-comment">// 輸出結果為 null &#x27;object&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>null</code> 通常會在需要清空物件或陣列中的資料內容時使用。</p>
</blockquote>
<h2 id="運算子"><a href="#運算子" class="headerlink" title="運算子"></a>運算子</h2><h3 id="比較運算子"><a href="#比較運算子" class="headerlink" title="比較運算子"></a>比較運算子</h3><p>常見的比較運算子如下所示：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">| &gt; 大於 | &lt; 小於 | &gt;= 大於且等於 | &lt;= 小於且等於 | == 等於 | != 不等於 | === 等於（包含型別） | !== 不等於（包含型別） |<br></code></pre></td></tr></table></figure>

<p>比較運算子所運算的結果會以布林值（Boolean）表示，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">50</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> c = a &gt; b;<br><span class="hljs-built_in">console</span>.log( a &gt; b );<br><span class="hljs-comment">// 輸出結果為 true</span><br><span class="hljs-built_in">console</span>.log( ( b**<span class="hljs-number">2</span> ) &gt; a );<br><span class="hljs-comment">// 輸出結果為 true</span><br><span class="hljs-built_in">console</span>.log( c );<br><span class="hljs-comment">// 變數 c 的值會先在記憶體中計算出結果，再回傳計算後的結果 true 並賦予變數值，因此最終輸出結果為 true</span><br></code></pre></td></tr></table></figure>

<h4 id="比較運算子補充觀念"><a href="#比較運算子補充觀念" class="headerlink" title="比較運算子補充觀念"></a>比較運算子補充觀念</h4><p><strong>觀念一</strong></p>
<p><code>=</code> 與 <code>==</code> 兩者在作用上的差異在於前者表示 “賦予” 一個變數值，後者則是判斷兩變數的值 “是否相等”。</p>
<p><strong>觀念二</strong></p>
<p><code>==</code> 與 <code>===</code> 都是用來判斷兩變數的值是否相等，但有些許差異，差異如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;10&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( a == b );<br><span class="hljs-comment">// 輸出結果為 true</span><br><span class="hljs-built_in">console</span>.log( a === b );<br><span class="hljs-comment">// 輸出結果為 false</span><br></code></pre></td></tr></table></figure>

<p>從上述範例可以得知，<code>==</code> 在比較的過程中如果內容相同但型別不同，就會自動轉型變數的型別，而 <code>===</code> 除了比較內容之外，也會判斷兩變數的型別是否相等，因此後者較為嚴謹。</p>
<blockquote>
<p>上述範例同理 <code>!=</code> 與 <code>!==</code>。</p>
</blockquote>
<h3 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子"></a>邏輯運算子</h3><p>邏輯運算子會使用的符號為 <code>&amp;&amp;</code>（and）、<code>||</code>（or），分別表示 “同時滿足條件”、”滿足其中一個條件” ，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">50</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> c = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">console</span>.log( a &gt;= b &amp;&amp; a &gt; c ); <span class="hljs-comment">// a &gt;= b 且 a &lt; c / 兩條件皆必須為 true</span><br><span class="hljs-comment">// 輸出結果為 false</span><br><span class="hljs-built_in">console</span>.log( a &gt;= b || a &gt; c ); <span class="hljs-comment">// a &gt;= b 或 a &lt; c / 其中一個條件為 true 即可</span><br><span class="hljs-comment">// 輸出結果為 true</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>邏輯運算子常見的情境像是百貨公司周年慶 e.g 同款項第二件九折，若單筆消費超過兩千元，則送百元折價券。</p>
</blockquote>
<p>邏輯運算子也可以用來判斷兩個以上的條件，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sex = <span class="hljs-string">&#x27;male&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">let</span> isSingle = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">console</span>.log( sex == <span class="hljs-string">&#x27;male&#x27;</span> &amp;&amp; age &gt;= <span class="hljs-number">18</span> &amp;&amp; isSingle == <span class="hljs-literal">true</span> );<br><span class="hljs-comment">// 不滿足 isSingle == true 條件，因此輸出結果為 false</span><br></code></pre></td></tr></table></figure>

<h3 id="賦值運算子"><a href="#賦值運算子" class="headerlink" title="賦值運算子"></a>賦值運算子</h3><p>賦值運算子會使用 <code>+=</code>, <code>-=</code> 等方式來變更變數值，以下範例為變更一個變數值的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wallet = <span class="hljs-number">500</span>; <span class="hljs-comment">// 錢包總共有 500 元</span><br>wallect = <span class="hljs-number">400</span>; <span class="hljs-comment">// 買了 100 元的早餐，剩餘 400 元</span><br>wallet = <span class="hljs-number">450</span>; <span class="hljs-comment">// 路上撿到 50 元，現在總共有 450 元</span><br><span class="hljs-built_in">console</span>.log( wallect );<br><span class="hljs-comment">// 輸出結果為 450</span><br></code></pre></td></tr></table></figure>

<p>上述範例若使用賦值運算子，寫法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wallet = <span class="hljs-number">500</span>; <span class="hljs-comment">// 錢包總共有 500 元</span><br>wallect = wallet - <span class="hljs-number">100</span>; <span class="hljs-comment">// 買了 100 元的早餐，剩餘 400 元</span><br>wallect = wallect + <span class="hljs-number">50</span>;<br><span class="hljs-built_in">console</span>.log( wallect );<br><span class="hljs-comment">// 輸出結果為 450</span><br></code></pre></td></tr></table></figure>

<p>如上述情境所示，透過賦值運算子來計算花費的金額，邏輯與可辨識性相較前者高。</p>
<h4 id="賦值運算子縮寫"><a href="#賦值運算子縮寫" class="headerlink" title="賦值運算子縮寫"></a>賦值運算子縮寫</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<br>num = num + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// num 最終的值為 2</span><br></code></pre></td></tr></table></figure>

<p>將上述範例使用縮寫撰寫，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 縮寫</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<br>num += <span class="hljs-number">1</span>;<br><span class="hljs-comment">// num 最終的值為 2</span><br></code></pre></td></tr></table></figure>

<p>若只需要針對變數值進行 <code>+=1</code> 或 <code>-=1</code> 的動作，可以使用 <code>++</code> 或 <code>--</code>，範例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br>a++;<br>b--;<br><span class="hljs-built_in">console</span>.log( a, b );<br><span class="hljs-comment">// 輸出結果為 2, 1</span><br></code></pre></td></tr></table></figure>

<p>雖然 <code>++</code> 本身沒有 <code>=</code> 符號，但也會重新賦予變數值，因此上述三種方式的運作方式與結果皆相同。</p>
<blockquote>
<p>更多相關運算子內容可參考此<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators">連結</a>。</p>
</blockquote>
<h2 id="if-流程判斷"><a href="#if-流程判斷" class="headerlink" title="if 流程判斷"></a>if 流程判斷</h2><p>流程判斷會使用到的判斷方式有 <code>if</code>、<code>else if</code>、<code>else</code> 三種，分別可以理解成 “如果”、”或是”、”否則”，如下方範例情境所示：</p>
<p><strong>情境一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷是否下雨，若是，則待在家不出門</span><br><span class="hljs-keyword">let</span> isRain = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>( isRain == <span class="hljs-literal">true</span> )&#123; <span class="hljs-comment">// 判斷結果為 true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;待在家不出門&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 輸出結果為 &#x27;待在家不出門&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，<code>if</code> 右方小括弧中的內容稱為條件式，若條件式的判斷結果為 <code>true</code>（滿足條件式），則執行大括弧中的內容。</p>
<p><strong>情境二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷是否消費滿 1000 元，若是，則打九折，若否，則不打折</span><br><span class="hljs-keyword">let</span> cost = <span class="hljs-number">800</span>;<br><span class="hljs-keyword">if</span>( cost &gt;= <span class="hljs-number">1000</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;消費滿千，可以折扣&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未滿千元，沒有折扣&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 輸出結果為 &#x27;未滿千元，沒有折扣&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，因為條件式 <code>cost &gt;= 1000</code> 判斷結果為 <code>false</code>，因此跳過第 4 行的內容而執行 <code>else</code> 的內容。</p>
<blockquote>
<p>若 <code>if</code> 判斷的結果為 <code>false</code>，但沒有給予對應的 <code>else</code> 內容，就會終止判斷且不會執行任何內容。</p>
</blockquote>
<p><strong>情境三</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷錢包的錢是否夠買麵配可樂</span><br><span class="hljs-keyword">let</span> wallet = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">let</span> noodlePrice = <span class="hljs-number">120</span>;<br><span class="hljs-keyword">let</span> cokePrice = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">if</span>( wallet &gt;= ( noodlePrice + cokePrice ) )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;午餐吃麵配可樂，真爽&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( wallet &gt; noodlePrice &amp;&amp; wallet &lt; ( noodlePrice + cokePrice ) )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;午餐只能吃麵&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;午餐只喝可樂，e04&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>情境四</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：今天計畫要出門，如果下毛毛雨就帶輕便雨衣，如果下小雨就帶傘，但如果下豪雨就不出門。</span><br><span class="hljs-keyword">let</span> weather = <span class="hljs-string">&#x27;小雨&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`現在外面<span class="hljs-subst">$&#123;weather&#125;</span>，所以`</span>);<br><span class="hljs-keyword">if</span>( weather == <span class="hljs-string">&#x27;無雨&#x27;</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不需要攜帶雨具&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( weather == <span class="hljs-string">&#x27;毛毛雨&#x27;</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;攜帶輕便雨衣&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( weather == <span class="hljs-string">&#x27;小雨&#x27;</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;攜帶一把傘&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( weather == <span class="hljs-string">&#x27;小雨&#x27;</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;攜帶一把傘&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( weather == <span class="hljs-string">&#x27;豪雨&#x27;</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;待在家不出門&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;狀態異常&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 輸出結果為 現在外面小雨，所以 攜帶一把傘</span><br></code></pre></td></tr></table></figure>

<p>如上述範例所示，<code>else if</code> 可以使用多個，而 <code>if</code>、<code>else</code> 僅可頭尾分別存在一個。</p>
<p><strong>情境五</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷考試成績區間</span><br><span class="hljs-keyword">let</span> point;<br>point = <span class="hljs-number">89</span>;<br><span class="hljs-built_in">console</span>.log(point, <span class="hljs-keyword">typeof</span> point)<br><span class="hljs-keyword">if</span>( point &gt;= <span class="hljs-number">80</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> point) != <span class="hljs-literal">undefined</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;成績優異&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-number">80</span> &gt; point &amp;&amp; point &gt;= <span class="hljs-number">60</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> point) != <span class="hljs-literal">undefined</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請保持&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-number">60</span> &gt; point &amp;&amp; (<span class="hljs-keyword">typeof</span> point) != <span class="hljs-literal">undefined</span> )&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;請再加油&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;資料有誤&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>範例程式碼中，最後的 <code>else</code> 主要用於判斷程式碼若不符合前面所有條件時，所產生的異常狀態，有利於除錯。</p>
</blockquote>
<h3 id="流程圖"><a href="#流程圖" class="headerlink" title="流程圖"></a>流程圖</h3><p>初學者在撰寫流程判斷時，若有事先規劃的流程圖，可以有效提高撰寫的效率與程式邏輯思維，流程圖的形狀代表意義如下：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">箭頭 </span>=<span class="hljs-string"> 流程走向</span><br><span class="hljs-string">橢圓 = 起止符號 = 流程起點/終點</span><br><span class="hljs-string">矩形 = 處理流程 = 一系列的程式去改變數值、形式、數據的位置</span><br><span class="hljs-string">菱形 = 決策判斷 = 判斷條件，視情況決定下一步走向，通常以是/否決定。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>推薦使用 <a href="https://whimsical.com/">Whimsical</a> 線上工具來設計流程圖，流程圖參考範例：<a href="https://i.imgur.com/7KufOX3.png">範例一</a>、<a href="https://i.imgur.com/zzvsblf.png">範例二</a>。</p>
</blockquote>
<h3 id="if-巢狀運用"><a href="#if-巢狀運用" class="headerlink" title="if 巢狀運用"></a>if 巢狀運用</h3><p>if 在判斷條件式後，執行的內容中也能夠放入其他細部判斷式，流程圖可參考此<a href="https://i.imgur.com/g1WaOjc.png">連結</a>，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷不同性別的體態狀況</span><br><span class="hljs-comment">// 測試資料</span><br><span class="hljs-keyword">let</span> sex = <span class="hljs-string">&#x27;male&#x27;</span>;<br><span class="hljs-keyword">let</span> centimeter = <span class="hljs-number">88</span>;<br><span class="hljs-comment">// 將測用的資料帶入流程判斷</span><br><span class="hljs-keyword">if</span>( sex == <span class="hljs-string">&#x27;male&#x27;</span> )&#123;<br>    <span class="hljs-keyword">if</span>( centimeter &gt;= <span class="hljs-number">90</span> )&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;男生體態過胖&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;男生體態正常&#x27;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( sex == <span class="hljs-string">&#x27;woman&#x27;</span> )&#123;<br>    <span class="hljs-keyword">if</span>( centimeter &gt;= <span class="hljs-number">80</span> )&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;女生體態過胖&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;女生體態正常&#x27;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;您輸入的資料有誤&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 輸出結果為 男生體態正常</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，資料首先在第 6 行開始進行判斷式 <code>sex == &#39;male&#39;</code> 的判斷，符合條件後執行下方內容，再執行內容中 <code>if</code> 的判斷式 <code>centimeter &gt;= 90</code>，判斷後不符合條件，最後執行 <code>else</code> 的內容，執行完畢後終止該判斷流程。</p>
<blockquote>
<p>if 只要滿足其中一個條件（判斷式結果為 <code>true</code>），就會在執行該條件的內容後，終止判斷流程（不再進行後續判斷式判斷）。</p>
</blockquote>
<h2 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h2><h3 id="陣列（Array）"><a href="#陣列（Array）" class="headerlink" title="陣列（Array）"></a>陣列（Array）</h3><p>一般的情況下，一個變數只能賦予一個值，但是在多筆資料的狀況下，難以針對每一個變數去賦予對應的值，因此在處理多筆資料時，通常會將這些資料透過一個陣列來表示，並賦予到一個變數中，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 資料可以是各種型態</span><br><span class="hljs-keyword">let</span> data = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br><span class="hljs-keyword">let</span> data = [<span class="hljs-number">30</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>];<br><span class="hljs-keyword">let</span> data = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-keyword">let</span> data = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">true</span>];<br><span class="hljs-keyword">let</span> data = []; <span class="hljs-comment">// 表示沒有資料的空陣列</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>陣列中的所有資料會放入一個中括號內，且每筆資料會使用半形逗號隔開。</p>
</blockquote>
<h4 id="取得陣列資料"><a href="#取得陣列資料" class="headerlink" title="取得陣列資料"></a>取得陣列資料</h4><p>進行抓取指定資料前，需要先理解陣列中的每筆內容是有順序排列的，而第一筆會由 0 開始計算，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br><span class="hljs-built_in">console</span>.log( data );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (3) [&#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;]</span><br><span class="hljs-comment">// 0: &quot;red&quot;</span><br><span class="hljs-comment">// 1: &quot;yellow&quot;</span><br><span class="hljs-comment">// 2: &quot;green&quot;</span><br><span class="hljs-comment">// length: 3</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>從上述範例結果中，可以得知該陣列的每筆資料內容、長度以及資料結構類型，此時假設如果要取得該陣列的第二筆資料內容時，可以在該變數後方加上 <code>[1]</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br><span class="hljs-built_in">console</span>.log( data[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 第一筆以 [0] 表示，因此第二筆為 [1]，依此類推</span><br><span class="hljs-comment">// 輸出結果為 yellow</span><br></code></pre></td></tr></table></figure>

<h4 id="陣列取值賦予新變數"><a href="#陣列取值賦予新變數" class="headerlink" title="陣列取值賦予新變數"></a>陣列取值賦予新變數</h4><p>可指定陣列中的資料，並將該資料內容賦予至一個新變數中，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> musicGenres = [<span class="hljs-string">&#x27;Pop&#x27;</span>, <span class="hljs-string">&#x27;Rock&#x27;</span>, <span class="hljs-string">&#x27;Rap&#x27;</span>];<br><span class="hljs-keyword">let</span> myHobby = musicGenres[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">console</span>.log( myHobby );<br><span class="hljs-comment">// 輸出結果為 Pop</span><br></code></pre></td></tr></table></figure>

<h4 id="取得陣列長度"><a href="#取得陣列長度" class="headerlink" title="取得陣列長度"></a>取得陣列長度</h4><p>先前在型別有提到可使用 <code>length</code> 來查詢變數的內容長度，而該作法在陣列上的使用方式也是相同的，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> aryLength = ary.length;<br><span class="hljs-built_in">console</span>.log( aryLength );<br><span class="hljs-comment">// 輸出結果為 5</span><br></code></pre></td></tr></table></figure>

<h4 id="新增陣列資料"><a href="#新增陣列資料" class="headerlink" title="新增陣列資料"></a>新增陣列資料</h4><p>以空陣列為例，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例一：指定陣列中第一筆資料並賦予值</span><br><span class="hljs-keyword">let</span> ary = [];<br>ary[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;新增資料&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( ary );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// [&#x27;新增資料&#x27;]</span><br><span class="hljs-comment">// 0: &quot;新增資料&quot;</span><br><span class="hljs-comment">// length: 1</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例二：分別指定陣列中第一筆資料與第三筆資料並賦予值</span><br><span class="hljs-keyword">let</span> ary = [];<br>ary[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;第一筆資料&#x27;</span>;<br>ary[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;第二筆資料&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( ary, ary[<span class="hljs-number">1</span>] );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (3) [&#x27;第一筆資料&#x27;, empty, &#x27;第二筆資料&#x27;] undefined</span><br><span class="hljs-comment">// 0: &quot;第一筆資料&quot;</span><br><span class="hljs-comment">// 2: &quot;第二筆資料&quot;</span><br><span class="hljs-comment">// length: 3</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>範例二中的第二筆資料因為沒有賦予值，因此該筆資料為空資料 <code>empty</code>，但是空值不代表該筆資料不存在，而是尚未定義資料內容（undefined），因此也會被納入陣列的長度（length）中。</p>
</blockquote>
<h4 id="push-新增資料"><a href="#push-新增資料" class="headerlink" title="push 新增資料"></a>push 新增資料</h4><p><code>push()</code> 是新增資料到陣列中的一種方法，使用該方式所加入的值，會被放到陣列<strong>最末端</strong>的位置，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br>colors.push(<span class="hljs-string">&#x27;blue&#x27;</span>);<br><span class="hljs-built_in">console</span>.log( colors );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (4) [&#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;] // blue 位置在最後</span><br><span class="hljs-comment">// 0: &quot;red&quot;</span><br><span class="hljs-comment">// 1: &quot;yellow&quot;</span><br><span class="hljs-comment">// 2: &quot;green&quot;</span><br><span class="hljs-comment">// 3: &quot;blue&quot;</span><br><span class="hljs-comment">// length: 4</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="unshift-新增資料"><a href="#unshift-新增資料" class="headerlink" title="unshift 新增資料"></a>unshift 新增資料</h4><p>運作的原理與 <code>push()</code> 相同，差異在於透過 <code>unshift()</code> 所加入陣列的值，位置會在該陣列的<strong>最前端</strong>，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br>colors.unshift(<span class="hljs-string">&#x27;blue&#x27;</span>);<br><span class="hljs-built_in">console</span>.log( colors );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (4) [&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;] // blue 位置在最前</span><br><span class="hljs-comment">// 0: &quot;blue&quot;</span><br><span class="hljs-comment">// 1: &quot;red&quot;</span><br><span class="hljs-comment">// 2: &quot;yellow&quot;</span><br><span class="hljs-comment">// 3: &quot;green&quot;</span><br><span class="hljs-comment">// length: 4</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="pop-刪除資料"><a href="#pop-刪除資料" class="headerlink" title="pop 刪除資料"></a>pop 刪除資料</h4><p>在一個陣列後方加入 <code>pop()</code> 方法之後，該陣列的<strong>最後一筆</strong>資料會被刪除，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br>colors.pop();<br><span class="hljs-built_in">console</span>.log( colors );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (2) [&#x27;red&#x27;, &#x27;yellow&#x27;] // 最後一筆 green 被刪除</span><br><span class="hljs-comment">// 0: &quot;red&quot;</span><br><span class="hljs-comment">// 1: &quot;yellow&quot;</span><br><span class="hljs-comment">// length: 2</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="shift-刪除資料"><a href="#shift-刪除資料" class="headerlink" title="shift 刪除資料"></a>shift 刪除資料</h4><p>運作的原理與 <code>pop()</code> 相同，差異在於 <code>shift()</code> 所刪除的資料，是陣列中的<strong>第一筆</strong>，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];<br>colors.shift();<br><span class="hljs-built_in">console</span>.log( colors );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (2) [&#x27;yellow&#x27;, &#x27;green&#x27;] // 第一筆 red 被刪除</span><br><span class="hljs-comment">// 0: &quot;yellow&quot;</span><br><span class="hljs-comment">// 1: &quot;green&quot;</span><br><span class="hljs-comment">// length: 2</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="splice-刪除指定資料"><a href="#splice-刪除指定資料" class="headerlink" title="splice 刪除指定資料"></a>splice 刪除指定資料</h4><p>使用 <code>splice()</code> 方法刪除陣列中的資料時，會加入兩個參數，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>colors.splice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log( colors );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (2) [&#x27;red&#x27;, &#x27;blue&#x27;] // 從 green 開始，刪除兩筆資料</span><br><span class="hljs-comment">// 0: &quot;red&quot;</span><br><span class="hljs-comment">// 1: &quot;blue&quot;</span><br><span class="hljs-comment">// length: 2</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，<code>splice(1, 2)</code> 兩個參數依序分別代表刪除資料的起始位置，以及刪除資料的筆數，因此會以第二筆開始刪除，並刪除兩筆資料，因此 <code>green</code> 與 <code>blue</code> 被刪除。</p>
<blockquote>
<p>無論使用上述任何方法新增、刪除陣列中的資料，該陣列的長度都會有所改變。</p>
</blockquote>
<blockquote>
<p>關於陣列的處理方法還有 <code>filter()</code> , <code>find()</code> , <code>forEach()</code> , <code>map()</code> , <code>every()</code> , <code>some()</code> , <code>reduce()</code>，以上內容會在函式（function）的部分說明。</p>
</blockquote>
<h3 id="物件（Object）"><a href="#物件（Object）" class="headerlink" title="物件（Object）"></a>物件（Object）</h3><p>當一筆資料需要詳細紀錄不同的細部資訊時，會以物件的形式來表示，並賦予至一個變數中，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>, <span class="hljs-comment">// 屬性: 屬性值</span><br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@email.com&#x27;</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log( myInfo );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;Mark&#x27;, sex: &#x27;male&#x27;, age: 18, email: &#x27;test@email.com&#x27;, isSingle: true&#125;</span><br><span class="hljs-comment">// age: 18</span><br><span class="hljs-comment">// email: &quot;test@email.com&quot;</span><br><span class="hljs-comment">// isSingle: true</span><br><span class="hljs-comment">// name: &quot;Mark&quot;</span><br><span class="hljs-comment">// sex: &quot;male&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>物件的內容會放入一個大括號內，而物件中每個細項會有一個屬性名稱與對應的屬性值，且屬性之間會使用半形逗號隔開。</p>
</blockquote>
<h4 id="取得物件資料"><a href="#取得物件資料" class="headerlink" title="取得物件資料"></a>取得物件資料</h4><p>物件中會存在各種不同名稱的屬性與對應的值，如果要取得指定的屬性值，第一種方式會使用 <code>.</code> 符號，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log( myInfo.name ); <span class="hljs-comment">// 取得物件 myInfo 中的屬性 name 的值</span><br><span class="hljs-comment">// 輸出結果為 Mark</span><br></code></pre></td></tr></table></figure>

<p>除了前面提到使用 <code>.</code> 來取得屬性值，還可以使用中括號 <code>[屬性名稱]</code> 的方式來取得，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log( myInfo[<span class="hljs-string">&#x27;name&#x27;</span>] ); <span class="hljs-comment">// 取得物件 myInfo 中的屬性 name 的值</span><br><span class="hljs-comment">// 輸出結果為 Mark</span><br></code></pre></td></tr></table></figure>

<p>此外，也可以將物件的屬性名稱賦予至一變數，並透過 <code>[變數]</code> 的方式來取得物件中的屬性值，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-built_in">console</span>.log( myInfo[myName] ); <span class="hljs-comment">// 原理等同於 myInfo[&#x27;name&#x27;]</span><br><span class="hljs-comment">// 輸出結果為 Mark</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>.</code> 或是 <code>[]</code> 都可以取得物件中的屬性值，而前者在取得某些 JSON 格式的資料時可能會導致程式碼無法辨識。</p>
</blockquote>
<h4 id="新增物件屬性"><a href="#新增物件屬性" class="headerlink" title="新增物件屬性"></a>新增物件屬性</h4><p>以空物件為例，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;&#125;;<br>myInfo.name = <span class="hljs-string">&#x27;Mark&#x27;</span>; <span class="hljs-comment">// 在 myInfo 物件中新增一個 name 屬性，並賦予屬性值 &#x27;Mark&#x27;</span><br><span class="hljs-built_in">console</span>.log( myInfo );<br></code></pre></td></tr></table></figure>

<h4 id="修改物件屬性值"><a href="#修改物件屬性值" class="headerlink" title="修改物件屬性值"></a>修改物件屬性值</h4><p>物件中的屬性值修改方式原理與變數相同，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-comment">// 以下透過賦值運算子改變屬性值</span><br>myInfo.name = <span class="hljs-string">&#x27;Fuck&#x27;</span>;<br>myInfo.age += <span class="hljs-number">1</span>;<br>isSingle = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">console</span>.log( myInfo );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;Fuck&#x27;, age: 19, isSingle: true&#125;</span><br><span class="hljs-comment">// age: 19</span><br><span class="hljs-comment">// isSingle: true</span><br><span class="hljs-comment">// name: &quot;Fuck&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="刪除物件資料"><a href="#刪除物件資料" class="headerlink" title="刪除物件資料"></a>刪除物件資料</h4><p>物件中的屬性，可以透過 <code>delete</code> 來指定刪除，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">isSingle</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">delete</span> myInfo.isSingle; <span class="hljs-comment">// 刪除 myInfo 物件中的 isSingle 屬性與值</span><br><span class="hljs-built_in">console</span>.log( myInfo, myInfo.isSingle );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;Mark&#x27;, age: 18&#125; undefined // 刪除後找不到 isSingle 相關屬性</span><br><span class="hljs-comment">// age: 18</span><br><span class="hljs-comment">// name: &quot;Mark&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>



<h2 id="物件結合陣列"><a href="#物件結合陣列" class="headerlink" title="物件結合陣列"></a>物件結合陣列</h2><p>陣列除了可以放入一般的變數之外，也能夠放入多個物件，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：水果的詳細資訊</span><br><span class="hljs-keyword">let</span> fruitDetail = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">30</span>,<br>        <span class="hljs-attr">isSoldOut</span>: <span class="hljs-literal">false</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;banana&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">isSoldOut</span>: <span class="hljs-literal">true</span><br>    &#125;<br>]<br><span class="hljs-built_in">console</span>.log( fruitDetail );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// (2) [&#123;…&#125;, &#123;…&#125;]</span><br><span class="hljs-comment">// 0: &#123;name: &#x27;Apple&#x27;, price: 30, isSoldOut: false&#125;</span><br><span class="hljs-comment">// 1: &#123;name: &#x27;banana&#x27;, price: 20, isSoldOut: true&#125;</span><br><span class="hljs-comment">// length: 2</span><br><span class="hljs-comment">// [[Prototype]]: Array(0)</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>陣列中的每個物件之間會使用一個半形逗號隔開。</p>
</blockquote>
<p>先前提到陣列會使用 <code>[順序]</code> 的方式來取值，而在陣列內容結構為物件的情況下也是相同的，會使用 <code>[]</code> 來指定物件，並透過 <code>.</code> 或是 <code>[]</code> 來取得屬性內容，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fruitDetail = [<br>    &#123; <span class="hljs-comment">// 第 1 筆 [0]</span><br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">30</span>,<br>        <span class="hljs-attr">isSoldOut</span>: <span class="hljs-literal">false</span><br>    &#125;,&#123; <span class="hljs-comment">// 第 2 筆 [1]</span><br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;banana&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">isSoldOut</span>: <span class="hljs-literal">true</span><br>    &#125;<br>];<br><span class="hljs-built_in">console</span>.log( fruitDetail[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 取得陣列 fruitDetail 的第二個物件內容</span><br><span class="hljs-built_in">console</span>.log( fruitDetail[<span class="hljs-number">1</span>].name ); <span class="hljs-comment">// 指定陣列 fruitDetail 的第二個物件，並取得該物件中屬性 name 的值</span><br><span class="hljs-comment">// 輸出結果1 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;banana&#x27;, price: 20, isSoldOut: true&#125;</span><br><span class="hljs-comment">// isSoldOut: true</span><br><span class="hljs-comment">// name: &quot;banana&quot;</span><br><span class="hljs-comment">// price: 20</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// 輸出結果2 ----</span><br><span class="hljs-comment">// banana</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h3 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h3><p>JSON 是用於程式語言的一種資料結構，方便閱讀，目前也是多種語言通用的資料格式，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例 - 來源取自 wikipedia</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;This is the text&quot;</span>,<br>        <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;dark_red&quot;</span>,<br>        <span class="hljs-string">&quot;bold&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        <span class="hljs-string">&quot;strikethough&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        <span class="hljs-string">&quot;clickEvent&quot;</span>:<br>        &#123;<br>            <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;open_url&quot;</span>,<br>            <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;zh.wikipedia.org&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;hoverEvent&quot;</span>:<br>        &#123;<br>            <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;show_text&quot;</span>,<br>            <span class="hljs-string">&quot;value&quot;</span>:<br>            &#123;<br>                <span class="hljs-string">&quot;extra&quot;</span>: <span class="hljs-string">&quot;something&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;translate&quot;</span>: <span class="hljs-string">&quot;item.dirt.name&quot;</span>,<br>        <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span>,<br>        <span class="hljs-string">&quot;italic&quot;</span>: <span class="hljs-string">&quot;true&quot;</span><br>    &#125;<br>];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>若是使用 Chrome 瀏覽器，可安裝 JSONView 擴充功能，該工具可將網頁上壓縮後的 JSON 格式資料進行自動整理以提高可讀性。</p>
</blockquote>
<h3 id="物件巢狀運用"><a href="#物件巢狀運用" class="headerlink" title="物件巢狀運用"></a>物件巢狀運用</h3><p>物件中的屬性值也能以物件結構表示，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 巢狀物件</span><br><span class="hljs-keyword">let</span> fruit = &#123; <span class="hljs-comment">// 外層物件</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">isSoldOut</span>: &#123; <span class="hljs-comment">// 內層物件</span><br>        <span class="hljs-attr">storeA</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">storeB</span>: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log( fruit ); <span class="hljs-comment">// 取得物件整體內容</span><br><span class="hljs-built_in">console</span>.log( fruit.isSoldOut.storeA ); <span class="hljs-comment">// 取得物件內的物件資料</span><br><span class="hljs-comment">// 輸出結果1----</span><br><span class="hljs-comment">// &#123;name: &#x27;Apple&#x27;, price: 30, isSoldOut: &#123;…&#125;&#125;</span><br><span class="hljs-comment">// isSoldOut: &#123;storeA: true, storeB: false&#125;</span><br><span class="hljs-comment">// name: &quot;Apple&quot;</span><br><span class="hljs-comment">// price: 30</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// 輸出結果2----</span><br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="取得-JSON-資料"><a href="#取得-JSON-資料" class="headerlink" title="取得 JSON 資料"></a>取得 JSON 資料</h4><p><strong>範例一</strong></p>
<p>以此<a href="https://api.kcg.gov.tw/api/service/get/4278fc6a-c3ea-4192-8ce0-40f00cdb40dd">公開資料</a>為例，假設已將該資料賦予至變數 <code>jsonData</code> 中，嘗試取得屬性 <code>data</code> 中第 3 筆資料的 <code>車站中文名稱</code> 屬性值，做法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( jsonData.data[<span class="hljs-number">2</span>].車站中文名稱);<br><span class="hljs-comment">// 輸出結果為 草衙</span><br></code></pre></td></tr></table></figure>

<p><strong>範例二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = &#123;<br>  <span class="hljs-string">&quot;contentType&quot;</span>: <span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>,<br>  <span class="hljs-string">&quot;isImage&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;XML_Head&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;Listname&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>      <span class="hljs-string">&quot;Language&quot;</span>: <span class="hljs-string">&quot;C&quot;</span>,<br>      <span class="hljs-string">&quot;Orgname&quot;</span>: <span class="hljs-string">&quot;397000000A&quot;</span>,<br>      <span class="hljs-string">&quot;Updatetime&quot;</span>: <span class="hljs-string">&quot;2021/01/20 08:40:00&quot;</span>,<br>      <span class="hljs-string">&quot;Infos&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;Info&quot;</span>: [<br>          &#123;<br>            <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;C1_397000000A_000230&quot;</span>,<br>            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>            <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;田寮月世界&quot;</span>,<br>            <span class="hljs-string">&quot;Zone&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;Toldescribe&quot;</span>: <span class="hljs-string">&quot;田寮「月世界」特殊景觀在地理學上稱為「惡地」，是由於地殼的「回春作用」，經年累月的經由雨水與河水強烈侵蝕，將泥沙堆積在泥岩上，地層變動後，泥沙更與泥岩混合再經由風化、沉積作用，形成今日地貌，僅適於耐旱、耐鹽的淺根植物（如：箭竹）、濱海植物生長。從田寮到旗山台28線沿路除了月世界景觀，還有大小不等的二十多個泥火山，常呈現間歇性的噴發現象，噴發的規模則視地底天然氣與泥漿的累積壓力而定，噴發後的泥流堆積地區。&quot;</span>,<br>            <span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;田寮「月世界」特殊景觀在地理學稱為「惡地」，經年累月由雨、河水侵蝕，將泥沙堆積在泥岩上，泥沙與泥岩混合經由風化形成。&quot;</span>,<br>            <span class="hljs-string">&quot;Tel&quot;</span>: <span class="hljs-string">&quot;886-7-6367036&quot;</span>,<br>            <span class="hljs-string">&quot;Add&quot;</span>: <span class="hljs-string">&quot;高雄市823田寮區崇德里月球路36號&quot;</span>,<br>            <span class="hljs-string">&quot;Zipcode&quot;</span>: <span class="hljs-string">&quot;823&quot;</span>,<br>            <span class="hljs-string">&quot;Travellinginfo&quot;</span>: <span class="hljs-string">&quot;無障礙交通：高鐵台南站 → 沙旗美月世界快線公車 → 月世界 → 旗山高鐵左營站 → 旗美快線公車 → 旗山 → 轉搭沙旗美月世界快線公車 → 月世界&quot;</span>,<br>            <span class="hljs-string">&quot;Opentime&quot;</span>: <span class="hljs-string">&quot;遊客中心：09:00–17:00月世界：全天候開放&quot;</span>,<br>            <span class="hljs-string">&quot;Gov&quot;</span>: <span class="hljs-string">&quot;397000000A&quot;</span>,<br>            <span class="hljs-string">&quot;Px&quot;</span>: <span class="hljs-string">&quot;120.38898&quot;</span>,<br>            <span class="hljs-string">&quot;Py&quot;</span>: <span class="hljs-string">&quot;22.88600&quot;</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;C1_397000000A_000234&quot;</span>,<br>            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>            <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;西子灣風景區&quot;</span>,<br>            <span class="hljs-string">&quot;Zone&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;Toldescribe&quot;</span>: <span class="hljs-string">&quot;西子灣以夕陽美景及天然礁石聞名，區內包括了西子灣海水浴場、海濱公園、打狗英國領事館....等景點；可觀海景、遠眺高雄港；海水浴場極富熱帶氣息、南國風情，每當夜幕低垂，晚霞的照耀，漁船燈火閃爍其間，呈現海天一色美景。&quot;</span>,<br>            <span class="hljs-string">&quot;Description&quot;</span>: <span class="hljs-string">&quot;西子灣以夕陽美景及天然礁石聞名，區內包括了西子灣海水浴場、海濱公園、打狗英國領事館....等景點。&quot;</span>,<br>            <span class="hljs-string">&quot;Tel&quot;</span>: <span class="hljs-string">&quot;886-7-5250005&quot;</span>,<br>            <span class="hljs-string">&quot;Add&quot;</span>: <span class="hljs-string">&quot;高雄市804鼓山區蓮海路51號&quot;</span>,<br>            <span class="hljs-string">&quot;Zipcode&quot;</span>: <span class="hljs-string">&quot;804&quot;</span>,<br>            <span class="hljs-string">&quot;Travellinginfo&quot;</span>: <span class="hljs-string">&quot;搭高鐵至左營站下或搭臺鐵至高雄站下 → 轉搭高雄捷運至西子灣站下 → 轉搭高雄市公車(99路、橘1A路)至西子灣站下。&quot;</span>,<br>            <span class="hljs-string">&quot;Opentime&quot;</span>: <span class="hljs-string">&quot;西子灣海水浴場：10:00–16:00&quot;</span>,<br>            <span class="hljs-string">&quot;Gov&quot;</span>: <span class="hljs-string">&quot;397000000A&quot;</span>,<br>            <span class="hljs-string">&quot;Px&quot;</span>: <span class="hljs-string">&quot;120.26391&quot;</span>,<br>            <span class="hljs-string">&quot;Py&quot;</span>: <span class="hljs-string">&quot;22.62442&quot;</span><br>          &#125;<br>        ]<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;b69ffff9-23a5-44a6-a398-089b11a5f84c&quot;</span>,<br>  <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述內容為一個 JSON 格式資料，嘗試完成註解中的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 取得 Info 的陣列資料，並賦予至 newData 變數</span><br><span class="hljs-keyword">let</span> newData = data.data.XML_Head.Infos.Info;<br><br><span class="hljs-comment">// 取得 Info 陣列中第 2 筆資料的 Opentime 屬性值</span><br><span class="hljs-built_in">console</span>.log( data.data.XML_Head.Infos.Info[<span class="hljs-number">1</span>].Opentime ); <span class="hljs-comment">// 做法一</span><br><span class="hljs-built_in">console</span>.log( newData[<span class="hljs-number">1</span>].Opentime ); <span class="hljs-comment">// 做法二</span><br><span class="hljs-comment">// 輸出結果皆為 西子灣海水浴場：10:00–16:00</span><br></code></pre></td></tr></table></figure>

<h3 id="物件結合-if-判斷"><a href="#物件結合-if-判斷" class="headerlink" title="物件結合 if 判斷"></a>物件結合 if 判斷</h3><p>簡單範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myData = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">if</span>( myData.age &gt;= <span class="hljs-number">18</span> )&#123;<br>    myData.state = <span class="hljs-string">&#x27;符合入場條件&#x27;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    myData.state = <span class="hljs-string">&#x27;不符合入場條件&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log( myData );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;Mark&#x27;, age: 18, state: &#x27;符合入場條件&#x27;&#125;</span><br><span class="hljs-comment">// age: 18</span><br><span class="hljs-comment">// name: &quot;Mark&quot;</span><br><span class="hljs-comment">// state: &quot;符合入場條件&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h3 id="物件結合陣列與-if-判斷"><a href="#物件結合陣列與-if-判斷" class="headerlink" title="物件結合陣列與 if 判斷"></a>物件結合陣列與 if 判斷</h3><p>簡單範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：判斷 Mark 是否成年，若未成年則不得入場</span><br><span class="hljs-keyword">let</span> peopleData = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vivian&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">15</span>,<br>        <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>];<br><span class="hljs-keyword">if</span>( peopleData[<span class="hljs-number">0</span>].age &gt;= <span class="hljs-number">18</span> )&#123;<br>    peopleData[<span class="hljs-number">0</span>].state = <span class="hljs-string">&#x27;符合入場條件&#x27;</span>; <span class="hljs-comment">// 符合條件就重新賦予 state 屬性值</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    peopleData[<span class="hljs-number">0</span>].state = <span class="hljs-string">&#x27;不符合入場條件&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log( peopleData[<span class="hljs-number">0</span>] );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;name: &#x27;Mark&#x27;, age: 18, state: &#x27;符合入場條件&#x27;&#125;</span><br><span class="hljs-comment">// age: 18</span><br><span class="hljs-comment">// name: &quot;Mark&quot;</span><br><span class="hljs-comment">// state: &quot;符合入場條件&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>以上只是運作流程與邏輯的參考，而通常資料會有數筆，因此如果像上述範例一樣每有一筆資料就處理一次，效率就會很差且不易閱讀，因此通常會透過迴圈的方式來處理大批資料。</p>
</blockquote>
<h2 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h2><p>函式（function）的作用主要是把一系列相關的程式透過一個指令來包裝，並視情況執行，起手式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showText</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;一段文字內容&#x27;</span>);<br>&#125;<br>showText(); <span class="hljs-comment">// 執行函式 showText</span><br><span class="hljs-comment">// 輸出結果為 一段文字內容</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一組函式在註冊完成後並不會立即執行，需要透過 <code>functionName();</code> 方式來執行，而該函式在執行完內容後，就會終止。</p>
</blockquote>
<h3 id="巢狀函式"><a href="#巢狀函式" class="headerlink" title="巢狀函式"></a>巢狀函式</h3><p>範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showText</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;文字內容一&#x27;</span>);<br>    showText2();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showText2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;文字內容二&#x27;</span>);<br>&#125;<br>showText();<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 文字內容一</span><br><span class="hljs-comment">// 文字內容二</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>函式中若存在別的函式，則會先搜尋是否有該函式的存在，若有就執行該函式的內容，執行完畢後再跳回原本的函式接續執行後續的內容。</p>
</blockquote>
<h3 id="代入參數"><a href="#代入參數" class="headerlink" title="代入參數"></a>代入參數</h3><p>一個函式在執行時，是可以帶入參數的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log( num + num2 );<br>&#125;<br>calculate(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log( num, num2 );<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// num is not defined</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述範例在執行函式 <code>calculate</code> 時，代入了 <code>2</code>、<code>3</code> 兩個參數，此時第 2 行開始運算並得出結果為 <code>5</code>，而在函式外嘗試取得 <code>num</code> 的值後，輸出結果為顯示找不到相關內容，由此可知函式所代入的參數只能在該函式中作運用。</p>
<h3 id="return-回傳結果到函式外部"><a href="#return-回傳結果到函式外部" class="headerlink" title="return 回傳結果到函式外部"></a>return 回傳結果到函式外部</h3><p>前面提到函式所代入的參數只能使用在該函式中，但如果要在函式外做使用，可以透過 <code>return</code> 來將<strong>函式運算後的結果</strong>傳遞到函式的外部，此時就可以透過宣告變數等方式，來接收被傳遞到函式外的值，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> num + num2; <span class="hljs-comment">// 將運算結果回傳到函式之外（第 4 行）</span><br>&#125;<br><span class="hljs-keyword">let</span> result = calculate(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log( result );<br><span class="hljs-comment">// 輸出結果為 15</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>換句話說，<code>calculate(5, 10)</code> 可以直接當作 <code>15</code>。</p>
</blockquote>
<p>除了上述範例在函式內直接回傳 <code>num + num2</code> 的運算結果之外，也可以先將運算結果賦予到一變數中，再透過 <code>return</code> 回傳<strong>該變數的值</strong>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> sum = num + num2;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">let</span> result = calculate(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log( <span class="hljs-string">`運算結果等於<span class="hljs-subst">$&#123;result&#125;</span>`</span> );<br><span class="hljs-comment">// 輸出結果為 &#x27;運算結果等於15&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>函式內所宣告的變數與參數一樣，只能在該函式內使用，而 <code>return</code> 回傳的只有運算後的結果，並非該變數本身。</p>
</blockquote>
<h3 id="return-中斷函式"><a href="#return-中斷函式" class="headerlink" title="return 中斷函式"></a>return 中斷函式</h3><p>return 除了能夠回傳結果，還具有中斷函式執行的作用，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> sum = num + num2;<br>    <span class="hljs-keyword">return</span> sum;  <span class="hljs-comment">// 回傳結果後在此中斷</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;一段文字內容&#x27;</span>); <span class="hljs-comment">// 因 return 中斷而不執行</span><br>&#125;<br><span class="hljs-keyword">let</span> result = calculate(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log( result );<br><span class="hljs-comment">// 輸出結果為 15</span><br></code></pre></td></tr></table></figure>

<h3 id="return-應用範例"><a href="#return-應用範例" class="headerlink" title="return 應用範例"></a>return 應用範例</h3><p><strong>情境一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判斷成績是否及格</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkScore</span>(<span class="hljs-params">score</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>( <span class="hljs-number">100</span> &gt;= score &amp;&amp; score &gt;= <span class="hljs-number">60</span> )&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;成績及格&#x27;</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-number">60</span> &gt; score &amp;&amp; score &gt;= <span class="hljs-number">0</span> )&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;成績不及格&#x27;</span>; <span class="hljs-comment">// 回傳結果至 exam 後程式在此中斷</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;資料有誤&#x27;</span>; <span class="hljs-comment">// 回傳結果至 exam2 後程式在此中斷</span><br>&#125;<br><span class="hljs-keyword">let</span> exam = checkScore(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">let</span> exam2 = checkScore(<span class="hljs-number">120</span>);<br><span class="hljs-built_in">console</span>.log( exam, exam2 );<br><span class="hljs-comment">// 輸出結果為 &#x27;成績不及格&#x27; &#x27;資料有誤&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>情境二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判斷兩數字相除是否可整除</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> remainder = num % num2;<br>  <span class="hljs-keyword">if</span>( remainder == <span class="hljs-number">0</span> )&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;可以整除&#x27;</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`餘數為<span class="hljs-subst">$&#123;remainder&#125;</span>，不可整除`</span>; <span class="hljs-comment">// 回傳結果至 result 後程式在此中斷</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> result =  calculate(<span class="hljs-number">100</span>, <span class="hljs-number">12</span>);<br><span class="hljs-built_in">console</span>.log( result );<br><span class="hljs-comment">// 輸出結果為 &#x27;餘數為4，不可整除&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>情境三</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判斷計算結果總次數</span><br><span class="hljs-keyword">let</span> calcNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全域變數</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num, num2</span>)</span>&#123;<br>  calcNum += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> remainder = num % num2;<br>  <span class="hljs-keyword">if</span>( remainder == <span class="hljs-number">0</span> )&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;可以整除&#x27;</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`餘數為<span class="hljs-subst">$&#123;remainder&#125;</span>，不可整除`</span>; <span class="hljs-comment">// 回傳結果至 result 後程式在此中斷</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> result =  calculate(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br><span class="hljs-built_in">console</span>.log( result, <span class="hljs-string">`目前總共計算<span class="hljs-subst">$&#123;calcNum&#125;</span>次`</span> );<br><span class="hljs-comment">// 輸出結果為 &#x27;可以整除&#x27; &#x27;目前總共計算1次&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>從範例中第 4 行可得知，當函式中找不到宣告的變數時，會往全域搜尋是否存在相同名稱的變數。</p>
</blockquote>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（Document Object Model）簡單來說，就是將一個 HTML 的文件組成內容（標籤、文字、圖片等），以樹狀結構來表示的模型，詳細資料可參考此<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model">連結</a>。</p>
<h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p>透過 querySelector 可以選取網頁中的元素（標籤、class 選擇器、id 選擇器），語法格式為 <code>document.querySelector(&#39;網頁元素&#39;)</code>，以 id 選擇器為例，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">botton</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Botton<span class="hljs-tag">&lt;/<span class="hljs-name">botton</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(el);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &lt;botton id=&quot;btn&quot;&gt;Botton&lt;/botton&gt;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果選取的元素有綁定 id 屬性，也能使用 getElementById 方式來取得該元素節點。</p>
</blockquote>
<h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p>雖然 querySelector 可以選取網頁中的元素，但是相同名稱的元素存在多個時，只有第一個會被選取到，此時可以使用 querySelectorAll 來選取多個元素，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> els = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// NodeList[3]</span><br><span class="hljs-comment">// 0: a</span><br><span class="hljs-comment">// 1: a</span><br><span class="hljs-comment">// 2: a</span><br><span class="hljs-comment">// length: 3</span><br><span class="hljs-comment">// [[Prototype]]: NodeList</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述 JS 範例中得知，透過 querySelectorAll 的方式選取到所有的 a 標籤，而資料結構 <code>NodeList</code> 是一種有序的節點列表，也屬於陣列，因此可以透過中括號的方式來指定想要選取的內容，延續先前範例，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> els = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(els[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">// 輸出結果為 a</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>querySelector 會回傳一個 DOM，而 querySelector 則是回傳一個陣列。</p>
</blockquote>
<h3 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h3><p>如果需要修改元素的純文字內容，可以使用 textContent，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.title&#x27;</span>);<br>el.textContent = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上述 JS 範例中，第 3 行將元素 <code>.title</code> 的文字內容 Title 修改為 Hello。</p>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>與先前 textContent 的差異在於，innerHTML 除了純文字以外，還可以新增 HTML 標籤與相關內容，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.links&#x27;</span>);<br>el.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;&lt;li&gt;Google&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;Yahoo&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;Youtube&lt;/li&gt;&lt;/ul&gt;`</span>;<br></code></pre></td></tr></table></figure>

<p>上述 JS 範例中，第 3 行使用 <code>innerHTML</code> 新增一組列表 <code>ul</code> 與其文字內容，而所新增的元素內容可透過<strong>反引號</strong>（樣板字面值）的方式來包覆。</p>
<blockquote>
<p>使用 <code>innerHTML</code> 新增標籤後，若區塊內原先已有其他標籤，舊有的標籤內容會直接被清空並取代為新增的標籤內容。</p>
</blockquote>
<p>此外，透過 innerHTML 所加入的標籤中，也能夠帶入變數，延續先前範例，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 未帶入變數</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.links&#x27;</span>);<br>el.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;&lt;li&gt;Google&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;Yahoo&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/&quot;&gt;Youtube&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 帶入變數</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.links&#x27;</span>);<br><span class="hljs-keyword">const</span> myLink = <span class="hljs-string">&#x27;https://www.youtube.com/&#x27;</span>;<br>el.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;&lt;li&gt;Google&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;Yahoo&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;&lt;a href=<span class="hljs-subst">$&#123;myLink&#125;</span>&gt;Youtube&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`</span>;<br></code></pre></td></tr></table></figure>

<h3 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h3><p>透過 setAttribute 可設定 HTML 標籤中的屬性，格式為 <code>setAttribute(&#39;標籤屬性&#39;,&#39;屬性內容&#39;)</code>，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-selector-class">.text-primary</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> myLink = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.link&#x27;</span>);<br>myLink.setAttribute(<span class="hljs-string">&#x27;href&#x27;</span>,<span class="hljs-string">&#x27;https://www.google.com/&#x27;</span>);<br>myLink.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);<br></code></pre></td></tr></table></figure>



<h3 id="取得節點內容"><a href="#取得節點內容" class="headerlink" title="取得節點內容"></a>取得節點內容</h3><p>前面介紹到的 textContent、innerHTML、setAttribute 都是屬於寫入內容，若要取得內容可以使用以下做法：</p>
<p><strong>取得標籤中的純文字</strong></p>
<p>textContent 可寫入純文字，也可以取得標籤中的純文字內容，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.title&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(el.textContent); <span class="hljs-comment">// 取得 h1 標籤中的純文字內容</span><br><span class="hljs-comment">// 輸出結果為 Title</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>透過 textContent 所寫入的純文字，也可透過上述方式來取得純文字內容。</p>
</blockquote>
<p><strong>取得 HTML 標籤</strong></p>
<p>innerHTML 可寫入標籤，同時也可以取得標籤，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Google<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Yahoo<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Youtube<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.links&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(el.innerHTML); <span class="hljs-comment">// 取得 .links 區塊中的標籤內容</span><br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &lt;ul&gt;</span><br><span class="hljs-comment">//   &lt;li&gt;Google&lt;/li&gt;</span><br><span class="hljs-comment">//   &lt;li&gt;Yahoo&lt;/li&gt;</span><br><span class="hljs-comment">//   &lt;li&gt;Youtube&lt;/li&gt;</span><br><span class="hljs-comment">// &lt;/ul&gt;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>透過 innerHTML 所寫入的標籤，也可透過上述方式來取得標籤內容。</p>
</blockquote>
<p><strong>取得標籤屬性內容</strong></p>
<p>標籤屬性相關內容可透過 getAttribute 來取得，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.link&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(el.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)); <span class="hljs-comment">// 取得 a 標籤的 href 屬性內容</span><br><span class="hljs-built_in">console</span>.log(el.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>)); <span class="hljs-comment">// 取得 a 標籤的 class 屬性名稱</span><br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#x27;https://www.google.com/&#x27;</span><br><span class="hljs-comment">// &#x27;link&#x27;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h3 id="表單值取得與修改"><a href="#表單值取得與修改" class="headerlink" title="表單值取得與修改"></a>表單值取得與修改</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;txt&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文字內容&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;高雄&quot;</span>&gt;</span>高雄<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;台北&quot;</span>&gt;</span>台北<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>取得表單值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.txt&#x27;</span>);<br><span class="hljs-keyword">const</span> el2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#city&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(el.value, el2.value);<br><span class="hljs-comment">// 輸出結果為 &#x27;文字內容&#x27; &#x27;高雄&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>修改表單值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.txt&#x27;</span>);<br>el.value = <span class="hljs-string">&#x27;修改後的文字內容&#x27;</span>; <span class="hljs-comment">// 重新賦予 .txt 的 value 值</span><br><span class="hljs-keyword">const</span> el2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#city&#x27;</span>);<br>el2.value = <span class="hljs-string">&#x27;台北&#x27;</span>; <span class="hljs-comment">// 變更預設顯示的值</span><br></code></pre></td></tr></table></figure>

<h3 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h3><p>透過 nodeName 可以回傳目前 DOM 的節點名稱，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(btn.nodeName);<br><span class="hljs-comment">// 輸出結果為 BUTTON</span><br></code></pre></td></tr></table></figure>

<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>如果是針對 class 的屬性值，可以透過 classList 來達成某些動作，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkBox&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;check active&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkBox = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;checkBox&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(checkBox.classList);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 0: &quot;check&quot;</span><br><span class="hljs-comment">// 1: &quot;active&quot;</span><br><span class="hljs-comment">// length: 2</span><br><span class="hljs-comment">// value: &quot;check active&quot;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><strong>新增 class</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">checkBox.classList.add(<span class="hljs-string">&#x27;className&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>移除 class</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">checkBox.classList.remove(<span class="hljs-string">&#x27;className&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>切換 class</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">checkBox.classList.toggle(<span class="hljs-string">&#x27;className&#x27;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上述 toggle 會根據 class 名稱是否存在來執行動作，有就移除該類別名稱，沒有則是加入。</p>
</blockquote>
<p>此外，classList 也能搭配 contains 來判斷 class 列表中，是否存在指定的<strong>一個</strong>類別名稱，以前面範例來說，結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(checkBox.classList.contains(<span class="hljs-string">&#x27;active&#x27;</span>));<br><span class="hljs-comment">// 輸出結果為 true</span><br></code></pre></td></tr></table></figure>





<h2 id="event-事件"><a href="#event-事件" class="headerlink" title="event 事件"></a>event 事件</h2><p>event 表示在一個 DOM 元素上所觸發的事件，像常見的滑鼠點擊就屬於事件的一種，其他事件可參考此<a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">連結</a>。</p>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>DOM 的觸發事件可以透過 addEventListener() 方法來進行註冊，而該方法會有三個參數，分別是事件名稱、觸發後執行的函式、捕獲或冒泡階段的執行（在此不做說明），以點擊事件 <code>click</code> 為例，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">// 註冊事件監聽</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;已被點擊&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// 觸發事件時輸出結果為 已被點擊</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>事件監聽中的函式僅在事件觸發後才會執行。</p>
</blockquote>
<p>事件監聽中的函式，會帶入一個參數 <code>e</code>（event），而這個參數的結構是一個物件，主要是存放與該事件有關的所有屬性與其相關資訊，以前面範例來說，當事件觸發時，回傳結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">PointerEvent &#123;<span class="hljs-attr">isTrusted</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">pointerId</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">pressure</span>: <span class="hljs-number">0</span>, …&#125;<br></code></pre></td></tr></table></figure>

<p>因為是物件的關係，也可以指定想要顯示的資訊，如事件觸發後，回傳觸發事件的 DOM 當前位置，做法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.target);<br>&#125;)<br><span class="hljs-comment">// 觸發事件時輸出結果為 &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;Button&lt;/button&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="觸發事件目標"><a href="#觸發事件目標" class="headerlink" title="觸發事件目標"></a>觸發事件目標</h3><p>在上個範例有提到，事件監聽中的函式所帶入的參數 <code>e</code> 會回傳一個紀錄所有相關屬性的物件，而其中的屬性 <code>target</code> 代表觸發事件的元素位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.target);<br>&#125;)<br><span class="hljs-comment">// 觸發事件時輸出結果為 &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;Button&lt;/button&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="範圍取值"><a href="#範圍取值" class="headerlink" title="範圍取值"></a>範圍取值</h3><p>在項目較多的情情形下，如果都針對個別元素進行事件監聽，程式碼可能會較為繁雜，因此有時候會希望一個範圍內的所有元素都能夠觸發事件，做法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-1&quot;</span>&gt;</span>item-1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-2&quot;</span>&gt;</span>item-2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-3&quot;</span>&gt;</span>item-3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-4&quot;</span>&gt;</span>item-4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> els = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list&#x27;</span>); <span class="hljs-comment">// 監聽整個 ul 範圍</span><br>els.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// 輸出觸發對象的純文字內容</span><br>&#125;);<br><span class="hljs-comment">// 觸發事件時輸出結果 ----</span><br><span class="hljs-comment">// 點擊 item-1 範圍時，輸出結果為 &lt;li class=&quot;item-1&quot;&gt;item-1&lt;/li&gt;</span><br><span class="hljs-comment">// 點擊 item-2 範圍時，輸出結果為 &lt;li class=&quot;item-2&quot;&gt;item-2&lt;/li&gt;</span><br><span class="hljs-comment">// 點擊 item-3 範圍時，輸出結果為 &lt;li class=&quot;item-3&quot;&gt;item-3&lt;/li&gt;</span><br><span class="hljs-comment">// 點擊 item-4 範圍時，輸出結果為 &lt;li class=&quot;item-4&quot;&gt;item-4&lt;/li&gt;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>從上方範例可得知，因為事件監聽的範圍為整個 <code>ul</code>，因此當範圍內的不同元素所佔有的範圍被點擊時，輸出的結果也會對應到不同的內容。</p>
<p><strong>範例一</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list&#x27;</span>);<br>list.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.nodeName == <span class="hljs-string">&#x27;INPUT&#x27;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;點擊到按鈕&#x27;</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未點擊到按鈕&#x27;</span>, <span class="hljs-string">`目前點擊的對象是 <span class="hljs-subst">$&#123;e.target.nodeName&#125;</span>`</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>如上述範例，事件監聽範圍為 <code>.list</code> 區塊，當範圍內點擊事件觸發時，判斷觸發對象的節點名稱是否為 <code>INPUT</code> 而輸出對應的內容。</p>
<p><strong>範例二</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;點擊到按鈕&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> item = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.item&#x27;</span>);<br>item.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>) == <span class="hljs-string">&#x27;btn&#x27;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.target.getAttribute(<span class="hljs-string">&#x27;value&#x27;</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述範例則是透過 <code>getAttribute</code> 來判斷點擊到的元素標籤屬性 <code>class</code> 值是否為 <code>btn</code>，若是才會執行下方程式碼。</p>
<p><strong>範例三</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Title-1<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按鈕1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Title-2<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按鈕2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Title-3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按鈕3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//js</span><br><span class="hljs-keyword">const</span> itemList = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.item-list&#x27;</span>);<br>itemList.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>) !== <span class="hljs-string">&#x27;btn&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e.target.getAttribute(<span class="hljs-string">&#x27;value&#x27;</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述範例同理範例二，只是判斷條件變成點擊到的元素標籤屬性 <code>class</code> 值若不是 <code>btn</code>，則中斷程式碼。</p>
<h3 id="data-屬性取值"><a href="#data-屬性取值" class="headerlink" title="data- 屬性取值"></a>data- 屬性取值</h3><p>有些時候可能會額外加入一些需要使用的自訂屬性名稱，而為了讓這類型的屬性名稱達到通用，HTML5 新增了 <code>data-</code> 的屬性，格式為 <code>data-自訂名稱=&#39;自訂值&#39;</code>，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-order</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-order</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-order</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list&#x27;</span>);<br>list.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.nodeName == <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.target.getAttribute(<span class="hljs-string">&#x27;data-order&#x27;</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>補充知識：有時候會在 html 標籤中埋入 <code>data-id</code> 屬性，而該屬性通常會對應陣列中每筆物件的 id 類型屬性，為了確保每個 id 的獨一無二，可以使用 Date 物件的方式來達成，做法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(); <span class="hljs-comment">// 不同時間生成的物件，id 值都不同</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Date 物件儲存了世界標準時間（UTC）自 1979/01/01 開始至今的時間，以毫秒單位儲存，透過上述方式可以取得不同的時間戳，因此適合做為 id 使用，相關內容可參考此<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Date">文章</a>。</p>
</blockquote>
<h3 id="closest-最近節點"><a href="#closest-最近節點" class="headerlink" title="closest 最近節點"></a>closest 最近節點</h3><p>有時候可能會因為 HTML 結構較複雜（層數較多）導致 <code>e.target</code> 無法選取到指定的元素，此時透過 <code>closest</code> 就能夠取得距離該元素最近的指定節點，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>項目<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> listItem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list li&#x27;</span>);<br>listItem.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(e.target);<br>  <span class="hljs-built_in">console</span>.log(e.target.closest(<span class="hljs-string">&#x27;.list&#x27;</span>));<br>  <span class="hljs-built_in">console</span>.log(e.target.closest(<span class="hljs-string">&#x27;a&#x27;</span>));<br>&#125;);<br><span class="hljs-comment">// 點擊時輸出結果 ----</span><br><span class="hljs-comment">// &lt;a&gt;項目&lt;/a&gt;</span><br><span class="hljs-comment">// &lt;ul class=&quot;list&quot;&gt;...&lt;/ul&gt;</span><br><span class="hljs-comment">// &lt;li&gt;&lt;a&gt;項目&lt;/a&gt;&lt;/li&gt;</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><strong>應用範例 - 簡易 todolist</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;txt&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;輸入代辦事項&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;新增代辦事項&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;p&gt;待辦事項&lt;/p&gt;</span><br><span class="hljs-comment">    &lt;input type=&quot;button&quot; class=&quot;delete&quot; value=&quot;刪除&quot;&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> txt = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.txt&quot;</span>);<br><span class="hljs-keyword">const</span> save = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.save&quot;</span>);<br><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.list&quot;</span>);<br><br><span class="hljs-keyword">let</span> data = [<br>  <span class="hljs-comment">// &#123;</span><br>  <span class="hljs-comment">//   content: &quot;待辦事項&quot;</span><br>  <span class="hljs-comment">// &#125;</span><br>];<br><span class="hljs-comment">// 初始畫面渲染</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.list&quot;</span>);<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    str += <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;li&gt;</span><br><span class="hljs-string">    &lt;p&gt;<span class="hljs-subst">$&#123;item.content&#125;</span>&lt;/p&gt;</span><br><span class="hljs-string">    &lt;input type=&quot;button&quot; class=&quot;delete&quot; data-id=&quot;<span class="hljs-subst">$&#123;item.id&#125;</span>&quot; value=&quot;刪除&quot;&gt;</span><br><span class="hljs-string">  &lt;/li&gt;`</span>;<br>  &#125;);<br>  list.innerHTML = str;<br>&#125;<br>renderData();<br><br><span class="hljs-comment">// 新增邏輯</span><br>save.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (txt.value == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> addData = &#123;&#125;;<br>  addData.content = txt.value;<br>  addData.id = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime().toString();<br>  data.push(addData);<br>  renderData(); <span class="hljs-comment">// 新增資料後再次渲染畫面</span><br>  txt.value = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 刪除邏輯</span><br>list.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (e.target.nodeName !== <span class="hljs-string">&quot;INPUT&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> deleteId = data.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.id === e.target.dataset.id); <span class="hljs-comment">// 取得刪除資料的索引值</span><br>  data.splice(deleteId, <span class="hljs-number">1</span>);<br>  renderData(); <span class="hljs-comment">// 刪除資料後再次渲染畫面</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>以上範例使用了先前提到的範圍取值方式來進行事件監聽，並且透過 <code>findIndex</code> 取得自訂屬性 <code>data-id</code> 值，再透過 <code>splice</code> 達到刪除點擊的項目，呈現結果如下：</p>
<iframe src="https://codepen.io/Cliff_hex/embed/BarBpVd?default-tab=resault" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe>


<h3 id="取消默認行為"><a href="#取消默認行為" class="headerlink" title="取消默認行為"></a>取消默認行為</h3><p>HTML 標籤會存在一些默認行為，以 a 標籤來說，點擊標籤的連結會跳轉到指定的頁面就屬於一種默認的行為，如果要避免這些行為的話，可以使用 <code>e.preventDefault()</code> 方法來達成，範例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/&quot;</span>&gt;</span>Google<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>);<br>link.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  e.preventDefault();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未跳轉新頁面&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// 當點擊 a 標籤時，網頁不會跳轉，且輸出結果為 &#x27;未跳轉新頁面&#x27;</span><br></code></pre></td></tr></table></figure>





<h2 id="迴圈-陣列操作"><a href="#迴圈-陣列操作" class="headerlink" title="迴圈/陣列操作"></a>迴圈/陣列操作</h2><p>相同性質的資料若資料筆數過多，通常會透過迴圈迭代的方式，來重複執行相同的動作以取得或組合資料內容，而迴圈常聽到的迭代指的是重複過程的意思，一次迭代表示一次的重複過程。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++ )&#123;<br>    <span class="hljs-built_in">console</span>.log( i );<br>&#125;<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，<code>for</code> 小括號的三個項目依序分別表示<strong>初始狀態</strong>、<strong>執行條件</strong>、<strong>變更值</strong>，在此宣告一個變數 <code>i</code> 初始值為 <code>0</code>，當 <code>i</code> 值小於 <code>3</code> 的判斷結果為 <code>true</code> 時，執行大括號中的內容，每執行完一次 <code>i</code> 值 <code>+1</code>，接著運行第二次直到不滿足執行條件為止。</p>
<blockquote>
<p>for 迴圈的小括號中使用 <code>var</code> 宣告變數 <code>i</code> 時，該變數會屬於全域變數。</p>
</blockquote>
<h4 id="for-陣列操作範例"><a href="#for-陣列操作範例" class="headerlink" title="for 陣列操作範例"></a>for 陣列操作範例</h4><p><strong>情境一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：列出所有種類的水果名稱</span><br><span class="hljs-keyword">let</span> fruitDetail = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Apple&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">30</span>,<br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;banana&#x27;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-number">20</span>,<br>    &#125;<br>]<br><span class="hljs-keyword">let</span> fruitNum = fruitDetail.length;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;fruitNum; i++ )&#123;<br>    <span class="hljs-built_in">console</span>.log( fruitDetail[i].name );<br>&#125;<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// Apple</span><br><span class="hljs-comment">// banana</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><strong>情境二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 情境：加總所有學校的學生人數</span><br><span class="hljs-keyword">let</span> school = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;學校A&#x27;</span>,<br>        <span class="hljs-attr">studentNum</span>: <span class="hljs-number">35</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;學校B&#x27;</span>,<br>        <span class="hljs-attr">studentNum</span>: <span class="hljs-number">32</span><br>    &#125;<br>];<br><span class="hljs-keyword">let</span> schoolNum = school.length;<br><span class="hljs-keyword">let</span> studentTotal = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;schoolNum; i++ )&#123;<br>    studentTotal += school[i].studentNum;<br>&#125;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-string">`全部學生總共有<span class="hljs-subst">$&#123;studentTotal&#125;</span>人`</span> );<br><span class="hljs-comment">// 輸出結果為 全部學生總共有67人</span><br></code></pre></td></tr></table></figure>

<p><strong>情境三</strong></p>
<p>加入 if 條件判斷</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：列出正在下雨的城市</span><br><span class="hljs-keyword">let</span> cityStatus = [<br>    &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;高雄&#x27;</span>,<br>        <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;晴天&#x27;</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;台南&#x27;</span>,<br>        <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;下雨&#x27;</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;台北&#x27;</span>,<br>        <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;下雨&#x27;</span><br>    &#125;<br>];<br><span class="hljs-keyword">let</span> cityNum = cityStatus.length;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;cityNum; i++ )&#123;<br>    <span class="hljs-keyword">if</span>( cityStatus[i].state == <span class="hljs-string">&#x27;下雨&#x27;</span> )&#123;<br>        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`<span class="hljs-subst">$&#123;cityStatus[i].city&#125;</span>天氣為雨天`</span> );<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 台南天氣為雨天</span><br><span class="hljs-comment">// 台北天氣為雨天</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<h4 id="break-中斷迴圈"><a href="#break-中斷迴圈" class="headerlink" title="break 中斷迴圈"></a>break 中斷迴圈</h4><p>若希望 for 迴圈在執行過程中當滿足了某些條件後，就終止迴圈執行，可以使用 <code>break</code> 來中斷動作，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：集點活動，找出最先累積滿 100 點的人</span><br><span class="hljs-keyword">let</span> people = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mark&#x27;</span>,<br>        <span class="hljs-attr">points</span>: <span class="hljs-number">89</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vivian&#x27;</span>,<br>        <span class="hljs-attr">points</span>: <span class="hljs-number">102</span><br>    &#125;,&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>        <span class="hljs-attr">points</span>: <span class="hljs-number">115</span><br>    &#125;<br>];<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;people.length; i++ )&#123;<br>    <span class="hljs-keyword">if</span>( people[i].points &gt;= <span class="hljs-number">100</span> )&#123;<br>        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`最先累積滿100點的人是<span class="hljs-subst">$&#123;people[i].name&#125;</span>，總共有<span class="hljs-subst">$&#123;people[i].points&#125;</span>點!`</span> );<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 迴圈運行到第2筆時達成條件，因此終止迴圈</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 輸出結果為 最先累積滿100點的人是Vivian，總共有102點!</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>範例中若未加上 <code>break</code>，則輸出結果會列出所有滿足 <code>points &gt;= 100</code> 的內容，而 break 僅能在 for 迴圈中使用。</p>
</blockquote>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">let</span> data = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>];<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, index, array);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;結束迴圈&#x27;</span>);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// red 1 (3) [&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;]</span><br><span class="hljs-comment">// green 2 (3) [&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;]</span><br><span class="hljs-comment">// blue 0 (3) [&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;]</span><br><span class="hljs-comment">// 結束迴圈</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述範例中，第 3 行的部分可以看到 <code>forEach()</code> 會放入一個函式，而這個函式的執行次數，會根據陣列中的資料筆數而定，以範例來說，<code>data</code> 陣列中的資料總共有三筆，因此會執行三次，接著該函式可以帶入三個變數，分別表示<strong>當前對象的值</strong>、<strong>索引值</strong>、<strong>陣列中所有資料</strong>，直到陣列中的所有資料都執行完畢後，才會接著執行下方的程式碼。</p>
<blockquote>
<p>forEach 無法被 return 等語法中斷（無法中斷迴圈執行）。</p>
</blockquote>
<h4 id="forEach-陣列操作範例"><a href="#forEach-陣列操作範例" class="headerlink" title="forEach 陣列操作範例"></a>forEach 陣列操作範例</h4><p><strong>範例一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 數值累加</span><br><span class="hljs-keyword">let</span> data = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">30</span>,<span class="hljs-number">12</span>];<br><span class="hljs-keyword">let</span> calcNum = <span class="hljs-number">0</span>;<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  calcNum += item;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(calcNum);<br><span class="hljs-comment">// 輸出結果為 57</span><br></code></pre></td></tr></table></figure>

<p>如上述範例所示，宣告變數 <code>calcNum</code> 且值為 <code>0</code>，此時當 <code>data</code> 透過 <code>forEach</code> 執行第一次時，變數 <code>calcNum</code> 的值會加上陣列 <code>data</code> 中的第一個數值 <code>10</code>，接著相同的動作再進行第二次，依此類推，最終完成迴圈後的加總結果為 <code>57</code>。</p>
<p>接下來的範例邏輯大同小異，因此不另外做說明。</p>
<p><strong>範例二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 計算 data 中所有偶數的加總</span><br><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">let</span> evenTotal = <span class="hljs-number">0</span>;<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>( item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ) &#123;<br>    evenTotal  += item;<br>  &#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(evenTotal);<br><span class="hljs-comment">// 輸出結果為 30</span><br></code></pre></td></tr></table></figure>

<p><strong>範例三</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 加總所有學校的學生人數</span><br><span class="hljs-keyword">let</span> school = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;學校A&quot;</span>,<br>    <span class="hljs-attr">studentNum</span>: <span class="hljs-number">35</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;學校B&quot;</span>,<br>    <span class="hljs-attr">studentNum</span>: <span class="hljs-number">32</span><br>  &#125;<br>];<br><span class="hljs-keyword">let</span> studentTotal = <span class="hljs-number">0</span>;<br>school.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  studentTotal += item.studentNum;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(studentTotal);<br><span class="hljs-comment">// 輸出結果為 67</span><br></code></pre></td></tr></table></figure>

<p><strong>範例四</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 計算及格與不及格人數</span><br><span class="hljs-keyword">let</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Marry&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;girl&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">85</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">59</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alvin&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">90</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">48</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sophia&#x27;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;girl&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">75</span><br>  &#125;<br>];<br><span class="hljs-keyword">let</span> boyPass = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> girlPass = <span class="hljs-number">0</span>;<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>( item.sex == <span class="hljs-string">&#x27;boy&#x27;</span> &amp;&amp; item.score &gt;= <span class="hljs-number">60</span> ) &#123;<br>    boyPass ++;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( item.sex == <span class="hljs-string">&#x27;girl&#x27;</span> &amp;&amp; item.score &gt;= <span class="hljs-number">60</span> )&#123;<br>    girlPass ++;<br>  &#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`男生及格人數 <span class="hljs-subst">$&#123;boyPass&#125;</span> 人，女生及格人數 <span class="hljs-subst">$&#123;girlPass&#125;</span> 人`</span>);<br><span class="hljs-comment">// 輸出結果為 男生及格人數 1 人，女生及格人數 2 人</span><br></code></pre></td></tr></table></figure>

<p><strong>範例五</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 篩選出免費與投幣式的充電站</span><br><span class="hljs-keyword">let</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A充電站&#x27;</span>,<br>    <span class="hljs-attr">charge</span>: <span class="hljs-string">&#x27;投幣式&#x27;</span><br>  &#125;, &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;B充電站&#x27;</span>,<br>    <span class="hljs-attr">charge</span>: <span class="hljs-string">&#x27;投幣式&#x27;</span><br>  &#125;, &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;C充電站&#x27;</span>,<br>    <span class="hljs-attr">charge</span>: <span class="hljs-string">&#x27;免費&#x27;</span><br>  &#125;<br>];<br><span class="hljs-keyword">let</span> newData = &#123; <span class="hljs-comment">// 整合新的資料</span><br>  <span class="hljs-attr">pay</span>: [],<br>  <span class="hljs-attr">free</span>: []<br>&#125;;<br>data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>( item.charge == <span class="hljs-string">&#x27;投幣式&#x27;</span> ) &#123;<br>    newData.pay.push(item.name);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    newData.free.push(item.name);<br>  &#125;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(newData);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`收費充電站總共 <span class="hljs-subst">$&#123;newData.pay.length&#125;</span> 個，免費充電站總共 <span class="hljs-subst">$&#123;newData.free.length&#125;</span> 個`</span>);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// &#123;pay: Array(2), free: Array(1)&#125;</span><br><span class="hljs-comment">// free: [&#x27;C充電站&#x27;]</span><br><span class="hljs-comment">// pay: (2) [&#x27;A充電站&#x27;, &#x27;B充電站&#x27;]</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// 收費充電站總共 2 個，免費充電站總共 1 個</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><strong>範例六</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">let</span> cityStatus = [<br>  &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;高雄&quot;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;晴天&quot;</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;台南&quot;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;下雨&quot;</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;台北&quot;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&quot;下雨&quot;</span><br>  &#125;<br>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 初始化（預設載入）</span><br>  <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list&#x27;</span>);<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br>  cityStatus.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;item.city&#125;</span>目前<span class="hljs-subst">$&#123;item.state&#125;</span>。&lt;/li&gt;`</span><br>   	str += content;<br>  &#125;);<br>  list.innerHTML = str;<br>  <span class="hljs-built_in">console</span>.log(list.textContent); <span class="hljs-comment">// 測試</span><br>&#125;<br>init(); <span class="hljs-comment">// 網頁載入時執行</span><br><br><span class="hljs-comment">// 輸出結果為 高雄目前晴天。台南目前下雨。台北目前下雨。</span><br></code></pre></td></tr></table></figure>

<p>有時候會希望網頁載入時，某些程式碼就立即執行（如載入伺服器資料等），即初始化，此時可以參考上述範例 <code>init()</code> 的做法。</p>
<blockquote>
<p> 大部分的陣列處理方法都會回傳一個結果，而 forEach 不會。</p>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 原陣列</span><br><span class="hljs-keyword">const</span> newArr = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123; <span class="hljs-comment">// 產生的新陣列</span><br>  <span class="hljs-keyword">return</span> item * <span class="hljs-number">5</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr, newArr);<br><span class="hljs-comment">// 輸出結果為 [1, 2, 3] [5, 10, 15]</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>map</code> 在處理陣列時，會將原始陣列中的內容經過逐一運算並<strong>回傳結果</strong>，再將運算結果重新組合一個新的陣列，因此兩陣列長度會相同，如上述範例，將原陣列 <code>arr</code> 進行 <code>map</code> 陣列處理後所回傳的結果，賦予至新的陣列 <code>newArr</code> 中，而原陣列並沒有變化。</p>
<h4 id="map-陣列操作範例"><a href="#map-陣列操作範例" class="headerlink" title="map 陣列操作範例"></a>map 陣列操作範例</h4><p><strong>範例一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 將原陣列判斷後的結果賦予至物件中，並重組成新陣列</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">20</span>, <span class="hljs-number">18</span>, <span class="hljs-number">28</span>];<br><span class="hljs-keyword">const</span> newArr = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> calcNum = &#123;&#125;;<br>  calcNum.result = item &gt; <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">return</span> calcNum;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(newArr);<br><span class="hljs-comment">// 輸出結果為 [&#123;result: false&#125;, &#123;result: false&#125;, &#123;result: ture&#125;]</span><br></code></pre></td></tr></table></figure>

<p>補充說明：<code>map</code> 與 <code>forEach</code> 雖然都是陣列處理的方法，但是以 <code>map</code> 來說，需要使用 <code>return</code> 來回傳計算後的結果，即使不加上 <code>return</code> 也會回傳 <code>undefined</code>；而 <code>forEach</code> 無法使用 <code>return</code>，換句話說就是<strong>不會回傳任何東西</strong>，因此上述範例若改用 <code>forEach</code> 來處理陣列，會因為陣列本身並沒有被賦予值，所以輸出結果會是 <code>undefined</code>。</p>
<p>以使用時機來說，<code>forEach</code> 較適合用於需要逐一將陣列中的內容進行運算，或是組合成自訂的資料格式（HTML、物件等）時，但若是需要一個所有元素皆為原陣列回傳運算結果的新陣列，則較適合使用 <code>map</code>。</p>
<p><strong>範例二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 將原陣列的價格進行運算後新增屬性，並賦予至新陣列中</span><br><span class="hljs-keyword">const</span> foodList = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;豚骨拉麵&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">130</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;親子丼飯&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">80</span><br>  &#125;<br>];<br><span class="hljs-keyword">const</span> newList = foodList.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  item.newPrice = item.price * <span class="hljs-number">0.8</span>; <span class="hljs-comment">// 新增屬性</span><br>  <span class="hljs-keyword">return</span> item;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(newList);<br><span class="hljs-comment">// 輸出結果為 [&#123;name: &#x27;豚骨拉麵&#x27;, price: 130, newPrice: 104&#125;, &#123;name: &#x27;親子丼飯&#x27;, price: 80, newPrice: 64&#125;]</span><br></code></pre></td></tr></table></figure>

<h4 id="join-陣列轉字串"><a href="#join-陣列轉字串" class="headerlink" title="join 陣列轉字串"></a>join 陣列轉字串</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Red&#x27;</span>, <span class="hljs-string">&#x27;Green&#x27;</span>, <span class="hljs-string">&#x27;Blue&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(arr.join(), arr.join(<span class="hljs-string">&#x27;&#x27;</span>), arr.join(<span class="hljs-string">&#x27;-&#x27;</span>));<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// Red,Green,Blue   // 不加入任何內容（預設為 &quot;,&quot;）</span><br><span class="hljs-comment">// RedGreenBlue     // 加入空字串</span><br><span class="hljs-comment">// Red-Green-Blue   // 加入 &quot;-&quot; 符號</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><code>join()</code> 可將陣列中的分隔符號更改為自訂的內容，並將該陣列轉換為一個字串，格式為 <code>array.jion(分隔符號/其他內容)</code>，預設（不加入任何內容）為半形逗號。</p>
<p><strong>範例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> foodList = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;豚骨拉麵&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">130</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;親子丼飯&quot;</span>,<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">80</span><br>  &#125;<br>];<br><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.list&#x27;</span>);<br><span class="hljs-keyword">const</span> newList = foodList.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  item.newPrice = item.price * <span class="hljs-number">0.8</span>; <span class="hljs-comment">// 新增屬性</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;item.name&#125;</span> 目前特價 <span class="hljs-subst">$&#123;item.newPrice&#125;</span> 元&lt;/li&gt;`</span>;<br>&#125;);<br>list.innerHTML = newList; <span class="hljs-comment">// 渲染到頁面中</span><br><span class="hljs-built_in">console</span>.log(newList);<br><span class="hljs-comment">// 輸出結果為 [&#x27;&lt;li&gt;豚骨拉麵 目前特價 104 元&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;親子丼飯 目前特價 64 元&lt;/li&gt;&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>以上範例將原陣列 <code>foodList</code> 中每筆資料的屬性 <code>price</code> 進行運算，並重組成一個新陣列 <code>newList</code>，最後希望將新陣列的內容組成字串，並透過 <code>innerHTML</code> 渲染到網頁上，但是如輸出結果所示，<code>map</code> 會產生一個陣列，因此每個項目之間會存在半形逗號，而這些逗號也會跟著被渲染到網頁中，此時就能使用 <code>join</code> 方法來將陣列轉為字串 。</p>
<p>在上述範例 <code>map</code> 方法末端加入 <code>.join(&#39;&#39;)</code>，做法如下所示，此時陣列 <code>newList</code> 中的所有半形逗號就會替換為空字串，而陣列本身也會被轉為一個字串，在渲染頁面時便不會出現半形逗號。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newList = foodList.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;<br>  item.newPrice = item.price * <span class="hljs-number">0.8</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;item.name&#125;</span> 目前特價 <span class="hljs-subst">$&#123;item.newPrice&#125;</span> 元&lt;/li&gt;`</span>;<br>&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// 陣列轉字串</span><br>list.innerHTML = newList;<br><span class="hljs-built_in">console</span>.log(newList);<br><span class="hljs-comment">// 輸出結果為 &#x27;&lt;li&gt;豚骨拉麵 目前特價 104 元&lt;/li&gt;&lt;li&gt;親子丼飯 目前特價 64 元&lt;/li&gt;&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">let</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Marry&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">85</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">59</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alvin&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">90</span><br>  &#125;<br>];<br><span class="hljs-keyword">let</span> newData = data.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.score &gt;= <span class="hljs-number">60</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(newData);<br><span class="hljs-comment">// 輸出結果為 [&#123;name: &#x27;Marry&#x27;, score: 85&#125;, &#123;name: &#x27;Alvin&#x27;, score: 90&#125;]</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>filter</code> 在處理陣列時，會將原陣列進行<strong>條件判斷</strong>並回傳為 <code>true</code> 的項目，再將這些項目組合成一個新陣列且不影響原陣列，如上述範例，篩選出符合條件的學生，並組成新陣列 <code>newData</code>，因此 <code>filter</code> 適合使用在需要針陣列中的項目進行條件篩選的情況下。</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">let</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Marry&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">85</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">59</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alvin&#x27;</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-number">90</span><br>  &#125;<br>];<br><span class="hljs-keyword">let</span> newData = data.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.score &gt;= <span class="hljs-number">60</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(newData);<br><span class="hljs-comment">// 輸出結果為 [&#123;name: &#x27;Marry&#x27;, score: 85&#125;]</span><br></code></pre></td></tr></table></figure>

<p>前面提到 <code>filter</code> 會回傳原陣列所有符合條件的項目並組合成新陣列，而 <code>find</code> 與 <code>filter</code> 相似，差別在於 <code>find</code> <strong>只回傳一次</strong>結果，並且是原陣列中<strong>第一筆</strong>為 <code>true</code> 的項目，如上述範例，雖然 <code>item[0]</code>、<code>item[2]</code> 都符合 <code>&gt;=60</code> 條件，但是從輸出結果中可以發現，僅 <code>item[0]</code> 有被回傳。</p>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">let</span> data = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Marry&#x27;</span>,<br>    <span class="hljs-attr">product</span>: <span class="hljs-string">&#x27;茄子&#x27;</span>,<br>    <span class="hljs-attr">orderNum</span>: <span class="hljs-number">130450</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leo&#x27;</span>,<br>    <span class="hljs-attr">product</span>: <span class="hljs-string">&#x27;榴槤&#x27;</span>,<br>    <span class="hljs-attr">orderNum</span>: <span class="hljs-number">100257</span><br>  &#125;,&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alvin&#x27;</span>,<br>    <span class="hljs-attr">product</span>: <span class="hljs-string">&#x27;三色豆&#x27;</span>,<br>    <span class="hljs-attr">orderNum</span>: <span class="hljs-number">100595</span><br>  &#125;<br>];<br><span class="hljs-keyword">const</span> orderId = data.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.orderNum == <span class="hljs-string">&#x27;100595&#x27;</span>;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`索引值為 <span class="hljs-subst">$&#123;orderId&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`顧客姓名 <span class="hljs-subst">$&#123;data[orderId].name&#125;</span>，購買品項 <span class="hljs-subst">$&#123;data[orderId].product&#125;</span>`</span>);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 索引值為 2</span><br><span class="hljs-comment">// 顧客姓名 Alvin，購買品項 三色豆</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><code>findIndex</code> 與 <code>find</code> 兩者都<strong>只回傳一次</strong>結果，且回傳原陣列中<strong>第一筆</strong>符合判斷條件（為 true）的項目，差別在於 <code>findIndex</code> 只回傳該項目的<strong>索引值</strong>，如上述範例所示，透過判斷訂單編號來回傳對應的索引值，並根據索引值取得其他相關屬性內容。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">const</span> num = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> totalNum = num.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;<br><br>  <span class="hljs-comment">// accumulator：  每次迭代/累加的回傳值</span><br>  <span class="hljs-comment">// currentValue： 當前迭代的項目</span><br>  <span class="hljs-comment">// accumulator：  當前迭代的項目索引值（可有可無）</span><br>  <span class="hljs-comment">// array：        陣列本身（可有可無）</span><br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`累加值 <span class="hljs-subst">$&#123;accumulator&#125;</span>，當前值 <span class="hljs-subst">$&#123;currentValue&#125;</span>，回傳結果 <span class="hljs-subst">$&#123;currentValue + accumulator&#125;</span>`</span>);<br>  <span class="hljs-keyword">return</span> accumulator + currentValue;<br>&#125;) <span class="hljs-comment">// initialValue：初始值/第一次傳入 accumulator 的值（可有可無/預設為陣列第一筆項目）</span><br><span class="hljs-built_in">console</span>.log(totalNum);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 累加值 1，當前值 2，回傳結果 3</span><br><span class="hljs-comment">// 累加值 3，當前值 3，回傳結果 6</span><br><span class="hljs-comment">// 累加值 6，當前值 4，回傳結果 10</span><br><span class="hljs-comment">// 累加值 10，當前值 5，回傳結果 15</span><br><span class="hljs-comment">// 15</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>先前提到的陣列處理方法（<code>map</code>、<code>filter</code> 等）都是回傳一個陣列，相較之下 <code>reduce</code> 方法在邏輯與結構都有較大的差異，<code>reduce</code> 會回傳一個值而非陣列，而 <code>reduce</code> 能讓每次迭代回傳的值再次運算。</p>
<p>如上述範例，<code>reduce</code> 需要代入兩個參數 <code>accumulator</code> 與 <code>currentValue</code>，分別表示<strong>累計值</strong>與<strong>當前的項目</strong>，範例中嘗試將陣列 <code>num</code> 中的所有值進行加總並回傳到變數 <code>totalNum</code>，過程中第 11 行的部分將兩個參數相加並 <code>return</code>，而這邊因為沒有加入初始值（<code>reduce</code> 函式結尾處）的關係，所以參數 <code>accumulator</code> 預設會代入陣列第一筆項目的值 <code>1</code>，此時因為參數 <code>currentValue</code> 會與前一個項目的值進行累加，前一個值取自第一筆項目，因此當前項目 <code>currentValue</code> 就會是第二筆，代入當前項目的值 <code>2</code> 之後，就開始進行第一次迴圈，運算的結果值會傳入累加值 <code>accumulator</code> 再以相同過程進行下一次迴圈，依此類推。</p>
<blockquote>
<p>可以理解成每次 <code>return</code> 的值都會傳入累計值 <code>accumulator</code> 當中，再以這個累計值執行下一次的迴圈，且累計值與當前項目兩者存在<strong>關聯性</strong>，詳細資訊可參考此<a href="https://www.casper.tw/javascript/2017/06/29/es6-native-array/#Array-prototype-reduce">文章</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN</a>。</p>
</blockquote>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例：運作原理</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">15</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`比較 a: <span class="hljs-subst">$&#123;a&#125;</span>，b: <span class="hljs-subst">$&#123;b&#125;</span>`</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(arr);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 比較 a: 3，b: 17</span><br><span class="hljs-comment">// 比較 a: 22，b: 3</span><br><span class="hljs-comment">// 比較 a: 15，b: 22</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p><code>sort</code> 可以將陣列中的項目進行排序，如果要針對<strong>數字</strong>進行排序，需要在括號中加入一個函式（compareFunction）與兩個參數，然後會根據兩個參數的回傳值來進行排序；從上述的輸出結果可以發現，函式中的參數位置 <code>a</code> 皆為順序在後的值、<code>b</code> 皆為順序在前的值，且每次都是後者去與前者進行比較，在參數 <code>a</code> 與 <code>b</code> 比較時，會根據以下邏輯來進行排序：</p>
<ul>
<li>若函式的回傳值小於 0，<code>a</code> 會排在 <code>b</code> 前面。</li>
<li>若函式的回傳值大於 0，<code>b</code> 會排在 <code>a</code> 前面。</li>
<li>若函式的回傳值為 0，<code>a</code> 與 <code>b</code> 位置不變（兩個相同值的排序位置，會根據瀏覽器而有所差異）。</li>
</ul>
<p>如此一來，在比較陣列中的數值時，就可以透過將兩個參數相減，並根據回傳的結果是正值或負值來自訂排序的順序。</p>
<p><strong>範例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 由小到大排序</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">const</span> newArr = arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> - <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a-b&#125;</span>`</span>);<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(newArr);<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// 3 - 17 = -14 // 結果為負值，因此 a（17）排在 b（3）之前，後面依此類推。</span><br><span class="hljs-comment">// 22 - 3 = 19</span><br><span class="hljs-comment">// 22 - 17 = 5</span><br><span class="hljs-comment">// 15 - 17 = -2</span><br><span class="hljs-comment">// 15 - 3 = 12</span><br><span class="hljs-comment">// [3, 15, 17, 22]</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>上述輸出結果能看到每次在比較時，參數 <code>a</code> 與 <code>b</code> 所代入的值，且同時會根據回傳結果排序兩數值的前後順序。</p>
<blockquote>
<p>使用 <code>sort()</code> 時，若不加入 compareFunction，陣列中的數值會被轉換成字串，並以 Unicode 編碼位置進行比較來排序，本篇僅論數字的排序方法，相關內容可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">MDN</a>。</p>
</blockquote>
<h2 id="AJAX-簡述"><a href="#AJAX-簡述" class="headerlink" title="AJAX 簡述"></a>AJAX 簡述</h2><p>AJAX（Asynchronous JavaScript and XML）是一種非同步的 JavaScript 與 XML 技術，主要的功用是能夠讓網頁在更新內容時，不需要重新載入整個頁面，達到網址不需要變動就能夠更新局部內容效果。</p>
<h3 id="網路請求"><a href="#網路請求" class="headerlink" title="網路請求"></a>網路請求</h3><p>網路請求（HTTP Request）簡單來說，就是使用者向伺服器發出請求後，伺服器經驗證再從資料庫取得資料，並提供給使用者的過程。以瀏覽器來說，輸入網址並按下 Enter，就屬於網路請求的一種。</p>
<p>以下方原始碼為例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-hant&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx/xxx/img.png&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 第二次請求 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./all.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- 第三次請求 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>當網址送出時，瀏覽器會向伺服器發出一次網路請求，若確認網址無誤，便會回傳資料庫內容給瀏覽器，接著開始載入並解析 HTML 結構，若存在如上述範例第 11 行的 <code>img</code> 圖片網址等相關內容，就會再發出一次請求，以上述範例來說，總共對伺服器發出三次網路請求。</p>
<blockquote>
<p>網路請求並非同時進行，以上述範例來說，是先載入 HTML 結構，再由上往下依序判斷程式碼。而網路請求的順序與相關內容可從開發人員工具 ➔ Network 查看（需重新整理頁面）。</p>
</blockquote>
<h3 id="狀態碼"><a href="#狀態碼" class="headerlink" title="狀態碼"></a>狀態碼</h3><p>HTTP 狀態碼是伺服器端回應請求結果的狀態，根據不同的請求結果所回應的狀態碼也會不同，常見的狀態碼如 200（請求成功）、404（伺服器找不到請求的資源）、500（伺服器端錯誤）等。</p>
<blockquote>
<p>狀態碼可從開發人員工具 ➔  Network ➔ Status 查看，HTTP 狀態碼相關內容可參考此<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status">連結</a>。</p>
</blockquote>
<h3 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request / Response"></a>Request / Response</h3><p>Request 即瀏覽器發出的請求，而 Response 為伺服器端回傳的內容，兩者的相關資訊可從開發人員工具 ➔ Network ➔ Headers 中查看，以瀏覽器發出請求的基本資訊來說，主要會記錄在 Request Headers 中，而伺服器端的回應資訊則是會記錄在 Response Headers 內。</p>
<p>除了請求與回傳的基本資訊外，伺服器端所回傳的主要資料內容，可以在開發人員工具 ➔ Network ➔ Response 中查看。</p>
<h3 id="JavaScript-網路請求"><a href="#JavaScript-網路請求" class="headerlink" title="JavaScript 網路請求"></a>JavaScript 網路請求</h3><p>JavaScript 可以使用原生寫法 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest">XMLHttpRequert</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Fetch_API/Using_Fetch">Fetch</a>，或是透過套件 <a href="https://github.com/axios/axios">axios</a> 來發出網路請求，而本篇以 axios 來做說明。</p>
<h4 id="環境安裝"><a href="#環境安裝" class="headerlink" title="環境安裝"></a>環境安裝</h4><p><strong>NPM</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">$ npm install axios<br></code></pre></td></tr></table></figure>

<p><strong>CDN</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h4><p><strong>GET 請求</strong></p>
<p><code>get</code> 請求只應用於<strong>取得資料</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 網址來源為 JSONPlaceholder 假資料</span><br>axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response.data); <span class="hljs-comment">// 主要資料內容</span><br>    <span class="hljs-built_in">console</span>.log(response.status); <span class="hljs-comment">// 狀態碼</span><br>    <span class="hljs-comment">// console.log(response.statusText);</span><br>    <span class="hljs-comment">// console.log(response.headers);</span><br>    <span class="hljs-comment">// console.log(response.config);</span><br>  &#125;);<br><span class="hljs-comment">// 回傳結果 ----</span><br><span class="hljs-comment">// &#123;data: &#123;…&#125;, status: 200, statusText: &#x27;&#x27;, headers: &#123;…&#125;, config: &#123;…&#125;, …&#125;</span><br><span class="hljs-comment">// config: &#123;transitional: &#123;…&#125;, transformRequest: Array(1), transformResponse: Array(1), timeout: 0, adapter: ƒ, …&#125;</span><br><span class="hljs-comment">// data: &#123;userId: 1, id: 1, title: &#x27;delectus aut autem&#x27;, completed: false&#125;</span><br><span class="hljs-comment">// headers: &#123;cache-control: &#x27;max-age=43200&#x27;, content-type: &#x27;application/json; charset=utf-8&#x27;, expires: &#x27;-1&#x27;, pragma: &#x27;no-cache&#x27;&#125;</span><br><span class="hljs-comment">// request: XMLHttpRequest &#123;onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …&#125;</span><br><span class="hljs-comment">// status: 200</span><br><span class="hljs-comment">// statusText: &quot;&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// 200</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>get</code> 發出請求時，第一個參數會帶入資料的網址，當伺服器的資料成功回傳時，<code>.then</code> 函式就會執行，而回傳資料的型態會整理成物件，並帶入參數 <code>response</code> 中，因此可透過點記法來取得屬性資料。</p>
<p>接著，嘗試將資料中的 <code>title</code> 屬性內容呈現在網頁上，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> title = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.title&#x27;</span>);<br>    title.textContent = response.data.title;<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>POST 請求</strong></p>
<p><code>post</code> 方法用於<strong>提交指定資料</strong>，以提供伺服器進行驗證，並依驗證結果成功與否回傳對應內容；當瀏覽器透過 <code>post</code> 發出請求或是接收伺服器回傳的資訊時，都會夾帶 headers 資訊（開發人員工具 ➔ Network ➔ Headers）以及 data 資料（開發人員工具 ➔ Network ➔ Payload）。</p>
<p>此外，data 的資料格式又有好幾種分別，常見的資料格式（Content-Type）如下：</p>
<ol>
<li>application/x-www-form-urlencoded</li>
<li>application/json</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ol>
<blockquote>
<p>axios 預設使用的資料格式為 application/json，本篇未記載其他資料格式與轉換方式（沒有研究），Content-Type 相關內容可參考此<a href="https://www.796t.com/article.php?id=192469">文章</a>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// axios post 範例</span><br>axios.post(url, &#123;  <span class="hljs-comment">// post(url, obj)</span><br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Amy&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Lin&#x27;</span><br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>若是透過 <code>post</code> 發出請求，則會帶入兩個參數，分別是網址與傳送至伺服器端的 data 資料（物件格式且屬性與伺服器相同），這個 data 會對應到瀏覽器發出請求時，所夾帶的 data 內容，而 <code>.then</code> 與 <code>.catch</code> 則分別會回傳請求成功或失敗的對應資訊。</p>
<p><strong>POST 應用範例</strong></p>
<p>下列為 <a href="https://github.com/hexschool/nodejs_ajax_tutorial">六角學院練習用 API</a>：</p>
<p><em><strong>註冊</strong></em> - 新增一個帳號</p>
<ul>
<li><p><strong>Method:</strong> <code>POST</code></p>
</li>
<li><p><strong>URL:</strong> <code>https://hexschool-tutorial.herokuapp.com/api/signup</code></p>
</li>
<li><p><strong>Data:</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;lovef2e@hexschool.com&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;12345678&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Success Response:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;帳號註冊成功&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Error Response:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;此帳號已被使用&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>登入</strong></em> - 登入一個已存在的帳號</p>
<ul>
<li><p><strong>Method:</strong> <code>POST</code></p>
</li>
<li><p><strong>URL:</strong> <code>https://hexschool-tutorial.herokuapp.com/api/signin</code></p>
</li>
<li><p><strong>Data:</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;lovef2e@hexschool.com&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;12345678&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Success Response:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;登入成功&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Error Response:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;result&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;此帳號不存在或帳號密碼錯誤&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>在上述文件註冊或登入內文中，可以看到 Method（請求方法）、URL（伺服器網址路徑）、Data（傳送至伺服器的資料格式）、Success Response（請求成功的回傳內容）以及 Error Response（請求失敗的回傳內容）。</p>
<blockquote>
<p>不同伺服器的請求格式規範也會不同。</p>
</blockquote>
<p>以上述範例 API 為例，嘗試使用 axios 來進行註冊的 post 網路請求，如下所示：</p>
<p><strong>範例一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;</span>;<br><span class="hljs-keyword">let</span> data = &#123;<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;testacc123@gmail.com&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;testpwd456&#x27;</span><br>&#125;<br>axios.post(url, data)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>    .console.log(error);<br>  &#125;)<br><span class="hljs-comment">// 回傳結果 ----</span><br><span class="hljs-comment">// config: &#123;transitional: &#123;…&#125;, transformRequest: Array(1), transformResponse: Array(1), timeout: 0, adapter: ƒ, …&#125;</span><br><span class="hljs-comment">// data: &#123;success: true, result: &#123;…&#125;, message: &#x27;帳號註冊成功&#x27;&#125;</span><br><span class="hljs-comment">// headers: &#123;content-length: &#x27;59&#x27;, content-type: &#x27;application/json; charset=utf-8&#x27;&#125;</span><br><span class="hljs-comment">// request: XMLHttpRequest &#123;onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …&#125;</span><br><span class="hljs-comment">// status: 200</span><br><span class="hljs-comment">// statusText: &quot;OK&quot;</span><br><span class="hljs-comment">// [[Prototype]]: Object</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>在上述回傳資訊中可以看到各種屬性與其對應的值，狀態碼 <code>200</code> 表示請求成功，其中物件 <code>data</code> 的值與範例 API 文件的 Success Response 內容相同。</p>
<p><strong>範例二</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;account&quot;</span>&gt;</span>帳號：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密碼：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;送出&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> account = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#account&#x27;</span>);<br><span class="hljs-keyword">const</span> password = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#password&#x27;</span>);<br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>);<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  callSignUp();<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSignUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(account.value == <span class="hljs-string">&#x27;&#x27;</span> || password.value == <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    alert(<span class="hljs-string">&#x27;帳號或密碼不得為空白！&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  data.email = account.value;<br>  data.password = password.value;<br>  <br>  axios.post(<span class="hljs-string">&#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;</span>, data)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response.data);<br>    alert(response.data.message);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="axios-非同步觀念"><a href="#axios-非同步觀念" class="headerlink" title="axios 非同步觀念"></a>axios 非同步觀念</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = [];<br>axios.get(<span class="hljs-string">&#x27;url&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>    data.push(response.data);<br>    <span class="hljs-built_in">console</span>.log(data, <span class="hljs-number">1</span>); <span class="hljs-comment">// 位置 1</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(data, <span class="hljs-number">2</span>); <span class="hljs-comment">// 位置 2</span><br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// [] 2</span><br><span class="hljs-comment">// [&#123;…&#125;] 1</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>以上述範例來說，第 5 行將伺服器回傳的內容賦予至陣列 <code>data</code> 中，因此從位置一的輸出結果可以看到值有被賦予到陣列中，但是位置二的輸出結果卻是空陣列，而導致這種結果的原因是，當 axios 在發出網路請求時，為了避免資料過於龐大而導致網頁渲染出現延遲等問題，因此伺服器即使尚未將資料回傳至瀏覽器，後方程式碼依然會繼續執行，直到所有資料都回傳完畢，<code>.then</code> 的函式才會執行並將資料內容帶入變數 <code>response</code> 中，而從輸出結果也能看到，程式碼的執行順序是位置 2 ➔ 位置 1。</p>
<p><strong>透過函式處理非同步</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = [];<br>axios.get(<span class="hljs-string">&#x27;url&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>    data.push(response.data);<br>    <span class="hljs-built_in">console</span>.log(data, <span class="hljs-number">1</span>); <span class="hljs-comment">// 位置 1</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;資料已回傳&#x27;</span>);<br>    renderData();<br>&#125;)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(data, <span class="hljs-number">2</span>); <span class="hljs-comment">// 位置 2</span><br>&#125;<br><span class="hljs-comment">// 輸出結果 ----</span><br><span class="hljs-comment">// [&#123;…&#125;] 1</span><br><span class="hljs-comment">// 資料已回傳</span><br><span class="hljs-comment">// [&#123;…&#125;] 2</span><br><span class="hljs-comment">// ----</span><br></code></pre></td></tr></table></figure>

<p>如上述範例所示，將位置 2 的程式碼透過函式 <code>renderData()</code> 包裝並寫入 <code>.then</code> 函式中，從輸出結果可看到執行順序為位置 1 ➔ 完成資料回傳 ➔ 位置 2，並且陣列 <code>data</code> 也成功被賦予值。</p>
<p>原因是 <code>.then</code> 函式會等待資料回傳到瀏覽器後才執行，而函式 <code>renderData()</code> 的執行位置也在函式 <code>.then</code> 之中，所以資料回傳後就會依序執行函式中的程式碼，如此一來，就能確保伺服器的資料回傳完畢後，程式碼能夠同步被執行。</p>
<p><strong>非同步處理範例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js</span><br><span class="hljs-keyword">let</span> data = [];<br>axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;資料已回傳&#x27;</span>);<br>    dataTitle = response.data.title;<br>    renderData();<br>&#125;)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> title = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.title&#x27;</span>);<br>  title.textContent = dataTitle;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述 JS 範例中， 因為函式 <code>renderData()</code> 位置在第 7 行，而函式 <code>.then</code> 在伺服器回傳資料給瀏覽器後就依序執行，換言之，函式 <code>renderData()</code> 會在 <code>dataTitle</code> 被賦予值（第 6 行）之後執行，因此第 11 行 <code>title</code> 才能正確讀取到 <code>dataTitle</code> 的值，並渲染純文字在畫面中。</p>
<h2 id="函式-延伸內容"><a href="#函式-延伸內容" class="headerlink" title="函式-延伸內容"></a>函式-延伸內容</h2><h3 id="陳述式與表達式"><a href="#陳述式與表達式" class="headerlink" title="陳述式與表達式"></a>陳述式與表達式</h3><p>JavaScript 函式建立的方式有以下兩種：</p>
<p><strong>函式陳述式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">statement</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br>statement();<br><span class="hljs-comment">// 輸出結果為 Hello!</span><br></code></pre></td></tr></table></figure>

<p>以上範例是先前提到的類型，這種直接具名的形式稱為<strong>函式陳述式</strong>（Function Statement），這種直接宣的告函式，可以在函式被宣告之前呼叫，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">statement(); <span class="hljs-comment">// 在函式註冊之前執行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">statement</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 輸出結果為 Hello!</span><br></code></pre></td></tr></table></figure>

<p><strong>函式表達式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> expression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br>expression();<br></code></pre></td></tr></table></figure>

<p>另一種形式是將一個匿名的函式指定到一個變數中，這種形式稱為<strong>函式表達式</strong>（Function Expression），與陳述式的差別在於，表達式函式的呼叫位置如果在該函式被建立之前，該函式就無法執行，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">expression(); <span class="hljs-comment">// 在函式註冊之前執行</span><br><span class="hljs-keyword">const</span> expression = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 顯示錯誤</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>函式陳述式與表達式的運行差異與 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting">Hosting</a>（提升）有關，而 <code>var</code> 的提升現象與 <code>let</code>、<code>const</code> 也有所差異，這裡不討論。</p>
</blockquote>
<h3 id="箭頭函式"><a href="#箭頭函式" class="headerlink" title="箭頭函式"></a>箭頭函式</h3><p>一般函式的組成結構會有關鍵字 <code>function</code> 加上函式名稱、<code>()</code> 中的參數列表、<code>&#123;&#125;</code> 中的主要程式碼，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 普通函式一</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcName</span>(<span class="hljs-params">num, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num + num2;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 普通函式二</span><br><span class="hljs-keyword">let</span> funcName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num + num2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而箭頭函式在寫法上相較一般函式來得簡短，以上述範例來說，箭頭函式的寫法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 箭頭函式</span><br><span class="hljs-keyword">let</span> funcName = <span class="hljs-function">(<span class="hljs-params">num, num2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> num + num2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述範例可以看到關鍵字 <code>function</code> 被省略，而參數列表與主要程式碼之間加入了 <code>=&gt;</code> 符號，用來表示這是一個箭頭函式。</p>
<p>除此之外，箭頭函式的主要程式碼中，如果<strong>只存在一個回傳值敘述</strong>（return）而沒有其他程式碼時，可以將回傳值寫入一個小括號中，或是<strong>只寫回傳值</strong>，而大括號、<code>return</code> 與回傳值的結尾分號可以省略，以下方範例來說，兩者結果相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 箭頭函式（簡化）</span><br><span class="hljs-keyword">let</span> funcName = <span class="hljs-function">(<span class="hljs-params">num, num2</span>) =&gt;</span> (num + num2);<br><span class="hljs-keyword">let</span> funcName = <span class="hljs-function">(<span class="hljs-params">num, num2</span>) =&gt;</span> num + num2;<br></code></pre></td></tr></table></figure>

<p>最後，如果箭頭函式的參數只存在一個，則包覆參數列表的小括號也能省略，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> funcName = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>箭頭函式若沒有參數，依然需要加上一組小括號來表示參數列表。</p>
</blockquote>
<p>這裡補上不可以簡化的箭頭函式，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 箭頭函式（不可簡化）</span><br><span class="hljs-keyword">let</span> funcName = <span class="hljs-function">(<span class="hljs-params">num, num2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> result = num + num2; <span class="hljs-comment">// 存在除了 return 以外的程式碼</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.796t.com/article.php?id=192469">前端利用formData格式進行資料上傳，前端 formData 傳值和 json 傳值的區別？</a><br><a href="https://www.casper.tw/javascript/2017/06/29/es6-native-array/#Array-prototype-reduce">JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()]</a><br><a href="https://www.fooish.com/javascript/array/sort.html#%E8%87%AA%E5%AE%9A%E7%BE%A9%E6%8E%92%E5%BA%8F-custom-sort">JavaScript Array sort() (陣列排序)</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
</search>
